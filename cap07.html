<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBA Acidental</title>
    <link rel="stylesheet" href="estilo/style.css">
    <link rel="stylesheet" href="estilo/media-queries.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
</head>

<body onresize="mudouTamanho()">
    <header>
        <h1>Troubleshooting SQL Server</h1>
        <h2>Um Guia para o DBA Acidental</h2>
    </header>

    <nav>
        <i id="burger" class="material-icons" onclick="clickMenu()">menu</i>
        <menu id="itens">
            <ul>
                <li><a href="index.html" target="_self"><i id="home" class="material-icons">home</i></a></li>
                <li><a href="abertura.html" target="_self">Abertura</a></li>
                <li><a href="introducao.html" target="_self">Introdução</a></li>
                <li><a href="cap01.html" target="_self">Cap.1</a></li>
                <li><a href="cap02.html" target="_self">Cap.2</a></li>
                <li><a href="cap03.html" target="_self">Cap.3</a></li>
                <li><a href="cap04.html" target="_self">Cap.4</a></li>
                <li><a href="cap05.html" target="_self">Cap.5</a></li>
                <li><a href="cap06.html" target="_self">Cap.6</a></li>
            </ul>
        </menu>
    </nav>

    <main>
        <h1>Capítulo 7: Lidando com Deadlocks</h1>

        <p>Um deadlock é definido no dicionário como "uma paralisação resultante da ação de forças iguais e opostas", e isso acaba sendo uma descrição razoável de um deadlock no SQL Server: duas ou mais sessões dentro do mecanismo do banco de dados acabam aguardando acesso a recursos bloqueados mantidos um pelo outro. Em uma situação de deadlock, nenhuma das sessões pode continuar a executar até que uma dessas sessões libere seus bloqueios, permitindo assim que a(s) outra(s) sessão(ões) acesse(m) o recurso bloqueado. Múltiplos processos bloqueando persistentemente uns aos outros, em um estado insolúvel, eventualmente resultarão em uma interrupção no processamento dentro do mecanismo do banco de dados.</p>

        <p>Um equívoco comum é que os DBAs precisam intervir para "matar" um dos processos envolvidos em um deadlock. Na verdade, o SQL Server é projetado para detectar e resolver deadlocks automaticamente, por meio do uso do <strong>Lock Monitor</strong>, um processo em segundo plano que é iniciado quando a instância do SQL Server é iniciada e que monitora constantemente o sistema em busca de sessões em deadlock. No entanto, quando os deadlocks são relatados, o DBA deve investigar sua causa imediatamente. Muitos dos mesmos problemas que causam bloqueios graves no banco de dados, como design de banco de dados inadequado, falta de indexação, consultas mal projetadas, nível de isolamento inadequado e assim por diante (todos discutidos no <a href="cap06.html" target="_self">Capítulo 6</a>), também são causas comuns de deadlocks. Este capítulo fornecerá as ferramentas, técnicas e ajustes necessários para diagnosticar e prevenir deadlocks, e garantir que eles sejam tratados com elegância, caso ocorram. Especificamente, ele abordará:</p>

        <ul>
            <li>como capturar gráficos de deadlock usando uma variedade de técnicas, incluindo Flags de Rastreamento, o evento de gráfico de deadlock do Profiler e notificações de eventos do service broker</li>
            <li>como ler gráficos de deadlock para localizar as sessões, consultas e recursos envolvidos</li>
            <li>tipos comuns de deadlock e como evitá-los</li>
            <li>usando tratamento de erro <code>TRY...CATCH</code> no servidor ou no cliente para deadlocks, para evitar erros <code>UnhandledException</code> na aplicação.</li>
        </ul>

        <h2 id="lockmonitor">Lock Monitor</h2>

        <p>Quando o Monitor de Bloqueio realiza uma busca por deadlock e detecta que uma ou mais sessões estão envolvidas em um deadlock, uma das sessões é selecionada como vítima do deadlock e sua transação atual é revertida. Quando isso ocorre, todos os bloqueios mantidos pela sessão da vítima são liberados, permitindo que qualquer outra sessão previamente bloqueada continue processando. Uma vez que a reversão é concluída, a sessão da vítima é terminada, retornando uma mensagem de erro 1205 para o cliente de origem.</p>

        <p>O SQL Server seleciona a vítima do deadlock com base nos seguintes critérios:</p>

        <ol>
            <li><strong>Prioridade de deadlock</strong> – a DEADLOCK_PRIORITY atribuída a uma determinada sessão determina a importância relativa de completar suas transações, caso essa sessão esteja envolvida em um deadlock. A sessão com a menor prioridade será sempre escolhida como a vítima do deadlock. A prioridade de deadlock é abordada em mais detalhes mais adiante neste capítulo.</li>
            <li><strong>Custo de reversão </strong>– se duas ou mais sessões envolvidas em um deadlock tiverem a mesma prioridade de deadlock, o SQL Server escolherá como vítima do deadlock a sessão que tiver o menor custo estimado de reversão.</li>
        </ol>

        <h2 id="capgraf">Capturando Gráficos de Deadlock</h2>

        <p>Quando erros 1205 são relatados, é importante que o DBA descubra por que o deadlock aconteceu e tome medidas para evitar sua recorrência. O primeiro passo para solucionar e resolver um problema de deadlock é capturar as informações do <strong>gráfico de deadlock</strong>.</p>

        <p>Um gráfico de deadlock é uma saída de informações sobre as sessões e recursos que estiveram envolvidos em um deadlock. Os meios pelos quais você pode capturar um gráfico de deadlock se diversificaram e melhoraram nas versões mais recentes do SQL Server. Se você ainda está usando o SQL Server 2000, então está limitado a um único, e um tanto limitado, Trace Flag (1204). O SQL Server 2005 adicionou um novo Trace Flag (1222), forneceu o evento <strong>Gráfico de Deadlock em XML</strong> no SQL Server Profiler e permitiu a captura de gráficos de deadlock via notificações de eventos do Service Broker e do Provedor WMI (Instrumentação de Gerenciamento do Windows) para Eventos do Servidor. Em cada caso, o gráfico de deadlock contém significativamente mais informações sobre a natureza do deadlock do que está disponível através do Trace Flag 1204. Isso minimiza a necessidade de reunir, manualmente, informações adicionais do SQL Server para entender por que o deadlock ocorreu; por exemplo, resolver o <code>pageid</code> dos bloqueios sendo mantidos para o <code>objectid</code> e <code>indexid</code>, usando <code>DBCC PAGE</code>, e usar SQL Trace para percorrer a cadeia de deadlock e descobrir quais declarações em execução estão causando o problema. O SQL Server 2008 fornece todas essas facilidades, além da sessão de Eventos Estendidos <code><strong>system_health</strong></code>.</p>

        <p>Para permitir que você trabalhe em cada seção e gere os mesmos gráficos de deadlock que são apresentados e descritos no texto, os materiais de recursos deste livro (<a href="http://www.simple-talk.com/RedGateBooks/JonathanKehayias/TroubleshootingSQLServer_Code.zip" target="_blank">http://www.simple-talk.com/RedGateBooks/JonathanKehayias/TroubleshootingSQLServer_Code.zip</a>) incluem código de exemplo para gerar um deadlock no SQL Server.</p>

        <h3 id="traceflag1204">Trace Flag 1204</h3>

        <p>Os Trace Flags no SQL Server permitem "caminhos de código" alternativos em pontos chave dentro do motor de banco de dados, permitindo que código adicional seja executado quando necessário. Se você estiver enfrentando falhas em consultas com erros de deadlock em uma instância do SQL Server, os Trace Flags podem ser ativados para uma única sessão ou para todas as sessões naquela instância. Quando o Trace Flag 1204 está habilitado para todas as sessões em uma instância do SQL Server, qualquer deadlock detectado pelo monitor de deadlock resultará na escrita de um gráfico de deadlock no log de erros do SQL Server.</p>

        <p>No SQL Server 2000, este Trace Flag é o único meio de capturar um gráfico de deadlock, o que torna a solução de problemas de deadlocking no SQL Server 2000 bastante desafiadora, embora ainda possível. Nas versões mais recentes do SQL Server, este Trace Flag ainda está disponível, embora tenha sido substituído pelo Trace Flag 1222.</p>

        <p>O Trace Flag 1204, assim como todos os Trace Flags, pode ser ativado e desativado de forma ad hoc usando os comandos <code>DBCC TRACEON</code> e <code>DBCC TRACEOFF</code> no console do banco de dados. A Listagem 7.1 mostra como habilitar o Trace Flag 1204 a curto prazo no nível do servidor (especificado pelo argumento -1), de modo que todas as declarações subsequentes sejam executadas com este Trace Flag habilitado.</p>
        <div id="container">
            <pre><code>
DBCC TRACEON(1204, -1)
            </code></pre>
        </div>

        <p class="legenda"><strong>Listagem 7.1:</strong> Habilitando o Trace Flag 1204 para todas as sessões.</p>
        
        <p>Alternativamente, os Trace Flags podem ser ativados automaticamente, utilizando o parâmetro de inicialização –T. Para adicionar um parâmetro de inicialização ao SQL Server, clique com o botão direito do mouse no nó do servidor no <strong>Enterprise Manager</strong> e abra a página de <strong>Propriedades do Servidor</strong>. Na aba <strong>Geral</strong>, clique no botão <strong>Parâmetros de Inicialização</strong> e, em seguida, adicione o parâmetro de inicialização ao servidor, conforme mostrado na Figura 7.1.</p>

        <img src="imagens/fig71.PNG" alt="Utilizando o parâmetro de inicialização –T." width="50%">

        <p class="legenda"><strong>Figura 7.1</strong>: Utilizando o parâmetro de inicialização –T.</p>

        <p>Nos casos em que é possível reiniciar uma instância, utilizar um parâmetro de inicialização pode ser útil quando se deseja capturar todos os deadlocks que ocorrem no servidor, ao longo de um longo período. No entanto, uma vez que a resolução de problemas de deadlock tenha sido concluída, o Trace Flag deve ser removido dos parâmetros de inicialização. Como o Trace Flag permite que a instância grave o gráfico de deadlock no log de erros do SQL Server, a única maneira de recuperar o gráfico é ler o arquivo de log de erros e, em seguida, extrair os eventos do arquivo de log para análise.</p>

        <h3 id="traceflag1222">Trace Flag 1222</h3>

        <p>O SQL Server 2005 adicionou o Trace Flag 1222 para capturar os gráficos de deadlock em um formato mais fácil de ler e mais abrangente do que o disponível com o flag 1204. Ele captura e apresenta as informações de uma maneira que torna muito mais fácil identificar a vítima do deadlock, assim como os recursos e processos envolvidos no deadlock (abordados em detalhes na seção <em>Leitura de Gráficos de Deadlock</em>).</p>

        <p>O Trace Flag 1204 ainda está disponível, por motivos de compatibilidade retroativa, mas ao usar Trace Flags para capturar gráficos de deadlock no SQL Server 2005 ou posterior, você deve sempre usar o Trace Flag 1222 em preferência ao Trace Flag 1204. O Trace Flag 1222 é habilitado da mesma maneira que o 1204, utilizando <code>DBCC TRACEON()</code>, como mostrado no Listagem 7.1 ou o parâmetro de inicialização –T, como mostrado na Figura 7.1.</p>

        <h3 id="deadlockxml">Evento de Gráfico de Deadlock XML no SQL Profiler</h3>

        <p>Novo no SQL Server 2005, o evento <code>Deadlock Graph</code> no SQL Trace captura as informações do gráfico de deadlock, sem escrevê-las no Log de Erros do SQL Server. O evento <code>Deadlock Graph</code> faz parte da categoria de eventos <strong>Locks</strong> e pode ser adicionado a um rastreamento do SQL Server Profiler selecionando o evento na caixa de diálogo <strong>Propriedades de Rastreamento</strong> do Profiler, como mostrado na Figura 7.2.</p>
        
        <img src="imagens/fig72.PNG" alt="Selecionando o evento Deadlock Graph na caixa de diálogo Propriedades de Rastreamento.">

        <p class="legenda"><strong>Figura 7.2</strong>: Selecionando o evento <code>Deadlock Graph</code> na caixa de diálogo Propriedades de Rastreamento.</p>

        <p>SQL Profiler can be configured to save the deadlock graphs separately, into XDL files, as shown in Figure 7.3.</p>

        <img src="imagens/fig73.PNG" alt="Salvando gráficos de deadlock">

        <p class="legenda"><strong>Figura 7.3</strong>: Salvando gráficos de deadlock.</p>

        <p>Um arquivo XDL é um arquivo XML padrão. O Management Studio reconhece a extensão do arquivo ao abri-lo e exibe as informações de deadlock graficamente, em vez de como XML.</p>

        <p>Se você preferir trabalhar diretamente com traces no servidor, eliminando a sobrecarga do cliente Profiler, pode capturar as informações do gráfico de deadlock diretamente dos seus scripts, utilizando o conjunto de procedimentos armazenados do sistema <code><strong>SP_TRACE_*</strong></code>. Os gráficos capturados serão gravados em um arquivo de rastreamento SQL no SQL Server. A maneira mais fácil de gerar um script para um trace no servidor é primeiro criar o trace no SQL Profiler e, em seguida, exportá-lo para um script usando <strong>Arquivo</strong> | <strong>Exportar</strong> | <strong>Exportar Definição de Trace</strong>, conforme descrito em detalhes no <a href="cap05.html#worload" target="_self">Capítulo 5</a>.</p>

        <p>Um arquivo de trace no servidor pode ser lido usando a função de sistema <code>fn_trace_gettable</code> ou abrindo-o no SQL Profiler. Ao usar o SQL Profiler para visualizar o conteúdo do arquivo de trace, os eventos de deadlock podem ser exportados para arquivos XDL individuais, que podem ser abertos graficamente usando o SQL Server Management Studio, através do menu <strong>Arquivo</strong> | <strong>Exportar</strong> | <strong>Extrair Eventos do SQL Server</strong> | <strong>Extrair Eventos de Deadlock</strong>.</p>

        <h3 id="servicebroker">Notificações de eventos do Service Broker</h3>

        <p>Também novo no SQL Server 2005, as notificações de eventos permitem capturar informações de gráficos de deadlock usando o SQL Server Service Broker, criando um <strong>serviço</strong> e uma <strong>fila</strong> para o evento de rastreamento <code>DEADLOCK_GRAPH</code>. As informações contidas no gráfico de deadlock capturado por notificações de eventos não diferem das informações contidas no gráfico de deadlock capturado pelo SQL Trace; a única diferença é o mecanismo de captura.</p>

        <p>Configurar uma notificação de evento para capturar informações de gráficos de deadlock requer três objetos do Service Broker:</p>

        <ul>
            <li>Uma <code><strong>FILA</strong></code> para armazenar as mensagens do evento <code>DEADLOCK_GRAPH</code></li>
            <li>Um <code><strong>SERVIÇO</strong></code> para encaminhar as mensagens para a fila</li>
            <li>Uma <code><strong>NOTIFICAÇÃO DE EVENTO</strong></code> para capturar o gráfico de deadlock e empacotá-lo em uma mensagem que é enviada para o Serviço.</li>
        </ul>

        <p>A Listagem 7.2 mostra como criar esses objetos usando T-SQL. Observe que é necessário criar os objetos em um banco de dados com suporte ao broker, como o <code><strong>msdb</strong></code>. O banco de dados <code><strong>master</strong></code> não tem o broker habilitado por padrão.</p>
        
        <div id="container">
            <pre><code>
<cls>USE</cls> msdb;

<com>-- Create a service broker queue to hold the events</com>
<cls>CREATE QUEUE</cls> DeadlockQueue
<cls>GO</cls>

<com>-- Create a service broker service receive the events</com>
<cls>CREATE SERVICE</cls> DeadlockService
<cls>ON QUEUE</cls> DeadlockQueue ([http://schemas.microsoft.com/SQL/Notifications/
PostEventNotification])
<cls>GO</cls>

<com>-- Create the event notification for deadlock graphs on the service</com>
<cls>CREATE EVENT NOTIFICATION</cls> CaptureDeadlocks
<cls>ON SERVER</cls>
<cls>WITH</cls> FAN_IN
<cls>FOR</cls> DEADLOCK_GRAPH
<cls>TO SERVICE</cls> <string>'DeadlockService'</string>, <string>'current database'</string> ;
<cls>GO</cls>
            </code></pre>
        </div>
        
        <p class="legenda"><strong>Listagem 7.2</strong>: Criando os objetos de serviço, fila e notificação de evento do Service Broker.</p>

        <p>Com os objetos criados, os gráficos de deadlock serão coletados na fila à medida que os deadlocks ocorrerem no servidor. Embora a fila possa ser consultada usando uma instrução <code>SELECT</code>, como se fosse uma tabela, o conteúdo permanece na fila até que seja processado usando o comando <code>RECEIVE</code>, conforme demonstrado na Listagem 7.3.</p>

        <div id="container">
            <pre><code>

<cls>USE</cls> msdb ;

<com>-- Cast message_body to XML and query deadlock graph from TextData</com>
<cls>SELECT</cls> message_body.valuequery(<string>'(/EVENT_INSTANCE/TextData/</string>
                                 <string>deadlock-list)[1]', 'varchar(128)'</string>)
                                 <cls>AS</cls> DeadlockGraph
<cls>FROM</cls> ( <cls>SELECT</cls> CAST(message_body <cls>AS</cls> <cls>XML</cls>) <cls>AS</cls> message_body
       <cls>FROM</cls> DeadlockQueue
     ) <cls>AS</cls> sub ;
<cls>GO</cls>

<com>-- Receive the next available message FROM the queue</com>
DECLARE @message_body <cls>XML</cls> ;

<cls>RECEIVE TOP</cls>(1) -- just handle one message at a time
@message_body=message_body
<cls>FROM</cls> DeadlockQueue ;

<com>-- Query deadlock graph from TextData</com>
<cls>SELECT</cls> @message_body.valuequery(<string>'(/EVENT_INSTANCE/TextData/</string>
                                  <string>deadlock-list)[1]','varchar(128)'</string>)
                                  <cls>AS</cls> DeadlockGraph
<cls>GO</cls>
            </code></pre>
        </div>
        
        <p class="legenda"><strong>Listing 7.3</strong>: Query and processing DEADLOCK_GRAPH event messages in the queue.</p>
        
        <p>Since Event Notifications utilize a service broker queue for processing, additional actions can be performed when the deadlock event fires. When a deadlock event occurs, Service Broker can "activate" a stored procedure that processes the message and responds appropriately, for example, by sending an email notification using Database Mail, logging the event in a table, or gathering additional information, like the execution plans for both statements, from SQL Server, based on the information contained inside of the deadlock graph. Full coverage of this topic is beyond the scope of this chapter. However, a full example of how to use queue activation to completely automate deadlock collection can be found in the code download file for this book.</p>

        <p>WMI Provider for server events</p>

        <p>Also new to SQL Server 2005, the WMI Provider for Server Events allows WMI to be used to monitor SQL Server events as they occur. Any event that can be captured through event notifications has a corresponding WMI Event Object, and any WMI managementapplication can subscribe to these event objects.</p>

        <p>SQL Server Agent was updated to manage WMI events, through the use of WMI Query Language (WQL), a query language similar to T-SQL that is used with WMI and Agent Alerts for WMI events.</p>

        <p>A full example of how to create a SQL Agent alert to capture and store deadlock graphs is out of scope for this chapter, and can be found in the Books Online Sample, Creating a SQL Server Agent Alert by Using the WMI Provider for Server Events (http://msdn.microsoft.com/en-us/library/ms186385.aspx). However, in essence, it involves creating, via the WMI Event Provider, a SQL Agent alert to monitor deadlock graph events. The alert queries for events using WQL, and when it receive notification that one has occurred, it fires a job that captures the deadlock graph in a designated SQL Server table.</p>

        <p>To capture deadlock graphs using the WMI Event Provider and a SQL Agent alert in thismanner requires that the "Replace tokens for all job responses to alerts" in SQL Server Agent Alert System properties must be enabled. It also requires that Service Broker (which processes the notification messages) is enabled in msdb as well as the database in which the deadlock graphs are stored.</p>

        <p>WMI event provider bug</p>

        <p>It is worth noting that there is a known bug in the WMI Event Provider for server names that exceed fourteen characters; this was fixed in Cumulative Update 5 for SQL Server 2005 Service Pack 2.</p>

        <p>Extended Events</p>

        <p>Prior to SQL Server 2008, there was no way to retroactively find deadlock information. Obtaining deadlock graphs required that a SQL Trace was actively running, or that Trace Flag 1222 or 1205 was turned on for the instance. Since tracing deadlocks by either of these methods can be resource intensive, this usually meant that a series of deadlocks had to occur to prompt starting a trace or enabling the Trace Flags.</p>
        
        <p>SQL Server 2008 includes all of the previously discussed techniques for capturing deadlock graphs, and adds one new one, namely collecting the deadlock information through the system_health default event session in Extended Events. This default event session (akin, in concept, to the default trace) is running by default on all installations of SQL Server 2008 and collects a range of useful troubleshooting information for errors that occur in SQL Server, including deadlocks. Deadlock graphs captured by Extended Events in SQL Server 2008 have the unique ability to contain information about multi-victim deadlocks (deadlocks where more than session was killed by the Lock Monitor to resolve the conflict).</p>

        <p>More on Extended Events</p>

        <p>We can't cover Extended Events in detail in this book but, for a good overview of the topic, read Paul Randal's article, "SQL 2008: Advanced Troubleshooting with Extended Events" (http://technet.microsoft.com/en-us/magazine/2009.01.sql2008.aspx).</p>

        <p>The system_health session uses a ring_buffer target which stores the information collected by events firing in memory as an XML document in the sys.dm_xe_session_targets DMV. This DMV can be joined to the sys.dm_xe_sessions DMV to get the session information along with the data stored in the ring_buffer target, as shown in Listing 7.4.</p>

        <div>
            <pre>
                <code>
SELECT CAST(target_data AS XML) AS TargetData
FROM sys.dm_xe_session_targets st
JOIN sys.dm_xe_sessions s ON s.address = st.event_session_address
WHERE name = 'system_health'
                </code>
            </pre>
        </div>
        
        <p>Listing 7.4: Retrieving system_health session information.</p>
        
        <p>The query in Listing 7.5 shows how to retrieve a valid XML deadlock graph from the default system_health session using XQuery, the target_data column, and a CROSS APPLY to get the individual event nodes. Note that, due to changes in the deadlock graph to support multi-victim deadlocks, and to minimize the size of the event data, the resulting XML cannot be saved as an XDL file for graphical representation.</p>

        <div>
            <pre>
                <code>
SELECT CAST(event_data.value('(event/data/value)[1]',
'varchar(max)') AS XML) AS DeadlockGraph
FROM ( SELECT XEvent.query('.') AS event_data
FROM ( -- Cast the target_data to XML
SELECT CAST(target_data AS XML) AS TargetData
FROM sys.dm_xe_session_targets st
JOIN sys.dm_xe_sessions s
ON s.address = st.event_session_address
WHERE name = 'system_health'
AND target_name = 'ring_buffer'
) AS Data -- Split out the Event Nodes
CROSS APPLY TargetData.nodes('RingBufferTarget/
event[@name="xml_deadlock_report"]')
AS XEventData ( XEvent )
) AS tab ( event_data )
                </code>
            </pre>
        </div>
        
        <p>Listing 7.5: Retrieving an XML deadlock graph.</p>
        
        <p>Note, also, that there is a bug in the RTM release of SQL Server 2008 that causes deadlock graphs not to be captured and retained in an Extended Events session. This bug was fixed in Cumulative Update 1 for SQL Server 2008 and is also included in the latest Service Pack. An additional bug exists for malformed XML in the deadlock graph generated by Extended Events, which was corrected in Cumulative Update Package 6 for SQL Server 2008 Service Pack 1. It is still possible to generate a valid XML document in these earlier builds, by hacking the deadlock graph being output by Extended Events. However, since the fix to SQL Server has already been released, the specifics of the work-around will not be covered in this chapter.</p>
        
        <p>Changes to Extended Events in SQL Server Denali</p>

        <p>At the time of the final edits of this chapter, SQL Server Denali CTP3 was released, with changes associated to how the Extended Events targets store XML data inside of the value element of the Event XML output. Listing 7.5 shows the use of the .value() method from XML in SQL Server, but in Denali CTP3, a .query() method has to be used to retrieve the deadlock graph from the Event XML output.</p>

        <p>Reading Deadlock Graphs</p>
        
        <p>The precise format of the deadlock graph in SQL Server has changed from version to version, and mainly for the better. In general, it now contains better information in an easier-to-digest format, such as the graphical display provided in SQL Server Management Studio and SQL Profiler, so allowing us to more easily troubleshoot deadlocks.</p>

        <p>Even with the changes to the deadlock graph XML that is output by Extended Events, in SQL Server 2008, the fundamentals of how to interpret the graph are the same as for any other XML deadlock graph.</p>

        <p>Interpreting Trace Flag 1204 deadlock graphs</p>

        <p>Perhaps one of the most difficult aspects of troubleshooting deadlocks in SQL Server 2000 is interpreting the output of Trace Flag 1204. The process is complicated by the need to query the sysobjects and sysindexes system tables to find out exactly what objects are involved in the deadlock.</p>

        <p>Listing 7.6 shows an example deadlock graph that was generated by enabling Trace Flag 1204, and then creating a deadlock situation (the code to do this is provided as part of the code download for this book).</p>
        
        <div>
            <pre>
                <code>
Deadlock encountered .... Printing deadlock information
Wait-for graph
Node:1
KEY: 13:1993058136:2 (08009d1c9ab1) CleanCnt:2 Mode: S Flags: 0x0
Grant List 0::
Owner:0x567e7660 Mode: S Flg:0x0 Ref:1 Life:00000000 SPID:54 ECID:0
SPID: 54 ECID: 0 Statement Type: SELECT Line #: 3
Input Buf: Language Event: WHILE (1=1)
BEGIN
INSERT INTO #t1 EXEC BookmarkLookupSelect 4
TRUNCATE TABLE #t1
END
Requested By:
ResType:LockOwner Stype:'OR' Mode: X SPID:55 ECID:0 Ec:(0x26F7DBD8)
Value:0x58f80880 Cost:(0/3C)
Node:2
KEY: 13:1993058136:1 (040022ae5dcc) CleanCnt:2 Mode: X Flags: 0x0
Grant List 1::
Owner:0x58f80940 Mode: X Flg:0x0 Ref:0 Life:02000000 SPID:55 ECID:0
SPID: 55 ECID: 0 Statement Type: UPDATE Line #: 4
Input Buf: Language Event: SET NOCOUNT ON
WHILE (1=1)
BEGIN
EXEC BookmarkLookupUpdate 4
END
Requested By:
ResType:LockOwner Stype:'OR' Mode: S SPID:54 ECID:0 Ec:(0x2F881BD8)
Value:0x567e76c0 Cost:(0/0)
Victim Resource Owner:
ResType:LockOwner Stype:'OR' Mode: S SPID:54 ECID:0 Ec:(0x2F881BD8)
Value:0x567e76c0 Cost:(0/0)
                </code>
            </pre>
        </div>
        
        <p>Listing 7.6: Sample deadlock graph from Trace Flag 1204, involving KEY locks.</p>
        
        <p>The first thing to pay attention to in the graph output is that there are two nodes, each node representing a locked resource. The first line of output for each node shows the resource on which the lock is held, and then the Grant List section provides details of the deadlocking situation, including:</p>

        <ul>
            <li>Mode of the lock being held on the resource</li>
            <li>SPID of the associated process</li>
            <li>Statement Type the SPID is currently running</li>
            <li>Line # (line number) that marks the start of the currently executing statement</li>
            <li>Input Buf, the contents of the input buffer for that SPID (the last statement sent).</li>
        </ul>
        
        <p>So, for Node 1, we can see that a shared read (S) lock is being held by SPID 54 on an index KEY of a non-clustered index (:2) on an object with ID 1993058136. Node 2 shows that an exclusive (X) lock is being held by SPID 55 on an index key of the clustered index (:1) of the same object.</p>
        
        <p>Further down, for each node, is the Requested By section, which details any resource requests that cannot be granted, due to blocking. For Node 1, we can see that that SPID 55 is waiting for an exclusive lock on the non-clustered index key (it is blocked by the S lock held by SPID 54). For Node 2, we can see that SPID 54 is waiting to acquire a shared read lock on the clustered index key (it is blocked by the exclusive lock held by SPID 55).</p>
        
        <p>Furthermore, back in the Grant List section, we can see that SPID 54 has issued the SELECT statement on Line # 3 of the BookmarkLookupSelect stored procedure (but is unable to acquire a shared read lock) and SPID 55 has issued the UPDATE statement on Line # 4 of the BookmarkLookupUpdate stored procedure (but is unable to acquire an exclusive lock).</p>
        
        <p>This is a classic deadlock situation, and happens to be one of the more common types of deadlock, covered in more detail later in this chapter, in the section titled Bookmark lookup deadlock.</p>
        
        <p>Finally, in the Victim Resource Owner section we can find out which SPID was chosen as the deadlock victim, in this case, SPID 54. Alternatively, we can identify the deadlock victim by matching the binary information in the Value to the binary information in the Owner portion of the Grant List.</p>
        
        <p>We've discussed a lot about the deadlocking incident, but so far we know only that it occurred on an object with an ID of 1993058136. In order to identify properly the object(s) involved in the deadlock, the information in the KEY entry for each node needs to be used to query sysobjects and sysindexes. The KEY entry is formatted as databaseid:objected:indexid. So, in this example, SPID 54 was holding a Shared (S) lock on index id 2, a non-clustered index, with objectID 1993058136. The query in Listing 7.7 shows how to determine the table and index names associated with the deadlock.</p>
        
        <div>
            <pre>
                <code>
SELECT o.name AS TableName ,
i.name AS IndexName
FROM sysobjects AS o
JOIN sysindexes AS i ON o.id = i.id
WHERE o.id = 1993058136
AND i.indid IN ( 1, 2 )
                </code>
            </pre>
        </div>
        
        <p>Listing 7.7: Finding the names of the objects associated with the deadlock.</p>
        
        <p>If a deadlock involves a PAG lock instead of a KEY lock, the deadlock graph might look as shown in Listing 7.8.</p>
        
        <div>
            <pre>
                <code>
                    Wait-for graph
                    Node:1
                    PAG: 8:1:96 CleanCnt:2 Mode: X Flags: 0x2
                    Grant List 0::
                    Owner:0x195fb2e0 Mode: X Flg:0x0 Ref:1 Life:02000000
                    SPID: 56 ECID: 0 Statement Type: UPDATE Line #: 4
                    Input Buf: Language Event: SET NOCOUNT ON
                    WHILE (1=1)
                    BEGIN253
                    Chapter 7: Handling Deadlocks
                    EXEC BookmarkLookupUpdate 4
                    END
                    Requested By:
                    ResType:LockOwner Stype:'OR' Mode: S SPID:55 ECID:0 Ec:(0x1A5E1560)
                    Value:0x1960dba0 Cost:(0/0)
                </code>
            </pre>
        </div>
        
        <p>Listing 7.8: Page lock example, generated by Trace Flag 1204.</p>
        
        <p>Notice now that the lock reference is of the form databaseid:fileid:pageid. In order to identify the object to which this page belongs, we need to enable Trace Flag 3604, dump the page header information to the client message box DBCC PAGE(), and then disable the Trace Flag, as shown in Listing 7.9.</p>
        
        <div>
            <pre>
                <code>
                    DBCC TRACEON(3604)
                    DBCC PAGE(8,1,96,1)
                    DBCC TRACEOFF(3604)
                </code>
            </pre>
        </div>
        
        <p>Listing 7.9: Identifying the objects involved in a deadlock involving page locks.</p>
        
        The output of the DBCC PAGE() command will include a PAGE HEADER section, shown in Listing 7.10, which contains the IDs of the object (m_objId field) and index (m_indexId) to which the page belongs.
        
        <div>
            <pre>
                <code>
                    Page @0x1A5EC000
                    ----------------
                    m_pageId = (1:96) m_headerVersion = 1 m_type = 1
                    m_typeFlagBits = 0x0 m_level = 0 m_flagBits = 0x4
                    m_objId = 1977058079 m_indexId = 0 m_prevPage = (0:0)
                    m_nextPage = (1:98) pminlen = 116 m_slotCnt = 66
                    m_freeCnt = 110 m_freeData = 7950 m_reservedCnt = 0
                    m_lsn = (912:41:3) m_xactReserved = 0 m_xdesId = (0:0)
                    m_ghostRecCnt = 0 m_tornBits = 2
                </code>
            </pre>
        </div>
        
        <p>Listing 7.10: Page Header section from the output of the DBCC PAGE().</p>
        
        <p>Understanding the statements that are being executed along with the indexes and objects involved in the deadlock is critical to troubleshooting the problem. However, there are situations where the currently executing statement may not be the actual statement that caused the deadlock. Multi-statement stored procedures and batches that enlist an explicit transaction will hold all of the locks acquired under the transaction scope until the transaction is either committed or rolled back. In this situation, the deadlock may involve locks that were acquired by a previous statement that was executed inside the same transaction block. To completely troubleshoot the deadlock it is necessary to look at the executing batch from the Input Buf as a whole, and understand when locks are being acquired and released.</p>

        <p>Bart Duncan is the definitive source for interpreting SQL Server deadlock graphs. For additional information on reading the output of Trace Flag 1204, see his blog post Interpreting Trace Flag 1204 Output (http://blogs.msdn.com/b/bartd/archive/2006/09/09/deadlock-troubleshooting_2c00_-part-1.aspx).</p>

        <p>Interpreting Trace Flag 1222 deadlock graphs</p>

        <p>The format of the information, as well as the amount of information, returned by Trace Flag 1222 is very different than the output from Trace Flag 1204. Listing 7.11 shows the Trace Flag 1222 output, in SQL Server 2005, for an identical deadlock to the one previously seen for the Trace Flag 1204 output, from SQL Server 2000.</p>

        <div>
            <pre>
                <code>
                    deadlock-list
                    deadlock victim=process8d8c58
                    process-list
                    process id=process84b108 taskpriority=0 logused=220 waitresource=KEY:
                    34:72057594038452224 (0c006459e83f) waittime=5000 ownerId=899067977
                    transactionname=UPDATE lasttranstarted=2009-12-13T00:22:46.357 XDES=0x157be250
                    lockMode=X schedulerid=1 kpid=4340 status=suspended spid=102 sbid=0
                    ecid=0 priority=0 transcount=2 lastbatchstarted=2009-12-13T00:13:37.510
                    lastbatchcompleted=2009-12-13T00:13:37.507 clientapp=Microsoft SQL Server
                    Management Studio - Query hostname=SQL2K5TEST hostpid=5516 loginname=sa
                    isolationlevel=read committed (2) xactid=899067977 currentdb=34
                    lockTimeout=4294967295 clientoption1=673187936 clientoption2=390200
                    executionStack
                    frame procname=DeadlockDemo.dbo.BookmarkLookupUpdate line=4 stmtstart=260
                    stmtend=394 sqlhandle=0x03002200e7a4787d08a10300de9c00000100000000000000
                    UPDATE BookmarkLookupDeadlock SET col2 = col2-1 WHERE col1 = @col2
                    frame procname=adhoc line=4 stmtstart=82 stmtend=138 sqlhandle=0x020000002a709
                    3322fbd674049d04f1dc0f3257646c4514b
                    EXEC BookmarkLookupUpdate 4
                    inputbuf
                    SET NOCOUNT ON
                    WHILE (1=1)
                    BEGIN
                    EXEC BookmarkLookupUpdate 4
                    END
                    process id=process8d8c58 taskpriority=0 logused=0 waitresource=KEY:
                    34:72057594038386688 (0500b49e5abb) waittime=5000 ownerId=899067972
                    transactionname=INSERT EXEC lasttranstarted=2009-12-13T00:22:46.357
                    XDES=0x2aebba08 lockMode=S schedulerid=2 kpid=5864 status=suspended
                    spid=61 sbid=0 ecid=0 priority=0 transcount=1 lastbatchstarted=2009-12-
                    13T00:22:46.347 lastbatchcompleted=2009-12-13T00:22:46.343 clientapp=Microsoft
                    SQL Server Management Studio - Query hostname=SQL2K5TEST hostpid=5516
                    loginname=sa isolationlevel=read committed (2) xactid=899067972 currentdb=34
                    lockTimeout=4294967295 clientoption1=673187936 clientoption2=390200
                    executionStack
                    frame procname=DeadlockDemo.dbo.BookmarkLookupSelect line=3 stmtstart=118
                    stmtend=284 sqlhandle=0x03002200ae80847c07a10300de9c00000100000000000000
                    SELECT col2, col3 FROM BookmarkLookupDeadlock WHERE col2 BETWEEN @col2 AND @col2+1
                    frame procname=adhoc line=3 stmtstart=50 stmtend=146 sqlhandle=0x02000000e00b6
                    6366c680fabe2322acbad592a896dcab9cb
                    INSERT INTO #t1 EXEC BookmarkLookupSelect 4
                    inputbuf
                    WHILE (1=1)
                    BEGIN
                    INSERT INTO #t1 EXEC BookmarkLookupSelect 4
                    TRUNCATE TABLE #t1
                    END
                    resource-list
                    keylock hobtid=72057594038386688 dbid=34 objectname=DeadlockDemo.dbo.
                    BookmarkLookupDeadlock indexname=cidx_BookmarkLookupDeadlock id=lock137d65c0 mode=X
                    associatedObjectId=72057594038386688
                    owner-list
                    owner id=process84b108 mode=X
                    waiter-list
                    waiter id=process8d8c58 mode=S requestType=wait
                    keylock hobtid=72057594038452224 dbid=34 objectname=DeadlockDemo.dbo.
                    BookmarkLookupDeadlock indexname=idx_BookmarkLookupDeadlock_col2 id=lock320d5900
                    mode=S associatedObjectId=72057594038452224
                    owner-list
                    owner id=process8d8c58 mode=S
                    waiter-list
                    waiter id=process84b108 mode=X requestType=wait
                </code>
            </pre>
        </div>
        
        <p>Listing 7.11: Sample deadlock graph, generated by Trace Flag 1222.</p>
        
        <p>The new format breaks a deadlock down into sections that define the deadlock victim, the processes involved in the deadlock (process-list), and the resources involved in the deadlock (resource-list). Each process has an assigned process id that is used to uniquely identify it in the deadlock graph. The deadlock victim lists the process that was selected as the victim and killed by the deadlock monitor. Each process includes the SPID as well as the hostname and loginname that originated the request, and the isolation level under which the session was running when the deadlock occurred. The execution stack section, for each process, displays the entire execution stack, starting from the most recently executed (deadlocked) statement backwards to the start of the call stack. This eliminates the need to perform additional steps to identify the statement being executed.</p>

        <p>The resource-list contains all of the information about the resources involved in the deadlock and is generally the starting point for reading a deadlock graph. The index names are included in the output and each resource displays the owner process and the type of locks being held, as well as the waiting process and the type of locks being requested.</p>

        <p>As with the Trace Flag 1204 output, the definitive source for understanding the output from Trace Flag 1222 is Bart Duncan. He has a three-part series on troubleshooting deadlocks with the output from Trace Flag 1222 on his blog, starting with Deadlock Troubleshooting, Part 1 (http://blogs.msdn.com/bartd/archive/2006/09/09/747119.aspx).</p>

        <p>Using the same technique employed in these posts, we can construct a description of the deadlock described, as shown in Listing 7.12.</p>

        <div>
            <pre>
                <code>
                    SPID 102 (process84b108) is running this query (line 4 of the BookmarkLookupUpdate
                    sproc):
                    UPDATE BookmarkLookupDeadlock SET col2 = col2-1 WHERE col1 = @col2
                    SPID 61 (process8d8c58 )is running this query (line 3 of BookmarkLookupSelect
                    sproc):
                    SELECT col2, col3 FROM BookmarkLookupDeadlock WHERE col2
                    BETWEEN @col2 AND @col2+1
                    SPID 102 is waiting for an Exclusive KEY lock on the idx_BookmarkLookupDeadlock_
                    col2 index (on the BookmarkLookupDeadlock table).
                    (SPID 61 holds a conflicting S lock)
                    SPID 61 is waiting for a Shared KEY lock on the index cidx_BookmarkLookupDeadlock
                    (on the BookmarkLookupDeadlock table)..
                    (SPID 102 holds a conflicting X lock)
                </code>
            </pre>
        </div>

        <p>Listing 7.12: Deadlock analysis, constructed from the Trace Flag 1222 deadlock graph.</p>

        <p>As we can see from the deadlock list section of Listing 7.11, SPID 61, attempting to run the SELECT statement against cidx_BookmarkLookupDeadlock, is chosen as the deadlock victim.</p>

        <p>Interpreting XML deadlock graphs</p>

        <p>The information contained in XML deadlock graph, obtained from SQL Profiler, or Service Broker Event notifications, and so on, is essentially the same as that obtained from the output of Trace Flag 1222, and it is interpreted in exactly the same way. However, the format in which the information is presented is very different. The XML deadlock graph can be displayed graphically in Management Studio by saving the XML to a file with a .XDL extension and then opening the file in Management Studio (although, as discussed earlier, the XML generated by Extended Events can't be displayed graphically, in this manner).</p>

        <p>Figure 7.4 displays graphically the same deadlock graph that we saw for the two Trace Flags.</p>

        <p>Figure 7.4: SSMS graphical deadlock graph.</p>

        <p>In the graphical display, the deadlock processes are displayed as ovals. The process information is displayed inside of the oval, and includes a tooltip, which pops up when the mouse hovers over the process, and displays the statement being executed, as shown in Figure 7.5. The deadlock victim process is shown crossed out.</p>

        <p>Figure 7.5: SSMS graphical deadlock graph: the victim process.</p>
        
        <p>The resources contributing to the deadlock are displayed in rectangular boxes in the center of the graphical display. The locks, and their respective modes, are displayed by arrows between the processes and the resources. Locks owned by a process are shown with the arrow pointed towards the process, while locks being requested are shown with the arrow pointed towards the resource as shown in Figure 7.6.</p>

        <p>Figure 7.6: SSMS graphical deadlock graph: processes and resources.</p>

        <p>A visual display like this makes it much easier to understand the circular blocking that caused the deadlock to occur.</p>

        <p>Common types of deadlock and how to eliminate them</p>

        <p>When troubleshooting any type of problem in SQL Server, you learn with experience how to recognize, from a distance, the particular varieties of problem that tend to crop up on a regular basis. The same is true of deadlocks; the same types of deadlock tend to appear with predictable regularity and, once you understand what patterns to look for, resolving the deadlock becomes much more straightforward.</p>

        <p>This section assumes knowledge of basic locking mechanisms inside SQL Server (see Chapter 6) and examines how to resolve the most common types of deadlock, namely the bookmark lookup deadlock, the serializable range scan deadlock, the cascading constraint deadlock, the intra-query parallelism deadlock and the accessing objects in different orders deadlock.</p>

        <p>Bookmark lookup deadlock</p>

        <p>Bookmark lookup deadlocks are one of the most common deadlocks in SQL Server. Fortunately, although they have a habit of appearing randomly, without any changes to the database or the code inside of it, they are also one of the easiest types of deadlock to troubleshoot.</p>

        <p>Bookmark lookup deadlocks generally have a SELECT statement as the victim, and an INSERT, UPDATE, or DELETE statement as the other contributing process to the deadlock. They occur partly as a general consequence of SQL Server's pessimistic locking mechanisms for concurrency, but mainly due to the lack of an appropriate covering index for the SELECT operation.</p>

        <p>When a column is used in the WHERE clause to filter the SELECT statement and a non-clustered index exists on that column, then the database engine takes a shared lock on the required rows or pages in the non-clustered index. In order to return any additional columns from the table, not covered by the non-clustered index, the database engine performs an operation known as KEY, or RID, lookup (in SQL Server 2000, the term "bookmark lookup" was used). This operation uses either the Clustered Index Key or RID (in the case of a heap) to look up the row in the table data and retrieve the additional columns.</p>

        <p>When a lookup operation occurs, the database engine takes additional shared locks on the rows or pages needed from the table. These locks are held for the duration of the SELECT operation, or until lock escalation is triggered to increase the lock granularity from row or page to table.</p>

        <p>The deadlock occurs, as we have seen in previous sections, when an operation that changes the data in a table (for example, an INSERT, UPDATE, or DELETE operation) occurs simultaneously with the SELECT. When the data-changing session executes, it acquires an exclusive lock on the row or page of the clustered index or table, and performs the data change operation. At the same time the SELECT operation acquires a shared lock on the non-clustered index. The data-changing operation requires an exclusive lock on the non-clustered index to complete the modification, and the SELECT operation requires a shared lock on the clustered index, or table, to perform the bookmark lookup. Shared locks and exclusive locks are incompatible, so if the data-changing operation and the SELECT operation affect the same rows then the data-changing operation will be blocked by the SELECT, and the SELECT will be blocked by the data change, resulting in a deadlock.</p>

        <p>One of the most common online recommendations for curing this type of deadlock is to use a NOLOCK table hint in the SELECT statement, to prevent it from acquiring shared locks. This is bad advice. While it might prevent the deadlock, it can have unwanted side effects, such as allowing operations to read uncommitted changes to the database data, and so return inaccurate results.</p>

        <p>The correct fix for this type of deadlock is to change the definition of the non-clustered index so that it contains, either as additional key columns or as INCLUDE columns (see Chapter 5), all the columns it needs to cover the query. Columns returned by the query that are not used in a JOIN, WHERE, or GROUP BY clause, can be added to the index as INCLUDE columns. Any column used in a JOIN, the WHERE clause, or in a GROUP BY should ideally be a part of the index key but, in circumstances where this exceeds the 900-byte limit, addition as an INCLUDE column may work as well. Implementing the covering index will resolve the deadlock without the unexpected side effects of using NOLOCK.</p>
        
        <p>A shortcut to finding the appropriate covering index for a query is to run it through the Database Engine Tuning Advisor (DTA). However, as discussed in Chapter 5, the DTA recommendations are only as good as the supplied workload, and repeated single-query evaluations against the same database can result in an excessive number of indexes, which often overlap. Manual review of any index recommendation made by the DTA should be made to determine if modification of an existing index can cover the query without creating a new index. A good video example, Using the DTA to Assist in Performance Tuning, can be found on the SQL Share website (http://www.sqlshare.com/using-thedta-to-assist-in-performance-tuning_599.aspx).</p>

        <p>Range scans caused by SERIALIZABLE isolation</p>

        <p>The SERIALIZABLE isolation level is the most restrictive isolation level in SQL Server for concurrency control, ensuring that every transaction is completely isolated from the effects of any other transaction.</p>

        <p>To accomplish this level of transactional isolation, range locks are used when reading data, in place of the row or page level locking used under READ COMMITTED isolation. These range locks ensure that no data changes can occur that affect the result set, allowing the operation to be repeated inside the same transaction with the same result. While the default isolation level for SQL Server is READ COMMITTED, certain providers, like COM+ and BizTalk, change the isolation to SERIALIZABLE when connections are made.</p>

        <p>Range locks have two components associated with their names, the lock type used to lock the range and then the lock type used for locking the individual rows within the range. The four most common range locks are shared-shared (RangeS-S), shared-update (RangeS-U), insert-null (RangeI-N), and exclusive (RangeX-X). Deadlocks associated with SERIALIZABLE isolation are generally caused by lock conversion, where a lock of higher compatibility, such as a RangeS-S or RangeS-U lock, needs to be converted to a lock of lower compatibility, such as a RangeI-N or RangeX-X lock.</p>

        <p>A common deadlock that occurs under SERIALIZABLE isolation has a pattern that involves a transaction that checks if a row exists in a table before inserting or updating the data in the table. A reproducible example of this deadlock is included in the code examples for this chapter. This type of deadlock will generally produce a deadlock graph with a resource-list similar to the one shown in Listing 7.13.</p>

        <div>
            <pre>
                <code>
                    <resource-list>
                    <keylock hobtid="72057594050969600" dbid="5" objectname="AdventureWorks.
                    Sales.SalesOrderHeader" indexname="IX_SalesOrderHeader_CustomerID" id="lock35bcc80"
                    mode="RangeS-U" associatedObjectId="72057594050969600">
                    <owner-list>
                    <owner id="processad4d2e8" mode="RangeS-U" />
                    <owner id="process9595b8" mode="RangeS-S" />
                    </owner-list>
                    <waiter-list>
                    <waiter id="processad4d2e8" mode="RangeI-N" requestType="convert" />
                    <waiter id="process9595b8" mode="RangeI-N" requestType="convert" />
                    </waiter-list>
                    </keylock>
                    </resource-list>
                </code>
            </pre>
        </div>

        <p>Listing 7.13: Extract from a deadlock graph for a SERIALIZABLE range scan deadlock.</p>

        <p>In this example, two processes have acquired compatible shared locks, RangeS-S and RangeS-U, on the SalesOrderHeader table. When one of the processes requires a lock conversion to a lock type that is incompatible with the lock being held by the other process, in this case a RangeI-N, it is blocked. If both processes require a lock conversion to RangeI-N locks, the result is a deadlock since each session is waiting on the other to release its high compatibility lock.</p>

        <p>There are several possible solutions to this type of deadlock and the most appropriate one depends on the database and the application it supports. If it is not necessary for the database to maintain the range locks acquired during the SELECT operation that checks for row existence and the SELECT operation can be moved outside of the transaction that performs the data change, then the deadlock can be prevented.</p>
        
        <p>If the operation doesn't require the use of SERIALIZABLE isolation, then changing the isolation level to a less restrictive isolation level, for example READ COMMITTED, will prevent the deadlock and allow a greater degree of concurrency.</p>

        If neither of these solutions is appropriate, the deadlock can be resolved by forcing the SELECT statement to use a lower-compatibility lock, through the use of an UPDLOCK or XLOCK table hint. This will block any other transactions attempting to acquire locks of higher compatibility. This fix is specific to this particular type of deadlock due to the usage of SERIALIZABLE isolation. Using UPDLOCK hints under READ COMMITTED may result in deadlocks occurring more frequently under certain circumstances.

        <p>Cascading constraint deadlocks</p>

        <p>Cascading constraint deadlocks are generally very similar to a Serializable Range Scan deadlock, even though the isolation level under which the victim transaction was running isn't SERIALIZABLE. To enforce cascading constraints, SQL Server has to traverse the FOREIGN KEY hierarchy to ensure that orphaned child records are not left behind, as the result of an UPDATE or DELETE operation to a parent table. To do this requires that the transaction that modifies the parent table be isolated from the effects of other transactions, in order to prevent a change that would violate FOREIGN KEY constraints, when the cascade operation subsequently completes.</p>

        <p>Under the default READ COMMITTED isolation, the database engine would acquire and hold, for the duration of the transaction, Exclusive locks on all rows that had to be changed. This blocks users from reading or changing the affected rows, but it doesn't prevent another session from adding a new row into a child table for the parent key being deleted. To prevent this from occurring, the database engine acquires and holds range locks, which block the addition of new rows into the range affected by the cascading operation. This is essentially an under-the-cover use of SERIALIZABLE isolation, during the enforcement of the cascading constraint, but the isolation level for the batch is not actually changed; only the type of locks used for the cascading operation are changed.</p>
        
        <p>When a deadlock occurs during a cascading operation, the first thing to look for is whether or not non-clustered indexes exist for the FOREIGN KEY columns that are used (see Chapter 5 for more on Indexing Foreign Keys). If appropriate indexes on the FOREIGN KEY columns do not exist, the locks being taken to enforce the constraints will be held for longer periods of time, increasing the likelihood of a deadlock between two operations, if a lock conversion occurs.</p>

        <p>Intra-query parallelism deadlocks</p>

        <p>An intra-query parallelism deadlock occurs when a single session executes a query that runs with parallelism, and deadlocks itself. Unlike other deadlocks in SQL Server, these deadlocks may actually be caused by a bug in the SQL Server parallelism synchronization code, rather than any problem with the database or application design. Since there are risks associated with fixing some bugs, it may be that the bug is known and won't be fixed, since it is possible to work around it by reducing the degree of parallelism for that the query, using the MAXDOP query hint, or by adding or changing indexes to reduce the cost of the query or make it more efficient.</p>

        <p>The deadlock graph for a parallelism deadlock will have the same SPID for all of the processes, and will have more than two processes in the process-list. The resourcelist will have threadpool, exchangeEvent, or both, listed as resources, but it won't have lock resources associated with it. In addition, the deadlock graph for this type of deadlock will be significantly longer than any other type of deadlock, depending on the degree of parallelism and the number of nodes that existed in the execution plan.</p>

        <p>Additional information about this specific type of deadlock can be found on Bart Duncan's blog post, Today's Annoyingly-Unwieldy Term: "Intra-Query Parallel Thread Deadlocks" (http://blogs.msdn.com/bartd/archive/2008/09/24/today-s-annoyinglyunwieldy-term-intra-query-parallel-thread-deadlocks.aspx).</p>
        
        <p>Accessing objects in different orders</p>

        <p>One of the easiest deadlocks to create, and consequently one of the easiest to prevent, is caused by accessing objects in a database in different operation orders inside of T-SQL code, inside of transactions, as shown in Listings 7.14 and 7.15.</p>

        <div>
            <pre>
                <code>
                    BEGIN TRANSACTION
                    UPDATE TableA
                    SET Column1 = 1
                    SELECT Column2
                    FROM TableB
                </code>
            </pre>
        </div>

        <p>Listing 7.14: Transaction1 updates TableA then reads TableB.</p>

        <div>
            <pre>
                <code>
                    BEGIN TRANSACTION
                    UPDATE TableB
                    SET Column2 = 1
                    SELECT Column1
                    FROM TableA
                </code>
            </pre>
        </div>
        
        <p>Listing 7.15: Transaction2 updates TableB then reads TableA.</p>
        
        <p>Transaction1's UPDATE against TableA will result in an exclusive lock being held on the table until the transaction completes. At the same time, Transaction2 runs an UPDATE against TableB, which also results in an exclusive lock being held until the transaction completes. After completing the UPDATE to TableA, Transaction1 tries to read TableB but is blocked and unable to acquire the necessary shared lock, due to the exclusive lock being held by Transaction2. After completing its UPDATE to TableB, Transaction2 reads TableA and is also blocked, unable to acquire a shared lock due to the exclusive lock held by Transaction1. Since the two transactions are both blocking each other, the result is a deadlock and the Lock Monitor will kill one of the two sessions, rolling back its transaction to allow the other to complete.</p>

        <p>When using explicit transactions in code, it is important that objects are always accessed in the same order, to prevent this type of deadlock from occurring.</p>

        <p>Handling Deadlocks to Prevent Errors</p>

        <p>In most cases, the same issues that cause severe blocking in the database, such as poor database design, lack of indexing, poorly designed queries, inappropriate isolation level and so on (all discussed in Chapter 6), are also the common causes of deadlocking. In most cases, by fixing such issues, we can prevent deadlocks from occurring. Unfortunately, the time deadlocks become a problem, it may not be possible to make the necessary design changes to correct them.</p>

        <p>Therefore, an important part of application and database design is defensive programming; a technique that anticipates and handles exceptions as a part of the general code base for an application or database. Defensive programming to handle deadlock exceptions can be implemented in two different ways:</p>

        <ul>
            <li>database-side, through the use of T-SQL TRY…CATCH blocks</li>
            <li>application-side, through the use of application TRY…CATCH blocks.</li>
        </ul>

        <p>In either case, proper handling of the 1205 exception raised by SQL Server for the deadlock victim can help avoid UnhandledException errors in the application and the ensuing end-user phone calls to Help Desk or Support.</p>
        
        <p>T-SQL TRY…CATCH blocks</p>

        <p>Depending on how an application is designed, and whether there is separation between application code and database code, the simplest implementation of deadlock error handling could be via the use of BEGIN TRY/CATCH blocks inside of the T-SQL being executed.</p>

        <p>This technique is most applicable in cases where an application calls stored procedures for all of its data access. In such cases, changing the code in a stored procedure so that it handles the deadlock exception doesn't require changes to application code, or recompiling and redistribution of the application. This greatly simplifies the implementation of such changes.</p>

        <p>The best way to deal with a deadlock, within your error handling code, will depend on your application and its expected behavior in the event of a deadlock. One way of handling the deadlock would be to retry the transaction a set number of times before actually raising an exception back to the application for handling. The cross-locking situation associated with a deadlock generally only lasts a very short duration, usually timed in milliseconds so, more often than not, a subsequent attempt at executing the T-SQL code selected as a victim will succeed, and there will be no need to raise any exceptions to the application.</p>

        <p>However, it is possible that the deadlock will continue to occur, and we need to avoid getting into an infinite loop, attempting repeatedly to execute the same failing code. To prevent this, a variable is used to count down from a maximum number of retry attempts; when zero is reached, an exception will be raised back to the application. This technique is demonstrated in Listing 7.16.</p>

        <div>
            <pre>
                <code>
                    DECLARE @retries INT ;
                    SET @retries = 4 ;
                    WHILE ( @retries > 0 )
                    BEGIN269
                    Chapter 7: Handling Deadlocks
                    BEGIN TRY
                    BEGIN TRANSACTION ;
                    -- place sql code here
                    SET @retries = 0 ;
                    COMMIT TRANSACTION ;
                    END TRY
                    BEGIN CATCH
                    -- Error is a deadlock
                    IF ( ERROR_NUMBER() = 1205 )
                    SET @retries = @retries - 1 ;
                    -- Error is not a deadlock
                    ELSE
                    BEGIN
                    DECLARE @ErrorMessage NVARCHAR(4000) ;
                    DECLARE @ErrorSeverity INT ;
                    DECLARE @ErrorState INT ;
                    SELECT @ErrorMessage = ERROR_MESSAGE() ,
                    @ErrorSeverity = ERROR_SEVERITY() ,
                    @ErrorState = ERROR_STATE() ;
                    -- Re-Raise the Error that caused the problem
                    RAISERROR (@ErrorMessage, -- Message text.
                    @ErrorSeverity, -- Severity.
                    @ErrorState -- State.
                    ) ;
                    SET @retries = 0 ;
                    END
                    IF XACT_STATE() <> 0
                    ROLLBACK TRANSACTION ;
                    END CATCH ;
                    END ;
                    GO
                </code>
            </pre>
        </div>
        
        <p>Listing 7.16: TRY…CATCH handling of deadlock exceptions, in T-SQL.</p>
        
        <p>Handling ADO.NET SqlExceptions in .NET code</p>

        <p>While it is possible to handle deadlocks in SQL Server 2005 and 2008, using BEGIN TRY and BEGIN CATCH blocks, the same functionality doesn't exist in SQL Server 2000, and in any event it may not be acceptable to have the database engine retry the operation automatically. In either case, the client application should be coded to handle the deadlock exception that is raised by SQL Server.</p>

        <p>There isn't much difference between the error handling in .NET and the error handling in T-SQL. A TRY…CATCH block is used to execute the SQL call from the application and catch any resulting exception raised by SQL Server. If the code should reattempt the operation in the event of a deadlock, a maximum number of retries should be set by a member variable that is decremented each time a deadlock is encountered.</p>

        <p>The example in Listing 7.17 shows how to catch the SqlException in C#, but can be used as a model to handle deadlocks in other languages as well.</p>

        <div>
            <pre>
                <code>
                    int retries = 4;
                    while (retries > 0)
                    {
                        try
                        {
                            // place sql code here
                            retries = 0;
                        }
                        catch (SqlException exception)
                        {
                            // exception is a deadlock
                            if (exception.Number == 1205)
                            {
                                // Delay processing to allow retry.
                                Thread.Sleep(500);
                                retries --;
                            }
                            // exception is not a deadlock
                            else
                            {
                                throw;
                            }
                        }
                    }
                </code>
            </pre>
        </div>
        
        <p>Listing 7.17: TRY…CATCH handling of deadlock exceptions, in C#.</p>

        <p>Rather than retrying the operation, it may be desirable to log the exception in the Windows Application Event Log, or perhaps display a MessageBox dialog and determine whether or not to retry the operation, based on user input. These are two examples of how handling the deadlock exception in the application code allows for more flexibility over handling the deadlock in the database engine.</p>

        <p>Controlling Deadlock Behavior with Deadlock Priority</p>

        <p>There are circumstances (for example, a critical report that performs a long running SELECT that must complete even if it is the ideal deadlock victim) where it may be preferable to specify which process will be chosen as the deadlock victim in the event of a deadlock, rather than let SQL Server decide based purely on the cost of rollback. As demonstrated in Listing 7.18, SQL Server offers the ability to set, at the session or batch level, a deadlock priority using the SET DEADLOCK PRIORITY option.</p>

        <div>
            <pre>
                <code>
                    -- Set a Low deadlock priority
                    SET DEADLOCK_PRIORITY LOW ;
                    GO
                    -- Set a High deadlock priority
                    SET DEADLOCK_PRIORITY HIGH ;
                    GO
                    -- Set a numeric deadlock priority
                    SET DEADLOCK_PRIORITY 2 ;
                </code>
            </pre>
        </div>
        
        <p>Listing 7.18: Setting deadlock priority.</p>
        
        <p>A process running in a batch or session with a low deadlock priority will be chosen as the deadlock victim over one that is running with a higher deadlock priority. Like all other SET options in SQL Server, the DEADLOCK PRIORITY is only in effect for the current execution scope. If it is set inside of a stored procedure, then when the stored procedure execution completes, the priority returns to the original priority of the calling execution scope.</p>

        <p>Note that SQL Server 2000 offers only two deadlock priorities; Low and Normal. This allows the victim to be determined by setting its priority to Low. SQL Server 2005 and 2008 however, have three named deadlock priorities; Low, Normal, and High, as well as a numeric range from -10 to +10, for fine-tuning the deadlock priority of different operations.</p>

        <p>The deadlock priority is set at execution time, and all users have the permission to set a deadlock priority. This can be a problem if users have ad hoc query access to SQL Server, and set their deadlock priority higher than other processes, in order to prevent their own process from being selected as a victim.</p>

        <p>Summary</p>

        <p>This chapter has covered how to capture and interpret deadlock graph information in SQL Server to troubleshoot deadlocking. The most common deadlocks have also been covered to provide a foundation for troubleshooting other types of deadlocks that might occur. Most often, deadlocks are the result of a design problem in the database or code that can be fixed to prevent the deadlock from occurring. However, when changes to the database are not possible to resolve the deadlock, adding appropriate error handling in the application code reduces the impact caused by a deadlock occurring. The information included in this chapter should allow rapid and efficient troubleshooting of most deadlocks in SQL Server.</p>
    </main>

    <div id="topo">
        <a href="#" target="_self"><i class="material-symbols-outlined">stat_2</i></a>
    </div>

    <footer>
        <p>Criado por Agnaldo Mota</p>
    </footer>

    <script src="scripts/script.js"></script>
</body>
</html>
