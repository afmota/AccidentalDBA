<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBA Acidental</title>
    <link rel="stylesheet" href="estilo/style.css">
    <link rel="stylesheet" href="estilo/media-queries.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
</head>

<body onresize="mudouTamanho()">
    <header>
        <h1>Troubleshooting SQL Server</h1>
        <h2>Um Guia para o DBA Acidental</h2>
    </header>

    <nav>
        <i id="burger" class="material-icons" onclick="clickMenu()">menu</i>
        <menu id="itens">
            <ul>
                <li><a href="index.html" target="_self"><i id="home" class="material-icons">home</i></a></li>
                <li><a href="abertura.html" target="_self">Abertura</a></li>
                <li><a href="introducao.html" target="_self">Introdução</a></li>
                <li><a href="cap01.html" target="_self">Cap.1</a></li>
                <li><a href="cap02.html" target="_self">Cap.2</a></li>
                <li><a href="cap03.html" target="_self">Cap.3</a></li>
                <li><a href="cap04.html" target="_self">Cap.4</a></li>
                <li><a href="cap05.html" target="_self">Cap.5</a></li>
                <li><a href="cap06.html" target="_self">Cap.6</a></li>
            </ul>
        </menu>
    </nav>

    <main>
        <h1>Capítulo 7: Lidando com Deadlocks</h1>

        <p>Um deadlock é definido no dicionário como "uma paralisação resultante da ação de forças iguais e opostas", e isso acaba sendo uma descrição razoável de um deadlock no SQL Server: duas ou mais sessões dentro do mecanismo do banco de dados acabam aguardando acesso a recursos bloqueados mantidos um pelo outro. Em uma situação de deadlock, nenhuma das sessões pode continuar a executar até que uma dessas sessões libere seus bloqueios, permitindo assim que a(s) outra(s) sessão(ões) acesse(m) o recurso bloqueado. Múltiplos processos bloqueando persistentemente uns aos outros, em um estado insolúvel, eventualmente resultarão em uma interrupção no processamento dentro do mecanismo do banco de dados.</p>

        <p>Um equívoco comum é que os DBAs precisam intervir para "matar" um dos processos envolvidos em um deadlock. Na verdade, o SQL Server é projetado para detectar e resolver deadlocks automaticamente, por meio do uso do <strong>Lock Monitor</strong>, um processo em segundo plano que é iniciado quando a instância do SQL Server é iniciada e que monitora constantemente o sistema em busca de sessões em deadlock. No entanto, quando os deadlocks são relatados, o DBA deve investigar sua causa imediatamente. Muitos dos mesmos problemas que causam bloqueios graves no banco de dados, como design de banco de dados inadequado, falta de indexação, consultas mal projetadas, nível de isolamento inadequado e assim por diante (todos discutidos no <a href="cap06.html" target="_self">Capítulo 6</a>), também são causas comuns de deadlocks. Este capítulo fornecerá as ferramentas, técnicas e ajustes necessários para diagnosticar e prevenir deadlocks, e garantir que eles sejam tratados com elegância, caso ocorram. Especificamente, ele abordará:</p>

        <ul>
            <li>como capturar gráficos de deadlock usando uma variedade de técnicas, incluindo Flags de Rastreamento, o evento de gráfico de deadlock do Profiler e notificações de eventos do service broker</li>
            <li>como ler gráficos de deadlock para localizar as sessões, consultas e recursos envolvidos</li>
            <li>tipos comuns de deadlock e como evitá-los</li>
            <li>usando tratamento de erro <code>TRY...CATCH</code> no servidor ou no cliente para deadlocks, para evitar erros <code>UnhandledException</code> na aplicação.</li>
        </ul>

        <h2 id="lockmonitor">Lock Monitor</h2>

        <p>Quando o Monitor de Bloqueio realiza uma busca por deadlock e detecta que uma ou mais sessões estão envolvidas em um deadlock, uma das sessões é selecionada como vítima do deadlock e sua transação atual é revertida. Quando isso ocorre, todos os bloqueios mantidos pela sessão da vítima são liberados, permitindo que qualquer outra sessão previamente bloqueada continue processando. Uma vez que a reversão é concluída, a sessão da vítima é terminada, retornando uma mensagem de erro 1205 para o cliente de origem.</p>

        <p>O SQL Server seleciona a vítima do deadlock com base nos seguintes critérios:</p>

        <ol>
            <li><strong>Prioridade de deadlock</strong> – a DEADLOCK_PRIORITY atribuída a uma determinada sessão determina a importância relativa de completar suas transações, caso essa sessão esteja envolvida em um deadlock. A sessão com a menor prioridade será sempre escolhida como a vítima do deadlock. A prioridade de deadlock é abordada em mais detalhes mais adiante neste capítulo.</li>
            <li><strong>Custo de reversão </strong>– se duas ou mais sessões envolvidas em um deadlock tiverem a mesma prioridade de deadlock, o SQL Server escolherá como vítima do deadlock a sessão que tiver o menor custo estimado de reversão.</li>
        </ol>

        <h2 id="capgraf">Capturando Gráficos de Deadlock</h2>

        <p>Quando erros 1205 são relatados, é importante que o DBA descubra por que o deadlock aconteceu e tome medidas para evitar sua recorrência. O primeiro passo para solucionar e resolver um problema de deadlock é capturar as informações do <strong>gráfico de deadlock</strong>.</p>

        <p>Um gráfico de deadlock é uma saída de informações sobre as sessões e recursos que estiveram envolvidos em um deadlock. Os meios pelos quais você pode capturar um gráfico de deadlock se diversificaram e melhoraram nas versões mais recentes do SQL Server. Se você ainda está usando o SQL Server 2000, então está limitado a um único, e um tanto limitado, Trace Flag (1204). O SQL Server 2005 adicionou um novo Trace Flag (1222), forneceu o evento <strong>Gráfico de Deadlock em XML</strong> no SQL Server Profiler e permitiu a captura de gráficos de deadlock via notificações de eventos do Service Broker e do Provedor WMI (Instrumentação de Gerenciamento do Windows) para Eventos do Servidor. Em cada caso, o gráfico de deadlock contém significativamente mais informações sobre a natureza do deadlock do que está disponível através do Trace Flag 1204. Isso minimiza a necessidade de reunir, manualmente, informações adicionais do SQL Server para entender por que o deadlock ocorreu; por exemplo, resolver o <code>pageid</code> dos bloqueios sendo mantidos para o <code>objectid</code> e <code>indexid</code>, usando <code>DBCC PAGE</code>, e usar SQL Trace para percorrer a cadeia de deadlock e descobrir quais declarações em execução estão causando o problema. O SQL Server 2008 fornece todas essas facilidades, além da sessão de Eventos Estendidos <code><strong>system_health</strong></code>.</p>

        <p>Para permitir que você trabalhe em cada seção e gere os mesmos gráficos de deadlock que são apresentados e descritos no texto, os materiais de recursos deste livro (<a href="http://www.simple-talk.com/RedGateBooks/JonathanKehayias/TroubleshootingSQLServer_Code.zip" target="_blank">http://www.simple-talk.com/RedGateBooks/JonathanKehayias/TroubleshootingSQLServer_Code.zip</a>) incluem código de exemplo para gerar um deadlock no SQL Server.</p>

        <h3 id="traceflag1204">Trace Flag 1204</h3>

        <p>Os Trace Flags no SQL Server permitem "caminhos de código" alternativos em pontos chave dentro do motor de banco de dados, permitindo que código adicional seja executado quando necessário. Se você estiver enfrentando falhas em consultas com erros de deadlock em uma instância do SQL Server, os Trace Flags podem ser ativados para uma única sessão ou para todas as sessões naquela instância. Quando o Trace Flag 1204 está habilitado para todas as sessões em uma instância do SQL Server, qualquer deadlock detectado pelo monitor de deadlock resultará na escrita de um gráfico de deadlock no log de erros do SQL Server.</p>

        <p>No SQL Server 2000, este Trace Flag é o único meio de capturar um gráfico de deadlock, o que torna a solução de problemas de deadlocking no SQL Server 2000 bastante desafiadora, embora ainda possível. Nas versões mais recentes do SQL Server, este Trace Flag ainda está disponível, embora tenha sido substituído pelo Trace Flag 1222.</p>

        <p>O Trace Flag 1204, assim como todos os Trace Flags, pode ser ativado e desativado de forma ad hoc usando os comandos <code>DBCC TRACEON</code> e <code>DBCC TRACEOFF</code> no console do banco de dados. A Listagem 7.1 mostra como habilitar o Trace Flag 1204 a curto prazo no nível do servidor (especificado pelo argumento -1), de modo que todas as declarações subsequentes sejam executadas com este Trace Flag habilitado.</p>
        <div id="container">
            <pre><code>
DBCC TRACEON(1204, -1)
            </code></pre>
        </div>

        <p class="legenda"><strong>Listagem 7.1:</strong> Habilitando o Trace Flag 1204 para todas as sessões.</p>
        
        <p>Alternativamente, os Trace Flags podem ser ativados automaticamente, utilizando o parâmetro de inicialização –T. Para adicionar um parâmetro de inicialização ao SQL Server, clique com o botão direito do mouse no nó do servidor no <strong>Enterprise Manager</strong> e abra a página de <strong>Propriedades do Servidor</strong>. Na aba <strong>Geral</strong>, clique no botão <strong>Parâmetros de Inicialização</strong> e, em seguida, adicione o parâmetro de inicialização ao servidor, conforme mostrado na Figura 7.1.</p>

        <img src="imagens/fig71.PNG" alt="Utilizando o parâmetro de inicialização –T." width="50%">

        <p class="legenda"><strong>Figura 7.1</strong>: Utilizando o parâmetro de inicialização –T.</p>

        <p>Nos casos em que é possível reiniciar uma instância, utilizar um parâmetro de inicialização pode ser útil quando se deseja capturar todos os deadlocks que ocorrem no servidor, ao longo de um longo período. No entanto, uma vez que a resolução de problemas de deadlock tenha sido concluída, o Trace Flag deve ser removido dos parâmetros de inicialização. Como o Trace Flag permite que a instância grave o gráfico de deadlock no log de erros do SQL Server, a única maneira de recuperar o gráfico é ler o arquivo de log de erros e, em seguida, extrair os eventos do arquivo de log para análise.</p>

        <h3 id="traceflag1222">Trace Flag 1222</h3>

        <p>O SQL Server 2005 adicionou o Trace Flag 1222 para capturar os gráficos de deadlock em um formato mais fácil de ler e mais abrangente do que o disponível com o flag 1204. Ele captura e apresenta as informações de uma maneira que torna muito mais fácil identificar a vítima do deadlock, assim como os recursos e processos envolvidos no deadlock (abordados em detalhes na seção <em>Leitura de Gráficos de Deadlock</em>).</p>

        <p>O Trace Flag 1204 ainda está disponível, por motivos de compatibilidade retroativa, mas ao usar Trace Flags para capturar gráficos de deadlock no SQL Server 2005 ou posterior, você deve sempre usar o Trace Flag 1222 em preferência ao Trace Flag 1204. O Trace Flag 1222 é habilitado da mesma maneira que o 1204, utilizando <code>DBCC TRACEON()</code>, como mostrado no Listagem 7.1 ou o parâmetro de inicialização –T, como mostrado na Figura 7.1.</p>

        <h3 id="deadlockxml">Evento de Gráfico de Deadlock XML no SQL Profiler</h3>

        <p>Novo no SQL Server 2005, o evento <code>Deadlock Graph</code> no SQL Trace captura as informações do gráfico de deadlock, sem escrevê-las no Log de Erros do SQL Server. O evento <code>Deadlock Graph</code> faz parte da categoria de eventos <strong>Locks</strong> e pode ser adicionado a um rastreamento do SQL Server Profiler selecionando o evento na caixa de diálogo <strong>Propriedades de Rastreamento</strong> do Profiler, como mostrado na Figura 7.2.</p>
        
        <img src="imagens/fig72.PNG" alt="Selecionando o evento Deadlock Graph na caixa de diálogo Propriedades de Rastreamento.">

        <p class="legenda"><strong>Figura 7.2</strong>: Selecionando o evento <code>Deadlock Graph</code> na caixa de diálogo Propriedades de Rastreamento.</p>

        <p>SQL Profiler can be configured to save the deadlock graphs separately, into XDL files, as shown in Figure 7.3.</p>

        <img src="imagens/fig73.PNG" alt="Salvando gráficos de deadlock">

        <p class="legenda"><strong>Figura 7.3</strong>: Salvando gráficos de deadlock.</p>

        <p>Um arquivo XDL é um arquivo XML padrão. O Management Studio reconhece a extensão do arquivo ao abri-lo e exibe as informações de deadlock graficamente, em vez de como XML.</p>

        <p>Se você preferir trabalhar diretamente com traces no servidor, eliminando a sobrecarga do cliente Profiler, pode capturar as informações do gráfico de deadlock diretamente dos seus scripts, utilizando o conjunto de procedimentos armazenados do sistema <code><strong>SP_TRACE_*</strong></code>. Os gráficos capturados serão gravados em um arquivo de rastreamento SQL no SQL Server. A maneira mais fácil de gerar um script para um trace no servidor é primeiro criar o trace no SQL Profiler e, em seguida, exportá-lo para um script usando <strong>Arquivo</strong> | <strong>Exportar</strong> | <strong>Exportar Definição de Trace</strong>, conforme descrito em detalhes no <a href="cap05.html#worload" target="_self">Capítulo 5</a>.</p>

        <p>Um arquivo de trace no servidor pode ser lido usando a função de sistema <code>fn_trace_gettable</code> ou abrindo-o no SQL Profiler. Ao usar o SQL Profiler para visualizar o conteúdo do arquivo de trace, os eventos de deadlock podem ser exportados para arquivos XDL individuais, que podem ser abertos graficamente usando o SQL Server Management Studio, através do menu <strong>Arquivo</strong> | <strong>Exportar</strong> | <strong>Extrair Eventos do SQL Server</strong> | <strong>Extrair Eventos de Deadlock</strong>.</p>

        <h3 id="servicebroker">Notificações de eventos do Service Broker</h3>

        <p>Também novo no SQL Server 2005, as notificações de eventos permitem capturar informações de gráficos de deadlock usando o SQL Server Service Broker, criando um <strong>serviço</strong> e uma <strong>fila</strong> para o evento de rastreamento <code>DEADLOCK_GRAPH</code>. As informações contidas no gráfico de deadlock capturado por notificações de eventos não diferem das informações contidas no gráfico de deadlock capturado pelo SQL Trace; a única diferença é o mecanismo de captura.</p>

        <p>Configurar uma notificação de evento para capturar informações de gráficos de deadlock requer três objetos do Service Broker:</p>

        <ul>
            <li>Uma <code><strong>FILA</strong></code> para armazenar as mensagens do evento <code>DEADLOCK_GRAPH</code></li>
            <li>Um <code><strong>SERVIÇO</strong></code> para encaminhar as mensagens para a fila</li>
            <li>Uma <code><strong>NOTIFICAÇÃO DE EVENTO</strong></code> para capturar o gráfico de deadlock e empacotá-lo em uma mensagem que é enviada para o Serviço.</li>
        </ul>

        <p>A Listagem 7.2 mostra como criar esses objetos usando T-SQL. Observe que é necessário criar os objetos em um banco de dados com suporte ao broker, como o <code><strong>msdb</strong></code>. O banco de dados <code><strong>master</strong></code> não tem o broker habilitado por padrão.</p>
        
        <div id="container">
            <pre><code>
<cls>USE</cls> msdb;

<com>-- Create a service broker queue to hold the events</com>
<cls>CREATE QUEUE</cls> DeadlockQueue
<cls>GO</cls>

<com>-- Create a service broker service receive the events</com>
<cls>CREATE SERVICE</cls> DeadlockService
<cls>ON QUEUE</cls> DeadlockQueue ([http://schemas.microsoft.com/SQL/Notifications/
PostEventNotification])
<cls>GO</cls>

<com>-- Create the event notification for deadlock graphs on the service</com>
<cls>CREATE EVENT NOTIFICATION</cls> CaptureDeadlocks
<cls>ON SERVER</cls>
<cls>WITH</cls> FAN_IN
<cls>FOR</cls> DEADLOCK_GRAPH
<cls>TO SERVICE</cls> <string>'DeadlockService'</string>, <string>'current database'</string> ;
<cls>GO</cls>
            </code></pre>
        </div>
        
        <p class="legenda"><strong>Listagem 7.2</strong>: Criando os objetos de serviço, fila e notificação de evento do Service Broker.</p>

        <p>Com os objetos criados, os gráficos de deadlock serão coletados na fila à medida que os deadlocks ocorrerem no servidor. Embora a fila possa ser consultada usando uma instrução <code>SELECT</code>, como se fosse uma tabela, o conteúdo permanece na fila até que seja processado usando o comando <code>RECEIVE</code>, conforme demonstrado na Listagem 7.3.</p>

        <div id="container">
            <pre><code>

<cls>USE</cls> msdb ;

<com>-- Cast message_body to XML and query deadlock graph from TextData</com>
<cls>SELECT</cls> message_body.valuequery(<string>'(/EVENT_INSTANCE/TextData/</string>
                                 <string>deadlock-list)[1]', 'varchar(128)'</string>)
                                 <cls>AS</cls> DeadlockGraph
<cls>FROM</cls> ( <cls>SELECT</cls> CAST(message_body <cls>AS</cls> <cls>XML</cls>) <cls>AS</cls> message_body
       <cls>FROM</cls> DeadlockQueue
     ) <cls>AS</cls> sub ;
<cls>GO</cls>

<com>-- Receive the next available message FROM the queue</com>
DECLARE @message_body <cls>XML</cls> ;

<cls>RECEIVE TOP</cls>(1) -- just handle one message at a time
@message_body=message_body
<cls>FROM</cls> DeadlockQueue ;

<com>-- Query deadlock graph from TextData</com>
<cls>SELECT</cls> @message_body.valuequery(<string>'(/EVENT_INSTANCE/TextData/</string>
                                  <string>deadlock-list)[1]','varchar(128)'</string>)
                                  <cls>AS</cls> DeadlockGraph
<cls>GO</cls>
            </code></pre>
        </div>
        
        <p class="legenda">Listing 7.3: Query and processing DEADLOCK_GRAPH event messages in the queue.</p>
        
        <p>Como as Notificações de Eventos utilizam uma fila do service broker para processamento, ações adicionais podem ser realizadas quando o evento de deadlock é disparado. Quando ocorre um evento de deadlock, o Service Broker pode "ativar" uma procedure armazenada que processa a mensagem e responde adequadamente, por exemplo, enviando uma notificação por email usando Database Mail, registrando o evento em uma tabela ou coletando informações adicionais, como os planos de execução de ambas as instruções, a partir do SQL Server, com base nas informações contidas dentro do gráfico de deadlock. A cobertura completa desse tópico está além do escopo deste capítulo. No entanto, um exemplo completo de como usar a ativação de fila para automatizar completamente a coleta de deadlocks pode ser encontrado no arquivo de download do código deste livro.</p>

        <h3 id="wmiprovider">Provedor WMI para eventos de servidor</h3>

        <p>Também novo no SQL Server 2005, o Provedor WMI para Eventos de Servidor permite que o WMI seja usado para monitorar eventos do SQL Server à medida que ocorrem. Qualquer evento que possa ser capturado através de notificações de eventos tem um <strong>Objeto de Evento WMI</strong> correspondente, e qualquer aplicativo de gerenciamento WMI pode se inscrever nesses objetos de evento.</p>

        <p>O SQL Server Agent foi atualizado para gerenciar eventos WMI, através do uso da WMI Query Language (WQL), uma linguagem de consulta semelhante ao T-SQL que é usada com WMI e Alertas do Agent para eventos WMI.</p>

        <p>Um exemplo completo de como criar um alerta do SQL Agent para capturar e armazenar gráficos de deadlock está fora do escopo deste capítulo e pode ser encontrado no exemplo do Books Online, <em>Criando um Alerta do SQL Server Agent Usando o Provedor WMI para Eventos de Servidor</em> (<a href="http://msdn.microsoft.com/en-us/library/ms186385.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/ms186385.aspx</a>). No entanto, essencialmente, isso envolve a criação, via o Provedor de Eventos WMI, de um alerta do SQL Agent para monitorar eventos de gráfico de deadlock. O alerta consulta eventos usando WQL e, quando recebe a notificação de que um ocorreu, dispara um job que captura o gráfico de deadlock em uma tabela designada do SQL Server.</p>

        <p>Para capturar gráficos de deadlock usando o Provedor de Eventos WMI e um alerta do SQL Agent dessa maneira, é necessário que a opção "Substituir tokens para todas as respostas de jobs a alertas" nas propriedades do Sistema de Alertas do SQL Server Agent esteja habilitada. Também é necessário que o Service Broker (que processa as mensagens de notificação) esteja habilitado no msdb, bem como no banco de dados em que os gráficos de deadlock são armazenados.</p>

        <div class="dica">
            <p class="destaque">WMI event provider bug</p>
            <p>It is worth noting that there is a known bug in the WMI Event Provider for server names that exceed fourteen characters; this was fixed in Cumulative Update 5 for SQL Server 2005 Service Pack 2.</p>
        </div>

        <h3 id="extendevents">Eventos Estendidos</h3>

        <p>Antes do SQL Server 2008, não havia como encontrar informações sobre deadlocks retroativamente. Obter gráficos de deadlock exigia que um SQL Trace estivesse ativamente em execução, ou que as Trace Flags 1222 ou 1205 estivessem ativadas para a instância. Como rastrear deadlocks por qualquer um desses métodos pode ser intensivo em recursos, isso geralmente significava que uma série de deadlocks precisava ocorrer para motivar o início de um trace ou a ativação das Trace Flags.</p>
        
        <p>O SQL Server 2008 inclui todas as técnicas discutidas anteriormente para capturar gráficos de deadlock e adiciona uma nova, que é a coleta de informações de deadlock através da sessão de eventos padrão <code>system_health</code> em Eventos Estendidos. Esta sessão de eventos padrão (semelhante, em conceito, ao trace padrão) é executada por padrão em todas as instalações do SQL Server 2008 e coleta uma gama de informações úteis para solução de problemas de erros que ocorrem no SQL Server, incluindo deadlocks. Os gráficos de deadlock capturados por Eventos Estendidos no SQL Server 2008 têm a capacidade única de conter informações sobre deadlocks com múltiplas vítimas (deadlocks onde mais de uma sessão foi finalizada pelo Lock Monitor para resolver o conflito).</p>

        <div class="dica">
            <p class="destaque">Mais sobre Eventos Estendidos</p>
            <p>Não podemos cobrir Eventos Estendidos em detalhes neste livro, mas, para uma boa visão geral do tópico, leia o artigo de Paul Randal, "SQL 2008: Advanced Troubleshooting with Extended Events".(<a href="http://technet.microsoft.com/en-us/magazine/2009.01.sql2008.aspx" target="_blank">http://technet.microsoft.com/en-us/magazine/2009.01.sql2008.aspx</a>).</p>
        </div>

        <p>A sessão <code>system_health</code> usa um alvo <code>ring_buffer</code>, que armazena as informações coletadas pelos eventos disparados na memória como um documento XML na DMV <code>sys.dm_xe_session_targets</code>. Esta DMV pode ser juntada à DMV <code>sys.dm_xe_sessions</code> para obter as informações da sessão juntamente com os dados armazenados no alvo <code>ring_buffer</code>, conforme mostrado na Listagem 7.4.</p>

        <div id="container">
            <pre>
                <code>
<cls>SELECT</cls> <func>CAST</func>(target_data <cls>AS XML</cls>) <cls>AS</cls> TargetData
<cls>FROM</cls> <com>sys.dm_xe_session_targets</com> st
JOIN <com>sys.dm_xe_sessions</com> s <cls>ON</cls> s.<cls>address</cls> = st.event_session_address
<cls>WHERE</cls> name = <string>'system_health'</string>
            </code></pre>
        </div>
        
        <p class="legenda"><strong>Listagem 7.4</strong>: Recuperando informações da sessão <code>system_health</code>.</p>
        
        <p>A consulta no Listagem 7.5 mostra como recuperar um gráfico de deadlock XML válido da sessão padrão <code>system_health</code> usando XQuery, a coluna <code>target_data</code> e um <code>CROSS APPLY</code> para obter os nós individuais do evento. Observe que, devido às mudanças no gráfico de deadlock para suportar deadlocks com múltiplas vítimas e para minimizar o tamanho dos dados do evento, o XML resultante não pode ser salvo como um arquivo XDL para representação gráfica.</p>

        <div id="container">
            <pre><code>
<cls>SELECT</cls> <func>CAST</func>(event_data.value(<string>'(event/data/value)[1]'</string>,
                              <string>'varchar(max)'</string>) <cls>AS XML</cls>) <cls>AS</cls> DeadlockGraph
<cls>FROM</cls>   ( <cls>SELECT</cls>    XEvent.query(<string>'.'</string>) <cls>AS</cls> event_data
         <cls>FROM</cls>      (    <com>-- Cast the target_data to XML</com>
                     <cls>SELECT</cls>    <func>CAST</func>(target_data <cls>AS XML</cls>) <cls>AS</cls> TargetData
                     <cls>FROM</cls>      <com>sys.dm_xe_session_targets</com> st
                               <join>JOIN</join> <com>sys.dm_xe_sessions</com> s
                                <cls>ON</cls> s.<cls>address</cls> = st.event_session_address
                     <cls>WHERE</cls>     name = <string>'system_health'</string>
                               <join>AND</join> target_name = <string>'ring_buffer'</string>
                   ) <cls>AS</cls> Data <com>-- Split out the Event Nodes</com>
                   <join>CROSS APPLY</join> TargetData.nodes(<string>'RingBufferTarget/</string>
                                    <string>event[@name="xml_deadlock_report"]'</string>)
                   <cls>AS</cls> XEventData ( XEvent )
       ) <cls>AS</cls> tab ( event_data )
                </code></pre>
        </div>
        
        <p class="legenda"><strong>Listagem 7.5</strong>: Recuperando um gráfico de deadlock XML.</p>
        
        <p>Observe também que há um bug na versão RTM do SQL Server 2008 que faz com que os gráficos de deadlock não sejam capturados e retidos em uma sessão de Extended Events. Esse bug foi corrigido na Atualização Cumulativa 1 para o SQL Server 2008 e também está incluído no último Service Pack. Existe um bug adicional relacionado ao XML malformado no gráfico de deadlock gerado por Extended Events, que foi corrigido no Pacote de Atualização Cumulativa 6 para o SQL Server 2008 Service Pack 1. Ainda é possível gerar um documento XML válido nessas versões anteriores, manipulando o gráfico de deadlock sendo gerado por Extended Events. No entanto, como a correção para o SQL Server já foi lançada, os detalhes da solução alternativa não serão abordados neste capítulo.</p>
        
        <div class="dica">
            <p class="destaque">Mudanças no Extended Events no SQL Server Denali</p>
            <p>No momento das edições finais deste capítulo, o SQL Server Denali CTP3 foi lançado, com mudanças relacionadas a como os alvos do Extended Events armazenam dados XML dentro do elemento value na saída XML do Evento. A Listagem 7.5 mostra o uso do método .value() do XML no SQL Server, mas no Denali CTP3, o método .query() deve ser usado para recuperar o gráfico de deadlock da saída XML do Evento.</p>
        </div>

        <h2 id="deadlockgraphs">Lendo Gráficos de Deadlock</h2>
        
        <p>O formato exato do gráfico de deadlock no SQL Server mudou de versão para versão, e principalmente para melhor. Em geral, ele agora contém informações mais detalhadas em um formato mais fácil de entender, como a exibição gráfica fornecida no SQL Server Management Studio e no SQL Profiler, permitindo que possamos resolver deadlocks com mais facilidade.</p>

        <p>Mesmo com as mudanças no XML do gráfico de deadlock gerado pelo Extended Events no SQL Server 2008, os fundamentos de como interpretar o gráfico são os mesmos que para qualquer outro gráfico de deadlock em XML.</p>

        <h3 id="traceflag_1204">Interpretando Gráficos de Deadlock do Trace Flag 1204</h3>

        <p>Talvez um dos aspectos mais difíceis de solucionar deadlocks no SQL Server 2000 seja interpretar a saída do Trace Flag 1204. O processo é complicado pela necessidade de consultar as tabelas de sistema <code>sysobjects</code> e <code>sysindexes</code> para descobrir exatamente quais objetos estão envolvidos no deadlock.</p>

        <p>A Listagem 7.6 mostra um exemplo de gráfico de deadlock gerado ao habilitar o Trace Flag 1204 e, em seguida, criar uma situação de deadlock (o código para fazer isso está disponível como parte do download de código deste livro).</p>
        
        <div id="container">
            <pre>
                <code>
Deadlock encountered .... Printing deadlock information

Wait-for graph

Node:1
<CLS>KEY:</CLS> 13:1993058136:2 (08009d1c9ab1) <CLS>CleanCnt:</CLS>2 <CLS>Mode:</CLS> S <CLS>Flags:</CLS> 0x0
 Grant List 0::
   <CLS>
       <CLS>Owner:</CLS>0x567e7660 <CLS>Mode:</CLS> S <CLS>Flg:</CLS>0x0 <CLS>Ref:</CLS>1 <CLS>Life:</CLS>00000000 <CLS>SPID:</CLS>54 <CLS>ECID:</CLS>0
   </CLS>
   <CLS>SPID:</CLS> 54 <CLS>ECID:</CLS> 0 <CLS>Statement Type:</CLS> SELECT <CLS>Line #:</CLS> 3
   <CLS>Input Buf:</CLS> Language <cls>Event:</cls> WHILE (1=1)
BEGIN
    INSERT INTO #t1 EXEC BookmarkLookupSelect 4
    TRUNCATE TABLE #t1
END

 Requested By:
   <cls>ResType:</cls>LockOwner <cls>Stype:</cls>'OR' <cls>Mode:</cls> X <cls>SPID:</cls>55 <cls>ECID:</cls>0 <cls>Ec:</cls>(0x26F7DBD8)
<cls>Value:</cls>0x58f80880 <cls>Cost:</cls>(0/3C)

Node:2
<CLS>KEY:</CLS> 13:1993058136:1 (040022ae5dcc) <CLS>CleanCnt:</CLS>2 <CLS>Mode:</CLS> X <CLS>Flags:</CLS> 0x0
 Grant List 1::
   <CLS>Owner:</CLS>0x58f80940 <CLS>Mode:</CLS> X <CLS>Flg:</CLS>0x0 <CLS>Ref:</CLS>0 <CLS>Life:</CLS>02000000 <CLS>SPID:</CLS>55 <CLS>ECID:</CLS>0
   <CLS>SPID:</CLS> 55 <CLS>ECID:</CLS> 0 <CLS>Statement Type:</CLS> UPDATE <CLS>Line #:</CLS> 4
   <CLS>Input Buf:</CLS> Language <CLS>Event:</CLS> SET NOCOUNT ON
WHILE (1=1)
BEGIN
    EXEC BookmarkLookupUpdate 4
END

 Requested By:
   <cls>ResType:</cls>LockOwner <cls>Stype:</cls>'OR' <cls>Mode:</cls> S <cls>SPID:</cls>54 <cls>ECID:</cls>0 <cls>Ec:</cls>(0x2F881BD8)
<cls>Value:</cls>0x567e76c0 <cls>Cost:</cls>(0/0)

Victim Resource Owner:
 <cls>ResType:</cls>LockOwner <cls>Stype:</cls>'OR' <cls>Mode:</cls> S <cls>SPID:</cls>54 <cls>ECID:</cls>0 <cls>Ec:</cls>(0x2F881BD8)
<cls>Value:</cls>0x567e76c0 <cls>Cost:</cls>(0/0)
                </code></pre>
        </div>
        
        <p class="legenda"><strong>Listagem 7.6</strong>: Exemplo de gráfico de deadlock do Trace Flag 1204, envolvendo bloqueios KEY.</p>
        
        <p>A primeira coisa a se observar na saída do gráfico é que há dois <strong>nós</strong>, cada um representando um recurso bloqueado. A primeira linha de saída para cada nó mostra o recurso sobre o qual o bloqueio está mantido, e então a seção <strong>Grant List</strong> fornece detalhes da situação de deadlock, incluindo:</p>

        <ul>
            <li>Modo do bloqueio sendo mantido no recurso;</li>
            <li>SPID do processo associado;</li>
            <li>Tipo de instrução que o SPID está executando atualmente;</li>
            <li>Número da linha (line number) que marca o início da instrução atualmente em execução;</li>
            <li>Input Buf, o conteúdo do buffer de entrada para esse SPID (a última instrução enviada).</li>
        </ul>
        
        <p>Então, para o Nó 1, podemos ver que um bloqueio de leitura compartilhada (<code>S</code>) está sendo mantido pelo <code>SPID 54</code> em uma chave de índice de um índice não-clustered (<code>:2</code>) em um objeto com ID <code>1993058136</code>. O Nó 2 mostra que um bloqueio exclusivo (<code>X</code>) está sendo mantido pelo <code>SPID 55</code> em uma chave de índice do índice clustered (<code>:1</code>) do mesmo objeto.</p>
        
        <p>Mais adiante, para cada nó, está a seção <strong>Requested By</strong>, que detalha quaisquer solicitações de recursos que não podem ser concedidas devido ao bloqueio. Para o Nó 1, podemos ver que o <code>SPID 55</code> está aguardando um bloqueio exclusivo na chave do índice não-clustered (ele está bloqueado pelo bloqueio <code>S</code> mantido pelo <code>SPID 54</code>). Para o Nó 2, podemos ver que o <code>SPID 54</code> está aguardando adquirir um bloqueio de leitura compartilhada na chave do índice clustered (ele está bloqueado pelo bloqueio exclusivo mantido pelo <code>SPID 55</code>).</p>
        
        <p>Além disso, na seção <strong>Grant List</strong>, podemos ver que o <code>SPID 54</code> emitiu a instrução <code>SELECT</code> na Linha # 3 da stored procedure <code>BookmarkLookupSelect</code> (mas não consegue adquirir um bloqueio de leitura compartilhada) e o <code>SPID 55</code> emitiu a instrução <code>UPDATE</code> na Linha # 4 da stored procedure <code>BookmarkLookupUpdate</code> (mas não consegue adquirir um bloqueio exclusivo).</p>
        
        <p>Esta é uma situação clássica de deadlock, e é um dos tipos mais comuns de deadlock, abordado com mais detalhes posteriormente neste capítulo, na seção intitulada <a href="#" target="_self">Deadlock de busca de bookmark</a>.</p>
        
        <p>Finalmente, na seção <strong>Victim Resource Owner</strong>, podemos descobrir qual <code>SPID</code> foi escolhido como a vítima do deadlock, neste caso, o <code>SPID 54</code>. Alternativamente, podemos identificar a vítima do deadlock combinando as informações binárias no <code>Value</code> com as informações binárias na parte <code>Owner</code> da Grant List.</p>
        
        <p>Discutimos muito sobre o incidente de deadlock, mas até agora sabemos apenas que ocorreu em um objeto com ID <code>1993058136</code>. Para identificar corretamente os objetos envolvidos no deadlock, as informações na entrada <code>KEY</code> de cada nó precisam ser usadas para consultar <code>sysobjects</code> e <code>sysindexes</code>. A entrada <code>KEY</code> é formatada como <code>databaseid:objectid:indexid</code>. Então, neste exemplo, o <code>SPID 54</code> estava mantendo um bloqueio Shared (<code>S</code>) no <code>índice id 2</code>, um índice não-clustered, com objectID <code>1993058136</code>. A consulta na Listagem 7.7 mostra como determinar os nomes da tabela e do índice associados ao deadlock.</p>
        
        <div id="container">
            <pre>
                <code>
<cls>SELECT</cls>  o.name <cls>AS</cls> TableName ,
        i.name <cls>AS</cls> IndexName
<cls>FROM</cls>    <com>sysobjects</com> <cls>AS</cls> o
        <join>JOIN</join> <com>sysindexes</com> <cls>AS</cls> i <cls>ON</cls> o.id = i.id
<cls>WHERE</cls>   o.id = 1993058136
        <join>AND</join> i.indid <join>IN</join> ( 1, 2 )
                </code></pre>
        </div>
        
        <p class="legenda"><strong>Listagem 7.7</strong>: Encontrando os nomes dos objetos associados ao deadlock.</p>
        
        <p>Se um deadlock envolver um bloqueio de página (<code>PAG</code> lock) em vez de um bloqueio de chave (<code>KEY</code> lock), o gráfico de deadlock poderá se parecer com o mostrado na Listagem 7.8.</p>
        
        <div id="container">
            <pre>
                <code>
Wait-for graph
Node:1
<cls>PAG</cls>: 8:1:96 <cls>CleanCnt</cls>:2 <cls>Mode</cls>: X <cls>Flags</cls>: 0x2
    Grant List 0::
    <cls>Owner</cls>:0x195fb2e0 <cls>Mode</cls>: X <cls>Flg</cls>:0x0 <cls>Ref</cls>:1 <cls>Life</cls>:02000000
    <cls>SPID</cls>: 56 ECID: 0 <cls>Statement Type</cls>: UPDATE <cls>Line #</cls>: 4
    <cls>Input Buf</cls>: Language Event: SET NOCOUNT ON
WHILE (1=1)
BEGIN253
Chapter 7: Handling Deadlocks
EXEC BookmarkLookupUpdate 4
END

    Requested By:
    <cls>ResType</cls>:LockOwner <cls>Stype</cls>:'OR' <cls>Mode</cls>: S <cls>SPID</cls>:55 <cls>ECID</cls>:0 <cls>Ec</cls>:(0x1A5E1560)
<cls>Value</cls>:0x1960dba0 <cls>Cost</cls>:(0/0)
                </code></pre>
        </div>
        
        <p class="legenda"><strong>Listagem 7.8</strong>: Exemplo de bloqueio de página, gerado pelo Trace Flag 1204.</p>
        
        <p>Observe agora que a referência de bloqueio está no formato <code>databaseid:fileid:pageid</code>. Para identificar o objeto ao qual essa página pertence, precisamos habilitar o Trace Flag 3604, exibir as informações do cabeçalho da página na caixa de mensagens do cliente com **DBCC PAGE()**, e, em seguida, desabilitar o Trace Flag, conforme mostrado na Listagem 7.9.</p>
        
        <div id="container">
            <pre>
                <code>
<cls>DBCC</cls> TRACEON(3604)
<cls>DBCC</cls> PAGE(8,1,96,1)
<cls>DBCC</cls> TRACEOFF(3604)
                </code></pre>
        </div>
        
        <p class="legenda"><strong>Listagem 7.9</strong>: Identificando os objetos envolvidos em um deadlock que envolve bloqueios de página.</p>
        
        <p>A saída do comando <code>DBCC PAGE()</code> incluirá uma seção <code>PAGE HEADER</code>, mostrada na Listagem 7.10, que contém os IDs do objeto (campo <code>m_objId</code>) e do índice (campo <code>m_indexId</code>) ao qual a página pertence.</p>
        
        <div id="container">
            <pre>
                <code>
Page @0x1A5EC000
----------------
m_pageId = (1:96)       m_headerVersion = 1     m_type = 1
m_typeFlagBits = 0x0    m_level = 0             m_flagBits = 0x4
m_objId = 1977058079    m_indexId = 0           m_prevPage = (0:0)
m_nextPage = (1:98)     pminlen = 116           m_slotCnt = 66
m_freeCnt = 110         m_freeData = 7950       m_reservedCnt = 0
m_lsn = (912:41:3)      m_xactReserved = 0      m_xdesId = (0:0)
m_ghostRecCnt = 0       m_tornBits = 2
                </code></pre>
        </div>
        
        <p class="legenda"><strong>Listagem 7.10</strong>: Seção Page Header da saída do comando DBCC PAGE().</p>
        
        <p>Compreender as instruções que estão sendo executadas, juntamente com os índices e objetos envolvidos no deadlock, é fundamental para solucionar o problema. No entanto, há situações em que a instrução atualmente em execução pode não ser a real causadora do deadlock. Procedimentos armazenados multi-instruções e lotes que utilizam uma transação explícita irão manter todos os bloqueios adquiridos dentro do escopo da transação até que ela seja concluída (commit) ou revertida (rollback). Nessa situação, o deadlock pode envolver bloqueios adquiridos por uma instrução anterior que foi executada dentro do mesmo bloco de transação. Para solucionar completamente o deadlock, é necessário analisar o lote em execução no **Input Buf** como um todo e compreender quando os bloqueios estão sendo adquiridos e liberados.</p>

        <p>Bart Duncan é a fonte definitiva para interpretar gráficos de deadlock no SQL Server. Para informações adicionais sobre como ler a saída do Trace Flag 1204, consulte sua postagem no blog <code>Interpreting Trace Flag 1204 Output</code> (<a href="http://blogs.msdn.com/b/bartd/archive/2006/09/09/deadlock-troubleshooting_2c00_-part-1.aspx" target="_blank">http://blogs.msdn.com/b/bartd/archive/2006/09/09/deadlock-troubleshooting_2c00_-part-1.aspx</a>).</p>

        <h3 id="tf1222">Interpretando gráficos de deadlock do Trace Flag 1222</h3>

        <p>O formato das informações, assim como a quantidade de informações, retornadas pelo Trace Flag 1222 é muito diferente da saída do Trace Flag 1204. A Listagem 7.11 mostra a saída do Trace Flag 1222, no SQL Server 2005, para um deadlock idêntico ao que foi visto anteriormente na saída do Trace Flag 1204, do SQL Server 2000.</p>

        <div id="container">
            <pre>
                <code>
deadlock-list
 <cls>deadlock victim=process8d8c58</cls>

  process-list
   process id=process84b108 <cls>taskpriority=0 logused=220 waitresource=KEY:
34:72057594038452224 (0c006459e83f) waittime=5000 ownerId=899067977
transactionname=UPDATE lasttranstarted=2009-12-13T00:22:46.357 XDES=0x157be250
lockMode=X schedulerid=1 kpid=4340 status=suspended</cls> spid=102 <cls>sbid=0
ecid=0 priority=0 transcount=2 lastbatchstarted=2009-12-13T00:13:37.510
lastbatchcompleted=2009-12-13T00:13:37.507 clientapp=Microsoft SQL Server
Management Studio - Query hostname=SQL2K5TEST hostpid=5516 loginname=sa
isolationlevel=read committed (2) xactid=899067977 currentdb=34
lockTimeout=4294967295 clientoption1=673187936 clientoption2=390200</cls>
    executionStack
     <cls>frame procname=DeadlockDemo.dbo.BookmarkLookupUpdate line=4 stmtstart=260
stmtend=394 sqlhandle=0x03002200e7a4787d08a10300de9c00000100000000000000
UPDATE BookmarkLookupDeadlock SET col2 = col2-1 WHERE col1 = @col2
     frame procname=adhoc line=4 stmtstart=82 stmtend=138 sqlhandle=0x020000002a709
3322fbd674049d04f1dc0f3257646c4514b
EXEC BookmarkLookupUpdate 4
    inputbuf
SET NOCOUNT ON
WHILE (1=1)
BEGIN
    EXEC BookmarkLookupUpdate 4
END</cls>
    process id=process8d8c58 <cls>taskpriority=0 logused=0 waitresource=KEY:
34:72057594038386688 (0500b49e5abb) waittime=5000 ownerId=899067972
transactionname=INSERT EXEC lasttranstarted=2009-12-13T00:22:46.357
XDES=0x2aebba08 lockMode=S schedulerid=2 kpid=5864 status=suspended</cls>
spid=61 <cls>sbid=0 ecid=0 priority=0 transcount=1 lastbatchstarted=2009-12-
13T00:22:46.347 lastbatchcompleted=2009-12-13T00:22:46.343 clientapp=Microsoft
SQL Server Management Studio - Query hostname=SQL2K5TEST hostpid=5516
loginname=sa isolationlevel=read committed (2) xactid=899067972 currentdb=34
lockTimeout=4294967295 clientoption1=673187936 clientoption2=390200</cls>
     executionStack
      <cls>frame procname=DeadlockDemo.dbo.BookmarkLookupSelect line=3 stmtstart=118
stmtend=284 sqlhandle=0x03002200ae80847c07a10300de9c00000100000000000000
SELECT col2, col3 FROM BookmarkLookupDeadlock WHERE col2 BETWEEN @col2 AND @col2+1
     frame procname=adhoc line=3 stmtstart=50 stmtend=146 sqlhandle=0x02000000e00b6
6366c680fabe2322acbad592a896dcab9cb
INSERT INTO #t1 EXEC BookmarkLookupSelect 4
    inputbuf
WHILE (1=1)
BEGIN
    INSERT INTO #t1 EXEC BookmarkLookupSelect 4
    TRUNCATE TABLE #t1
END</cls>

  resource-list
   <cls>keylock hobtid=72057594038386688 dbid=34 objectname=DeadlockDemo.dbo.
BookmarkLookupDeadlock indexname=cidx_BookmarkLookupDeadlock id=lock137d65c0 mode=X
associatedObjectId=72057594038386688
     owner-list</cls>
      owner id=process84b108 mode=X
     <cls>waiter-list</cls>
     waiter id=process8d8c58 mode=S <cls>requestType=wait
keylock hobtid=72057594038452224 dbid=34 objectname=DeadlockDemo.dbo.
BookmarkLookupDeadlock indexname=idx_BookmarkLookupDeadlock_col2 id=lock320d5900
mode=S associatedObjectId=72057594038452224
    owner-list</cls>
     owner id=process8d8c58 mode=S
    <cls>waiter-list</cls>
     waiter id=process84b108 mode=X <cls>requestType=wait</cls>
                </code></pre>
        </div>
        
        <p class="legenda"><strong>Listagem 7.11</strong>: Exemplo de gráfico de deadlock, gerado pelo Trace Flag 1222.</p>
        
        <p>O novo formato divide um deadlock em seções que definem a vítima do deadlock, os processos envolvidos no deadlock (<code>process-list</code>) e os recursos envolvidos no deadlock (<code>resource-list</code>). Cada processo possui um ID de processo atribuído que é usado para identificá-lo de forma exclusiva no gráfico de deadlock. A seção da vítima do deadlock lista o processo selecionado como vítima e encerrado pelo monitor de deadlock. Cada processo inclui o <code>SPID</code>, bem como o hostname e o loginname que originaram a solicitação, além do nível de isolamento em que a sessão estava sendo executada quando o deadlock ocorreu. A seção de pilha de execução, para cada processo, exibe toda a pilha de execução, começando pela instrução mais recentemente executada (que gerou o deadlock) até o início da pilha de chamadas. Isso elimina a necessidade de realizar etapas adicionais para identificar a instrução que estava sendo executada.</p>

        <p>A <code>resource-list</code> contém todas as informações sobre os recursos envolvidos no deadlock e geralmente é o ponto de partida para a leitura de um gráfico de deadlock. Os nomes dos índices estão incluídos na saída, e cada recurso exibe o processo proprietário e o tipo de bloqueios mantidos, assim como o processo em espera e o tipo de bloqueios solicitados.</p>

        <p>Assim como na saída do Trace Flag 1204, a fonte definitiva para entender a saída do Trace Flag 1222 é Bart Duncan. Ele possui uma série em três partes sobre como diagnosticar deadlocks utilizando a saída do Trace Flag 1222 em seu blog, começando com <em>Deadlock Troubleshooting, Part 1</em> (<a href="http://blogs.msdn.com/bartd/archive/2006/09/09/747119.aspx" target="_blank">http://blogs.msdn.com/bartd/archive/2006/09/09/747119.aspx</a>).</p>

        <p>Usando a mesma técnica empregada nessas postagens, podemos construir uma descrição do deadlock descrito, conforme mostrado na Listagem 7.12.</p>

        <div id="container">
            <pre>
                <code>
SPID 102 (process84b108) is running this query (line 4 of the BookmarkLookupUpdate
sproc):
   UPDATE BookmarkLookupDeadlock SET col2 = col2-1 WHERE col1 = @col2

SPID 61 (process8d8c58 )is running this query (line 3 of BookmarkLookupSelect
sproc):
   SELECT col2, col3 FROM BookmarkLookupDeadlock WHERE col2
                                                   BETWEEN @col2 AND @col2+1

SPID 102 is waiting for an Exclusive KEY lock on the idx_BookmarkLookupDeadlock_
col2 index (on the BookmarkLookupDeadlock table).
   (SPID 61 holds a conflicting S lock)

SPID 61 is waiting for a Shared KEY lock on the index cidx_BookmarkLookupDeadlock
(on the BookmarkLookupDeadlock table)..
   (SPID 102 holds a conflicting X lock)
                </code></pre>
        </div>

        <p class="legenda"><strong>Listagem 7.12</strong>: Análise de deadlock, construída a partir do gráfico de deadlock do Trace Flag 1222.</p>

        <p>Como podemos ver na seção da lista de deadlocks da Listagem 7.11, o SPID 61, ao tentar executar a instrução <code>SELECT</code> contra o <code>cidx_BookmarkLookupDeadlock</code>, é escolhido como a vítima do deadlock.</p>

        <h3 id="deadlock_xml">Interpretando gráficos de deadlock em XML</h3>

        <p>As informações contidas no gráfico de deadlock em XML, obtido do SQL Profiler, notificações de eventos do Service Broker, entre outros, são essencialmente as mesmas que as obtidas a partir da saída do Trace Flag 1222 e são interpretadas da mesma forma. No entanto, o formato em que as informações são apresentadas é muito diferente. O gráfico de deadlock em XML pode ser exibido graficamente no Management Studio ao salvar o XML em um arquivo com a extensão <code>.XDL</code> e abrir o arquivo no Management Studio (embora, como discutido anteriormente, o XML gerado por Extended Events não possa ser exibido graficamente dessa maneira).</p>

        <p>A Figura 7.4 exibe graficamente o mesmo gráfico de deadlock que vimos para os dois Trace Flags.</p>

        <img src="imagens/fig74.png" alt="Figura 7.4: exibe graficamente o mesmo gráfico de deadlock que vimos para os dois Trace Flags."/>

        <p class="legenda"><strong>Figura 7.4</strong>: Gráfico de deadlock gráfico do SSMS.</p>

        <p>Na exibição gráfica, os processos de deadlock são exibidos como ovais. As informações do processo são exibidas dentro do oval e incluem uma dica de ferramenta, que aparece quando o mouse passa sobre o processo, mostrando a instrução que está sendo executada, conforme mostrado na **Figura 7.5**. O processo vítima do deadlock é mostrado riscado.</p>

        <img src="imagens/fig75.png" alt="Gráfico de deadlock gráfico do SSMS: o processo vítima."/>

        <p class="legenda"><strong>Figura 7.5</strong>: Gráfico de deadlock gráfico do SSMS: o processo vítima.</p>
        
        <p>Os recursos que contribuem para o deadlock são exibidos em caixas retangulares no centro da exibição gráfica. Os bloqueios e seus respectivos modos são exibidos por setas entre os processos e os recursos. Os bloqueios pertencentes a um processo são mostrados com a seta apontando para o processo, enquanto os bloqueios sendo solicitados são mostrados com a seta apontando para o recurso, conforme mostrado na Figura 7.6.</p>

        <img src="imagens/fig76.png" alt="Gráfico de deadlock gráfico do SSMS: processos e recursos."/>

        <p class="legenda"><strong>Figura 7.6</strong>: Gráfico de deadlock gráfico do SSMS: processos e recursos.</p>

        <p>Uma exibição visual como esta torna muito mais fácil entender o bloqueio circular que causou o deadlock.</p>

        <h2 id="commomtypedeadlock">Tipos comuns de deadlock e como eliminá-los</h2>

        <p>Ao solucionar qualquer tipo de problema no SQL Server, você aprende com a experiência a reconhecer, à distância, os tipos específicos de problemas que tendem a surgir regularmente. O mesmo ocorre com deadlocks; os mesmos tipos de deadlock tendem a aparecer com uma regularidade previsível e, uma vez que você entende quais padrões procurar, resolver o deadlock se torna muito mais simples.</p>

        <p>Esta seção pressupõe o conhecimento dos mecanismos básicos de bloqueio no SQL Server (consulte o <a href="cap06.html" target="_self">Capítulo 6</a>) e analisa como resolver os tipos mais comuns de deadlock, a saber: o deadlock de busca por índice (<strong>bookmark lookup</strong> deadlock), o deadlock de varredura em intervalo serializável (<strong>serializable range scan</strong> deadlock), o deadlock de restrição em cascata (<strong>cascading constraint</strong> deadlock), o deadlock de paralelismo intra-consulta (<strong>intra-query parallelism</strong> deadlock) e o deadlock causado pelo acesso a objetos em ordens diferentes (<strong>accessing objects in different orders</strong> deadlock).</p>

        <h3 id="bookmarklookup">Bookmark lookup deadlock</h3>

        <p>Os deadlocks de busca por índice (bookmark lookup deadlocks) são um dos tipos mais comuns de deadlock no SQL Server. Felizmente, embora tendam a aparecer de forma aleatória, sem quaisquer alterações no banco de dados ou no código, eles também estão entre os tipos de deadlock mais fáceis de solucionar.</p>

        <p>Os deadlocks de busca por índice geralmente têm uma instrução <code>SELECT</code> como vítima e uma instrução INSERT, UPDATE ou DELETE como o outro processo contribuinte para o deadlock. Eles ocorrem, em parte, como uma consequência geral dos mecanismos de bloqueio pessimistas do SQL Server para concorrência, mas principalmente devido à falta de um índice de cobertura adequado para a operação SELECT.</p>

        <p>Quando uma coluna é usada na cláusula <code>WHERE</code> para filtrar a instrução <code>SELECT</code> e existe um índice não clusterizado nessa coluna, o mecanismo de banco de dados aplica um bloqueio compartilhado nas linhas ou páginas necessárias no índice não clusterizado. Para retornar quaisquer colunas adicionais da tabela que não sejam cobertas pelo índice não clusterizado, o mecanismo de banco de dados realiza uma operação conhecida como KEY ou RID lookup (no SQL Server 2000, o termo "bookmark lookup" era usado). Essa operação utiliza a chave do índice clusterizado ou o RID (no caso de um heap) para localizar a linha nos dados da tabela e recuperar as colunas adicionais.</p>

        <p>Quando ocorre uma operação de lookup, o mecanismo de banco de dados aplica bloqueios compartilhados adicionais nas linhas ou páginas necessárias da tabela. Esses bloqueios são mantidos durante toda a operação <code>SELECT</code> ou até que ocorra a escalada de bloqueio para aumentar a granularidade do bloqueio de linha ou página para tabela.</p>

        <p>O deadlock ocorre, como vimos em seções anteriores, quando uma operação que altera os dados em uma tabela (por exemplo, uma operação de <code>INSERT</code>, <code>UPDATE</code> ou <code>DELETE</code>) acontece simultaneamente com a operação <code>SELECT</code>. Quando a sessão que altera os dados é executada, ela adquire um bloqueio exclusivo na linha ou página do índice clusterizado ou tabela e realiza a operação de alteração de dados. Ao mesmo tempo, a operação <code>SELECT</code> adquire um bloqueio compartilhado no índice não clusterizado. A operação de alteração de dados requer um bloqueio exclusivo no índice não clusterizado para concluir a modificação, e a operação <code>SELECT</code> requer um bloqueio compartilhado no índice clusterizado ou tabela para realizar o bookmark lookup. Bloqueios compartilhados e exclusivos são incompatíveis, então, se a operação de alteração de dados e a operação <code>SELECT</code> afetarem as mesmas linhas, a operação de alteração será bloqueada pelo <code>SELECT</code>, e o <code>SELECT</code> será bloqueado pela alteração de dados, resultando em um deadlock.</p>

        <p>Uma das recomendações mais comuns online para resolver esse tipo de deadlock é usar a dica de tabela <code>NOLOCK</code> na instrução <code>SELECT</code>, para evitar que ela adquira bloqueios compartilhados. Essa é uma má prática. Embora possa evitar o deadlock, pode causar efeitos colaterais indesejados, como permitir que operações leiam alterações não confirmadas nos dados do banco de dados, resultando assim em resultados imprecisos.</p>

        <p>A correção adequada para esse tipo de deadlock é alterar a definição do índice não clusterizado para que ele contenha, como colunas-chave adicionais ou como colunas <code>INCLUDE</code> (veja o <a href="cap05.html">Capítulo 5</a>), todas as colunas necessárias para cobrir a consulta. As colunas retornadas pela consulta que não são usadas em uma cláusula <code>JOIN</code>, <code>WHERE</code> ou <code>GROUP BY</code> podem ser adicionadas ao índice como colunas INCLUDE. Qualquer coluna usada em um <code>JOIN</code>, na cláusula <code>WHERE</code> ou em um <code>GROUP BY</code> deve idealmente fazer parte da chave do índice, mas, em casos onde isso exceda o limite de 900 bytes, adicioná-la como uma coluna <code>INCLUDE</code> também pode funcionar. Implementar o índice de cobertura resolverá o deadlock sem os efeitos colaterais inesperados de usar <code>NOLOCK</code>.</p>
        
        <p>Uma maneira rápida de encontrar o índice de cobertura apropriado para uma consulta é executá-la no Database Engine Tuning Advisor (DTA). No entanto, como discutido no <a href="cap05.html">Capítulo 5</a>, as recomendações do DTA são tão boas quanto a carga de trabalho fornecida, e a avaliação repetida de uma única consulta no mesmo banco de dados pode resultar em um número excessivo de índices, que frequentemente se sobrepõem. É recomendável revisar manualmente qualquer recomendação de índice feita pelo DTA para determinar se a modificação de um índice existente pode cobrir a consulta sem criar um novo índice. Um bom exemplo em vídeo, <em>"Using the DTA to Assist in Performance Tuning"</em>, pode ser encontrado no site SQL Share (<a href="http://www.sqlshare.com/using-thedta-to-assist-in-performance-tuning_599.aspx" target="_blank">http://www.sqlshare.com/using-thedta-to-assist-in-performance-tuning_599.aspx</a>).</p>

        <h3 id="rangescan">Range scans causados por isolamento SERIALIZABLE</h3>

        <p>O nível de isolamento <code>SERIALIZABLE</code> é o nível de isolamento mais restritivo no SQL Server para controle de concorrência, garantindo que cada transação seja completamente isolada dos efeitos de qualquer outra transação.</p>

        <p>Para alcançar esse nível de isolamento transacional, <strong>bloqueios de intervalo</strong> são usados ao ler dados, no lugar dos bloqueios de nível de linha ou página usados no isolamento <code>READ COMMITTED</code>. Esses bloqueios de intervalo garantem que nenhuma alteração nos dados possa ocorrer que afete o conjunto de resultados, permitindo que a operação seja repetida dentro da mesma transação com o mesmo resultado. Embora o nível de isolamento padrão do SQL Server seja <code>READ COMMITTED</code>, certos provedores, como COM+ e BizTalk, alteram o isolamento para <code>SERIALIZABLE</code> quando as conexões são feitas.</p>

        <p>Os bloqueios de intervalo têm dois componentes associados aos seus nomes: o tipo de bloqueio usado para bloquear o intervalo e o tipo de bloqueio usado para bloquear as linhas individuais dentro do intervalo. Os quatro bloqueios de intervalo mais comuns são: compartilhado-compartilhado (<code>RangeS-S</code>), compartilhado-atualização (<code>RangeS-U</code>), inserção-nulo (<code>RangeI-N</code>) e exclusivo (<code>RangeX-X</code>). Deadlocks associados ao isolamento <code>SERIALIZABLE</code> geralmente são causados por conversão de bloqueio, onde um bloqueio de maior compatibilidade, como um bloqueio <code>RangeS-S</code> ou <code>RangeS-U</code>, precisa ser convertido para um bloqueio de menor compatibilidade, como um bloqueio <code>RangeI-N</code> ou <code>RangeX-X</code>.</p>

        <p>Um deadlock comum que ocorre sob o isolamento <code>SERIALIZABLE</code> tem um padrão que envolve uma transação que verifica se uma linha existe em uma tabela antes de inserir ou atualizar os dados na tabela. Um exemplo reproduzível desse deadlock está incluído nos exemplos de código para este capítulo. Esse tipo de deadlock geralmente produzirá um gráfico de deadlock com um <code>resouce-list</code> semelhante à mostrada na Lista 7.13.</p>

        <div id="container">
            <pre>
                <code><cls>
    &lt;resource-list&gt;
      &lt;keylock hobtid=&quot;72057594050969600&quot; dbid=&quot;5&quot; objectname=&quot;AdventureWorks.
Sales.SalesOrderHeader&quot; indexname=&quot;IX_SalesOrderHeader_CustomerID&quot; id=&quot;lock35bcc80&quot; 
mode=&quot;RangeS-U&quot; associatedObjectId=&quot;72057594050969600&quot;&gt;
        &lt;owner-list&gt;
          &lt;owner id=&quot;processad4d2e8&quot; mode=&quot;RangeS-U&quot; /&gt;
          &lt;owner id=&quot;process9595b8&quot; mode=&quot;RangeS-S&quot; /&gt;
        &lt;/owner-list&gt;
        &lt;waiter-list&gt;
          &lt;waiter id=&quot;processad4d2e8&quot; mode=&quot;RangeI-N&quot; requestType=&quot;convert&quot; /&gt;
          &lt;waiter id=&quot;process9595b8&quot; mode=&quot;RangeI-N&quot; requestType=&quot;convert&quot; /&gt;
        &lt;/waiter-list&gt;
      &lt;/keylock&gt;
    &lt;/resource-list&gt;
                </cls></code></pre>
        </div>

        <p class="legenda"><strong>Listagem 7.13</strong>: Extração de um gráfico de deadlock para um deadlock de varredura de intervalo SERIALIZABLE.</p>

        <p>Neste exemplo, dois processos adquiriram locks compartilhados compatíveis, <code>RangeS-S</code> e <code>RangeS-U</code>, na tabela <code>SalesOrderHeader</code>. Quando um dos processos necessita de uma conversão de lock para um tipo de lock que é incompatível com o lock mantido pelo outro processo, neste caso um <code>RangeI-N</code>, ele fica bloqueado. Se ambos os processos exigirem uma conversão de lock para locks <code>RangeI-N</code>, o resultado é um deadlock, pois cada sessão está esperando que a outra libere seu lock de alta compatibilidade.</p>

        <p>Existem várias soluções possíveis para esse tipo de deadlock, e a mais apropriada depende do banco de dados e da aplicação que ele suporta. Se não for necessário que o banco de dados mantenha os locks de intervalo adquiridos durante a operação <code>SELECT</code> que verifica a existência da linha, e a operação <code>SELECT</code> puder ser movida para fora da transação que realiza a alteração de dados, então o deadlock pode ser prevenido.</p>
        
        <p>Se a operação não exigir o uso da isolação <code>SERIALIZABLE</code>, então alterar o nível de isolação para um nível menos restritivo, por exemplo, <code>READ COMMITTED</code>, impedirá o deadlock e permitirá um maior grau de concorrência.</p>

        <p>Se nenhuma dessas soluções for apropriada, o deadlock pode ser resolvido forçando a instrução <code>SELECT</code> a usar um lock de menor compatibilidade, através do uso de uma dica de tabela <code>UPDLOCK</code> ou <code>XLOCK</code>. Isso bloqueará quaisquer outras transações que tentem adquirir locks de maior compatibilidade. Esta solução é específica para este tipo particular de deadlock devido ao uso da isolação <code>SERIALIZABLE</code>. O uso de dicas <code>UPDLOCK</code> sob o <code>READ COMMITTED</code> pode resultar em deadlocks ocorrendo com mais frequência em determinadas circunstâncias.</p>

        <h3 id="cascadeadlock">Deadlocks em restrições em cascata</h3>

        <p>Deadlocks em restrições em cascata são, geralmente, muito semelhantes a um deadlock de varredura de intervalo no nível de isolamento Serializable, mesmo que o nível de isolamento da transação vítima não seja <code>SERIALIZABLE</code>. Para aplicar as restrições em cascata, o SQL Server precisa percorrer a hierarquia de <code>FOREIGN KEY</code> para garantir que registros filhos órfãos não sejam deixados para trás como resultado de uma operação de <code>UPDATE</code> ou <code>DELETE</code> na tabela pai. Para isso, é necessário que a transação que modifica a tabela pai esteja isolada dos efeitos de outras transações, a fim de evitar mudanças que violem as restrições de <code>FOREIGN</code> KEY quando a operação em cascata for concluída posteriormente.</p>

        <p>No nível de isolamento padrão <code>READ COMMITTED</code>, o mecanismo de banco de dados adquire e mantém, durante toda a transação, bloqueios exclusivos (Exclusive locks) em todas as linhas que precisam ser alteradas. Isso impede que outros usuários leiam ou alterem as linhas afetadas, mas não impede que outra sessão adicione uma nova linha na tabela filha para a chave pai que está sendo excluída. Para evitar esse comportamento, o mecanismo de banco de dados adquire e mantém bloqueios de intervalo (Range locks), que impedem a adição de novas linhas dentro do intervalo afetado pela operação em cascata. Isso é, essencialmente, um uso implícito do isolamento <code>SERIALIZABLE</code> durante a aplicação da restrição em cascata, mas o nível de isolamento do lote não é realmente alterado; apenas o tipo de bloqueios usados na operação em cascata é modificado.</p>
        
        <p>Quando ocorre um deadlock durante uma operação em cascata, a primeira coisa a verificar é se existem ou não índices não clusterizados para as colunas de <code>FOREIGN KEY</code> que estão sendo utilizadas (consulte o <a href="cap05.html" target="_self">Capítulo 5</a> para mais informações sobre indexação de FOREIGN KEYS). Se índices apropriados nas colunas de <code>FOREIGN KEY</code> não existirem, os bloqueios realizados para aplicar as restrições serão mantidos por períodos mais longos, aumentando a probabilidade de um deadlock entre duas operações, caso ocorra uma conversão de bloqueio.</p>

        <h3 id="intraconsulta">Deadlocks de paralelismo intra-consulta</h3>

        <p>Um deadlock de paralelismo intra-consulta ocorre quando uma única sessão executa uma consulta que utiliza paralelismo e acaba entrando em deadlock consigo mesma. Diferentemente de outros deadlocks no SQL Server, esses deadlocks podem ser causados por um bug no código de sincronização de paralelismo do SQL Server, e não por um problema no design do banco de dados ou da aplicação. Como existem riscos associados à correção de alguns bugs, pode ser que o bug seja conhecido e não seja corrigido, pois é possível contorná-lo reduzindo o grau de paralelismo da consulta usando a dica de consulta <code>MAXDOP</code>, ou adicionando ou alterando índices para reduzir o custo da consulta ou torná-la mais eficiente.</p>

        <p>O gráfico de deadlock para um deadlock de paralelismo terá o mesmo SPID para todos os processos e terá mais de dois processos na <code>process-list</code>. A <code>resource-list</code> incluirá <code><strong>threadpool</strong></code>, <code><strong>exchangeEvent</strong></code>, ou ambos, como recursos, mas não terá recursos de bloqueio associados a ela. Além disso, o gráfico de deadlock para esse tipo de deadlock será significativamente mais longo do que qualquer outro tipo de deadlock, dependendo do grau de paralelismo e do número de nós existentes no plano de execução.</p>

        <p>Informações adicionais sobre esse tipo específico de deadlock podem ser encontradas na postagem do blog de Bart Duncan, intitulada <em>Today's Annoyingly-Unwieldy Term: "Intra-Query Parallel Thread Deadlocks"</em> (<a href="http://blogs.msdn.com/bartd/archive/2008/09/24/today-s-annoyinglyunwieldy-term-intra-query-parallel-thread-deadlocks.aspx" target="_blank">http://blogs.msdn.com/bartd/archive/2008/09/24/today-s-annoyinglyunwieldy-term-intra-query-parallel-thread-deadlocks.aspx</a>).</p>
        
        <h3 id="accessobjects">Acessando objetos em ordens diferentes</h3>

        <p>Um dos deadlocks mais fáceis de criar, e consequentemente um dos mais fáceis de prevenir, é causado pelo acesso a objetos em um banco de dados em diferentes ordens de operação dentro do código T-SQL, dentro de transações, como mostrado nos Listagens 7.14 e 7.15.</p>

        <div id="container">
            <pre>
                <code>
<cls>BEGIN TRANSACTION</cls>

<cls>UPDATE</cls> TabelaA
<cls>SET</cls>    Coluna1 = 1

<cls>SELECT</cls> Coluna2
<cls>FROM</cls>   TabelaB
                </code></pre>
        </div>

        <p class="legenda"><strong>Listagem 7.14</strong>: A Transação1 atualiza a TabelaA e, em seguida, lê a TabelaB.</p>

        <div id="container">
            <pre>
                <code>
<cls>BEGIN TRANSACTION</cls>

<cls>UPDATE</cls> TabelaB
<cls>SET</cls>    Column2 = 1

<cls>SELECT</cls> Coluna2
<cls>FROM</cls>   TabelaA
                </code></pre>
        </div>
        
        <p class="legenda"><strong>Listagem 7.15</strong>: A Transação2 atualiza a TabelaB e depois lê a TabelaA.</p>
        
        <p>A Transação1 faz um <code>UPDATE</code> na <code>TabelaA</code>, resultando em um bloqueio exclusivo (exclusive lock) na tabela até que a transação seja concluída. Ao mesmo tempo, a Transação2 executa um <code>UPDATE</code> na <code>TabelaB</code>, o que também gera um bloqueio exclusivo até a conclusão da transação. Após concluir o <code>UPDATE</code> na <code>TabelaA</code>, a Transação1 tenta ler a <code>TabelaB</code>, mas é bloqueada porque não consegue obter o bloqueio compartilhado necessário, devido ao bloqueio exclusivo mantido pela Transação2. Da mesma forma, após finalizar o <code>UPDATE</code> na <code>TabelaB</code>, a Transação2 tenta ler a <code>TabelaA</code>, mas também é bloqueada, pois não consegue obter o bloqueio compartilhado necessário devido ao bloqueio exclusivo mantido pela Transação1. Como ambas as transações estão se bloqueando mutuamente, ocorre um deadlock, e o Monitor de Bloqueios encerrará uma das sessões, revertendo sua transação para permitir que a outra seja concluída.</p>

        <p>Ao utilizar transações explícitas no código, é fundamental que os objetos sejam sempre acessados na mesma ordem para prevenir a ocorrência desse tipo de deadlock.</p>

        <h2 id="handlingdeadlocks">Lidando com Deadlocks para Prevenir Erros</h2>

        <p>Na maioria dos casos, os mesmos problemas que causam bloqueios severos no banco de dados, como design inadequado do banco de dados, falta de indexação, consultas mal projetadas, nível de isolamento inadequado e assim por diante (todos discutidos no <a href="cap06.html" target="_self">Capítulo 6</a>), também são as causas comuns de deadlocks. Na maioria dos casos, ao corrigir esses problemas, podemos prevenir a ocorrência de deadlocks. Infelizmente, quando os deadlocks se tornam um problema, pode não ser possível fazer as alterações necessárias no design para corrigi-los.</p>

        <p>Portanto, uma parte importante do design de aplicativos e bancos de dados é a programação defensiva; uma técnica que antecipa e lida com exceções como parte da base de código geral para um aplicativo ou banco de dados. A programação defensiva para lidar com exceções de deadlock pode ser implementada de duas maneiras diferentes:</p>

        <ul>
            <li>do lado do banco de dados, através do uso de blocos TRY…CATCH do T-SQL</li>
            <li>do lado da aplicação, através do uso de blocos TRY…CATCH da aplicação.</li>
        </ul>

        <p>Em ambos os casos, o tratamento adequado da exceção 1205 gerada pelo SQL Server para a vítima do deadlock pode ajudar a evitar erros de UnhandledException na aplicação e as subsequentes chamadas dos usuários finais para o Help Desk ou Suporte.</p>
        
        <h3 id="trycatch">Blocos T-SQL TRY…CATCH</h3>

        <p>Dependendo de como uma aplicação é projetada, e se há separação entre o código da aplicação e o código do banco de dados, a implementação mais simples do tratamento de erros de deadlock pode ser feita por meio do uso de blocos <code>BEGIN TRY/CATCH</code> dentro do T-SQL que está sendo executado.</p>

        <p>Esta técnica é mais aplicável em casos onde uma aplicação chama procedimentos armazenados para todo o seu acesso a dados. Nesses casos, alterar o código em um procedimento armazenado para que ele lide com a exceção de deadlock não requer mudanças no código da aplicação, recompilação e redistribuição da aplicação. Isso simplifica muito a implementação dessas mudanças.</p>

        <p>A melhor maneira de lidar com um deadlock, dentro do seu código de tratamento de erros, dependerá da sua aplicação e do comportamento esperado em caso de deadlock. Uma maneira de lidar com o deadlock seria tentar a transação um determinado número de vezes antes de realmente lançar uma exceção de volta para a aplicação tratar. A situação de bloqueio cruzado associada a um deadlock geralmente dura apenas um curto período de tempo, geralmente medido em milissegundos, então, na maioria das vezes, uma tentativa subsequente de executar o código T-SQL selecionado como vítima terá sucesso, e não haverá necessidade de lançar exceções para a aplicação.</p>

        <p>No entanto, é possível que o deadlock continue a ocorrer, e precisamos evitar entrar em um loop infinito, tentando repetidamente executar o mesmo código com falha. Para prevenir isso, uma variável é usada para contar a partir de um número máximo de tentativas; quando zero é alcançado, uma exceção será lançada de volta para a aplicação. Esta técnica é demonstrada na Listagem 7.16.</p>

        <div id="container">
            <pre>
                <code>
<cls>DECLARE</cls> @retries <cls>INT</cls> ;
<cls>SET</cls> @retries = 4 ;

<cls>WHILE</cls> ( @retries > 0 )
    <cls>BEGIN</cls>
        <cls>BEGIN TRY</cls>
            <cls>BEGIN TRANSACTION</cls> ;

            <com>-- place sql code here</com>
            <cls>SET</cls> @retries = 0 ;

            <cls>COMMIT TRANSACTION</cls> ;
        <cls>END TRY</cls>
        <cls>BEGIN CATCH</cls>
            <com>-- Error is a deadlock</com>
            <cls>IF</cls> ( <func>ERROR_NUMBER</func>() = 1205 )
                <cls>SET</cls> @retries = @retries - 1 ;

            <com>-- Error is not a deadlock</com>
            <cls>ELSE</cls>
                <cls>BEGIN</cls>
                    <cls>DECLARE</cls> @ErrorMessage <cls>NVARCHAR</cls>(4000) ;
                    <cls>DECLARE</cls> @ErrorSeverity <cls>INT</cls> ;
                    <cls>DECLARE</cls> @ErrorState <cls>INT</cls> ;

                    <cls>SELECT</cls> @ErrorMessage = ERROR_MESSAGE() ,
                    @ErrorSeverity = <func>ERROR_SEVERITY</func>() ,
                    @ErrorState = <func>ERROR_STATE</func>() ;

                    <com>-- Re-Raise the Error that caused the problem</com>
                    <cls>RAISERROR</cls> (@ErrorMessage, <com>-- Message text.</com>
                    @ErrorSeverity, <com>-- Severity.</com>
                    @ErrorState <com>-- State.</com>
                    ) ;
                    <cls>SET</cls> @retries = 0 ;
                <cls>END</cls>

            <cls>IF</cls> <func>XACT_STATE</func>() <> 0
                <cls>ROLLBACK TRANSACTION</cls> ;
        <cls>END CATCH</cls> ;
    <cls>END</cls> ;
<cls>GO</cls>
                </code></pre>
        </div>
        
        <p class="legenda"><strong>Listagem 7.16</strong>: Tratamento de exceções de deadlock com TRY...CATCH, em T-SQL</p>
        
        <h3 id="sqlexceptions">Tratando SqlExceptions do ADO.NET no código .NET</h3>

        <p>Embora seja possível lidar com deadlocks no SQL Server 2005 e 2008, usando blocos <code>BEGIN TRY</code> e <code>BEGIN CATCH</code>, a mesma funcionalidade não existe no SQL Server 2000, e, em qualquer caso, pode não ser aceitável que o mecanismo do banco de dados tente a operação novamente automaticamente. Em ambos os casos, a aplicação cliente deve ser codificada para lidar com a exceção de deadlock gerada pelo SQL Server.</p>

        <p>Não há muita diferença entre o tratamento de erros no .NET e no T-SQL. Um bloco <code>TRY...CATCH</code> é usado para executar a chamada SQL a partir da aplicação e capturar qualquer exceção resultante gerada pelo SQL Server. Se o código deve tentar a operação novamente no caso de um deadlock, um número máximo de tentativas deve ser definido por uma variável membro que é decrementada cada vez que um deadlock é encontrado.</p>

        <p>O exemplo na Listagem 7.17 mostra como capturar a SqlException em C#, mas pode ser usado como modelo para lidar com deadlocks em outras linguagens também.</p>

        <div id="container">
            <pre>
                <code>
int retries = 4;
while (retries > 0)
{
    try
    {
        // place sql code here
        retries = 0;
    }
    catch (SqlException exception)
    {
        // exception is a deadlock
        if (exception.Number == 1205)
        {
            // Delay processing to allow retry.
            Thread.Sleep(500);
            retries --;
        }
        // exception is not a deadlock
        else
        {
            throw;
        }
    }
}
                </code></pre>
        </div>
        
        <p class="legenda"><strong>Listagem 7.17</strong>: Tratamento de exceções de deadlock com <code>TRY...CATCH</code>, em C#</p>

        <p>Em vez de tentar a operação novamente, pode ser desejável registrar a exceção no Log de Eventos de Aplicativos do Windows ou, talvez, exibir uma caixa de diálogo <code>MessageBox</code> e determinar se deve ou não tentar a operação novamente, com base na entrada do usuário. Esses são dois exemplos de como o tratamento da exceção de deadlock no código da aplicação permite mais flexibilidade em comparação com o tratamento do deadlock no mecanismo do banco de dados.</p>

        <h2 id="deadlockbehavior">Controlando o Comportamento de Deadlocks com Prioridade de Deadlock</h2>

        <p>Existem circunstâncias (por exemplo, um relatório crítico que executa um <code>SELECT</code> de longa duração e deve ser concluído, mesmo que seja a vítima ideal de um deadlock) em que pode ser preferível especificar qual processo será escolhido como a vítima de deadlock no caso de um deadlock, em vez de deixar o SQL Server decidir com base puramente no custo de rollback. Conforme demonstrado na Listagem 7.18, o SQL Server oferece a capacidade de definir, no nível de sessão ou lote, uma prioridade de deadlock usando a opção <code>SET DEADLOCK PRIORITY</code>.</p>

        <div id="container">
            <pre>
                <code>
<com>-- Set a Low deadlock priority</com>
<cls>SET DEADLOCK_PRIORITY LOW</cls> ;
<cls>GO</cls>

<com>-- Set a High deadlock priority</com>
<cls>SET DEADLOCK_PRIORITY HIGH</cls> ;
<cls>GO</cls>

<com>-- Set a numeric deadlock priority</com>
<cls>SET DEADLOCK_PRIORITY</cls> 2 ;
                </code></pre>
        </div>
        
        <p class="legenda"><strong>Listagem 7.18</strong>: Definindo prioridade de deadlock</p>
        
        <p>Um processo em execução em um lote ou sessão com uma prioridade de deadlock baixa será escolhido como a vítima de deadlock em vez de um que esteja em execução com uma prioridade de deadlock mais alta. Como todas as outras opções <code>SET</code> no SQL Server, a <code>DEADLOCK PRIORITY</code> só está em vigor para o escopo de execução atual. Se for definida dentro de um procedimento armazenado, então, quando a execução do procedimento armazenado for concluída, a prioridade retorna à prioridade original do escopo de execução chamador.</p>

        <p>Observe que o SQL Server 2000 oferece apenas duas prioridades de deadlock: <code>Low</code> e <code>Normal</code>. Isso permite que a vítima seja determinada configurando sua prioridade como <code>Low</code>. No entanto, o SQL Server 2005 e 2008 têm três prioridades de deadlock nomeadas: <code>Low</code>, <code>Normal</code> e <code>High</code>, além de uma faixa numérica de -10 a +10, para ajustar com mais precisão a prioridade de deadlock de diferentes operações.</p>

        <p>A prioridade de deadlock é definida no momento da execução, e todos os usuários têm permissão para definir uma prioridade de deadlock. Isso pode ser um problema se os usuários tiverem acesso a consultas ad hoc no SQL Server e definirem suas prioridades de deadlock mais altas do que outros processos, a fim de evitar que seus próprios processos sejam escolhidos como vítimas.</p>

        <h2 id="summary">Resumo</h2>

        <p>Este capítulo abordou como capturar e interpretar informações de gráficos de deadlock no SQL Server para solucionar problemas de deadlocks. Os deadlocks mais comuns também foram abordados para fornecer uma base para solucionar outros tipos de deadlocks que possam ocorrer. Na maioria das vezes, os deadlocks são o resultado de um problema de design no banco de dados ou no código, que pode ser corrigido para evitar que o deadlock ocorra. No entanto, quando não é possível fazer mudanças no banco de dados para resolver o deadlock, adicionar o tratamento adequado de erros no código da aplicação reduz o impacto causado pela ocorrência de um deadlock. As informações incluídas neste capítulo devem permitir a solução rápida e eficiente da maioria dos deadlocks no SQL Server.</p>
    </main>

    <div id="topo">
        <a href="#" target="_self"><i class="material-symbols-outlined">stat_2</i></a>
    </div>

    <footer>
        <p>Criado por Agnaldo Mota</p>
    </footer>

    <script src="scripts/script.js"></script>
</body>
</html>
