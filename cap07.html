<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBA Acidental</title>
    <link rel="stylesheet" href="estilo/style.css">
    <link rel="stylesheet" href="estilo/media-queries.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
</head>

<body onresize="mudouTamanho()">
    <header>
        <h1>Troubleshooting SQL Server</h1>
        <h2>Um Guia para o DBA Acidental</h2>
    </header>

    <nav>
        <i id="burger" class="material-icons" onclick="clickMenu()">menu</i>
        <menu id="itens">
            <ul>
                <li><a href="index.html" target="_self"><i id="home" class="material-icons">home</i></a></li>
                <li><a href="abertura.html" target="_self">Abertura</a></li>
                <li><a href="introducao.html" target="_self">Introdução</a></li>
                <li><a href="cap01.html" target="_self">Cap.1</a></li>
                <li><a href="cap02.html" target="_self">Cap.2</a></li>
                <li><a href="cap03.html" target="_self">Cap.3</a></li>
                <li><a href="cap04.html" target="_self">Cap.4</a></li>
                <li><a href="cap05.html" target="_self">Cap.5</a></li>
                <li><a href="cap06.html" target="_self">Cap.6</a></li>
            </ul>
        </menu>
    </nav>

    <main>
        <h1>Capítulo 7: Lidando com Deadlocks</h1>

        <p>Um deadlock é definido no dicionário como "uma paralisação resultante da ação de forças iguais e opostas", e isso acaba sendo uma descrição razoável de um deadlock no SQL Server: duas ou mais sessões dentro do mecanismo do banco de dados acabam aguardando acesso a recursos bloqueados mantidos um pelo outro. Em uma situação de deadlock, nenhuma das sessões pode continuar a executar até que uma dessas sessões libere seus bloqueios, permitindo assim que a(s) outra(s) sessão(ões) acesse(m) o recurso bloqueado. Múltiplos processos bloqueando persistentemente uns aos outros, em um estado insolúvel, eventualmente resultarão em uma interrupção no processamento dentro do mecanismo do banco de dados.</p>

        <p>Um equívoco comum é que os DBAs precisam intervir para "matar" um dos processos envolvidos em um deadlock. Na verdade, o SQL Server é projetado para detectar e resolver deadlocks automaticamente, por meio do uso do <strong>Lock Monitor</strong>, um processo em segundo plano que é iniciado quando a instância do SQL Server é iniciada e que monitora constantemente o sistema em busca de sessões em deadlock. No entanto, quando os deadlocks são relatados, o DBA deve investigar sua causa imediatamente. Muitos dos mesmos problemas que causam bloqueios graves no banco de dados, como design de banco de dados inadequado, falta de indexação, consultas mal projetadas, nível de isolamento inadequado e assim por diante (todos discutidos no <a href="cap06.html" target="_self">Capítulo 6</a>), também são causas comuns de deadlocks. Este capítulo fornecerá as ferramentas, técnicas e ajustes necessários para diagnosticar e prevenir deadlocks, e garantir que eles sejam tratados com elegância, caso ocorram. Especificamente, ele abordará:</p>

        <ul>
            <li>como capturar gráficos de deadlock usando uma variedade de técnicas, incluindo Flags de Rastreamento, o evento de gráfico de deadlock do Profiler e notificações de eventos do service broker</li>
            <li>como ler gráficos de deadlock para localizar as sessões, consultas e recursos envolvidos</li>
            <li>tipos comuns de deadlock e como evitá-los</li>
            <li>usando tratamento de erro <code>TRY...CATCH</code> no servidor ou no cliente para deadlocks, para evitar erros <code>UnhandledException</code> na aplicação.</li>
        </ul>

        <h2 id="lockmonitor">Lock Monitor</h2>

        <p>Quando o Monitor de Bloqueio realiza uma busca por deadlock e detecta que uma ou mais sessões estão envolvidas em um deadlock, uma das sessões é selecionada como vítima do deadlock e sua transação atual é revertida. Quando isso ocorre, todos os bloqueios mantidos pela sessão da vítima são liberados, permitindo que qualquer outra sessão previamente bloqueada continue processando. Uma vez que a reversão é concluída, a sessão da vítima é terminada, retornando uma mensagem de erro 1205 para o cliente de origem.</p>

        <p>O SQL Server seleciona a vítima do deadlock com base nos seguintes critérios:</p>

        <ol>
            <li><strong>Prioridade de deadlock</strong> – a DEADLOCK_PRIORITY atribuída a uma determinada sessão determina a importância relativa de completar suas transações, caso essa sessão esteja envolvida em um deadlock. A sessão com a menor prioridade será sempre escolhida como a vítima do deadlock. A prioridade de deadlock é abordada em mais detalhes mais adiante neste capítulo.</li>
            <li><strong>Custo de reversão </strong>– se duas ou mais sessões envolvidas em um deadlock tiverem a mesma prioridade de deadlock, o SQL Server escolherá como vítima do deadlock a sessão que tiver o menor custo estimado de reversão.</li>
        </ol>

        <h2 id="capgraf">Capturando Gráficos de Deadlock</h2>

        <p>Quando erros 1205 são relatados, é importante que o DBA descubra por que o deadlock aconteceu e tome medidas para evitar sua recorrência. O primeiro passo para solucionar e resolver um problema de deadlock é capturar as informações do <strong>gráfico de deadlock</strong>.</p>

        <p>Um gráfico de deadlock é uma saída de informações sobre as sessões e recursos que estiveram envolvidos em um deadlock. Os meios pelos quais você pode capturar um gráfico de deadlock se diversificaram e melhoraram nas versões mais recentes do SQL Server. Se você ainda está usando o SQL Server 2000, então está limitado a um único, e um tanto limitado, Trace Flag (1204). O SQL Server 2005 adicionou um novo Trace Flag (1222), forneceu o evento <strong>Gráfico de Deadlock em XML</strong> no SQL Server Profiler e permitiu a captura de gráficos de deadlock via notificações de eventos do Service Broker e do Provedor WMI (Instrumentação de Gerenciamento do Windows) para Eventos do Servidor. Em cada caso, o gráfico de deadlock contém significativamente mais informações sobre a natureza do deadlock do que está disponível através do Trace Flag 1204. Isso minimiza a necessidade de reunir, manualmente, informações adicionais do SQL Server para entender por que o deadlock ocorreu; por exemplo, resolver o <code>pageid</code> dos bloqueios sendo mantidos para o <code>objectid</code> e <code>indexid</code>, usando <code>DBCC PAGE</code>, e usar SQL Trace para percorrer a cadeia de deadlock e descobrir quais declarações em execução estão causando o problema. O SQL Server 2008 fornece todas essas facilidades, além da sessão de Eventos Estendidos <code><strong>system_health</strong></code>.</p>

        <p>Para permitir que você trabalhe em cada seção e gere os mesmos gráficos de deadlock que são apresentados e descritos no texto, os materiais de recursos deste livro (<a href="http://www.simple-talk.com/RedGateBooks/JonathanKehayias/TroubleshootingSQLServer_Code.zip" target="_blank">http://www.simple-talk.com/RedGateBooks/JonathanKehayias/TroubleshootingSQLServer_Code.zip</a>) incluem código de exemplo para gerar um deadlock no SQL Server.</p>

        <h3 id="traceflag1204">Trace Flag 1204</h3>

        <p>Os Trace Flags no SQL Server permitem "caminhos de código" alternativos em pontos chave dentro do motor de banco de dados, permitindo que código adicional seja executado quando necessário. Se você estiver enfrentando falhas em consultas com erros de deadlock em uma instância do SQL Server, os Trace Flags podem ser ativados para uma única sessão ou para todas as sessões naquela instância. Quando o Trace Flag 1204 está habilitado para todas as sessões em uma instância do SQL Server, qualquer deadlock detectado pelo monitor de deadlock resultará na escrita de um gráfico de deadlock no log de erros do SQL Server.</p>

        <p>No SQL Server 2000, este Trace Flag é o único meio de capturar um gráfico de deadlock, o que torna a solução de problemas de deadlocking no SQL Server 2000 bastante desafiadora, embora ainda possível. Nas versões mais recentes do SQL Server, este Trace Flag ainda está disponível, embora tenha sido substituído pelo Trace Flag 1222.</p>

        <p>O Trace Flag 1204, assim como todos os Trace Flags, pode ser ativado e desativado de forma ad hoc usando os comandos <code>DBCC TRACEON</code> e <code>DBCC TRACEOFF</code> no console do banco de dados. A Listagem 7.1 mostra como habilitar o Trace Flag 1204 a curto prazo no nível do servidor (especificado pelo argumento -1), de modo que todas as declarações subsequentes sejam executadas com este Trace Flag habilitado.</p>
        <div id="container">
            <pre><code>
DBCC TRACEON(1204, -1)
            </code></pre>
        </div>

        <p class="legenda"><strong>Listagem 7.1:</strong> Habilitando o Trace Flag 1204 para todas as sessões.</p>
        
        <p>Alternativamente, os Trace Flags podem ser ativados automaticamente, utilizando o parâmetro de inicialização –T. Para adicionar um parâmetro de inicialização ao SQL Server, clique com o botão direito do mouse no nó do servidor no <strong>Enterprise Manager</strong> e abra a página de <strong>Propriedades do Servidor</strong>. Na aba <strong>Geral</strong>, clique no botão <strong>Parâmetros de Inicialização</strong> e, em seguida, adicione o parâmetro de inicialização ao servidor, conforme mostrado na Figura 7.1.</p>

        <img src="imagens/fig71.PNG" alt="Utilizando o parâmetro de inicialização –T." width="50%">

        <p class="legenda"><strong>Figura 7.1</strong>: Utilizando o parâmetro de inicialização –T.</p>

        <p>Nos casos em que é possível reiniciar uma instância, utilizar um parâmetro de inicialização pode ser útil quando se deseja capturar todos os deadlocks que ocorrem no servidor, ao longo de um longo período. No entanto, uma vez que a resolução de problemas de deadlock tenha sido concluída, o Trace Flag deve ser removido dos parâmetros de inicialização. Como o Trace Flag permite que a instância grave o gráfico de deadlock no log de erros do SQL Server, a única maneira de recuperar o gráfico é ler o arquivo de log de erros e, em seguida, extrair os eventos do arquivo de log para análise.</p>

        <h3 id="traceflag1222">Trace Flag 1222</h3>

        <p>O SQL Server 2005 adicionou o Trace Flag 1222 para capturar os gráficos de deadlock em um formato mais fácil de ler e mais abrangente do que o disponível com o flag 1204. Ele captura e apresenta as informações de uma maneira que torna muito mais fácil identificar a vítima do deadlock, assim como os recursos e processos envolvidos no deadlock (abordados em detalhes na seção <em>Leitura de Gráficos de Deadlock</em>).</p>

        <p>O Trace Flag 1204 ainda está disponível, por motivos de compatibilidade retroativa, mas ao usar Trace Flags para capturar gráficos de deadlock no SQL Server 2005 ou posterior, você deve sempre usar o Trace Flag 1222 em preferência ao Trace Flag 1204. O Trace Flag 1222 é habilitado da mesma maneira que o 1204, utilizando <code>DBCC TRACEON()</code>, como mostrado no Listagem 7.1 ou o parâmetro de inicialização –T, como mostrado na Figura 7.1.</p>

        <h3 id="deadlockxml">Evento de Gráfico de Deadlock XML no SQL Profiler</h3>

        <p>Novo no SQL Server 2005, o evento <code>Deadlock Graph</code> no SQL Trace captura as informações do gráfico de deadlock, sem escrevê-las no Log de Erros do SQL Server. O evento <code>Deadlock Graph</code> faz parte da categoria de eventos <strong>Locks</strong> e pode ser adicionado a um rastreamento do SQL Server Profiler selecionando o evento na caixa de diálogo <strong>Propriedades de Rastreamento</strong> do Profiler, como mostrado na Figura 7.2.</p>
        
        <img src="imagens/fig72.PNG" alt="Selecionando o evento Deadlock Graph na caixa de diálogo Propriedades de Rastreamento.">

        <p class="legenda"><strong>Figura 7.2</strong>: Selecionando o evento <code>Deadlock Graph</code> na caixa de diálogo Propriedades de Rastreamento.</p>

        <p>SQL Profiler can be configured to save the deadlock graphs separately, into XDL files, as shown in Figure 7.3.</p>

        <img src="imagens/fig73.PNG" alt="Salvando gráficos de deadlock">

        <p class="legenda"><strong>Figura 7.3</strong>: Salvando gráficos de deadlock.</p>

        <p>Um arquivo XDL é um arquivo XML padrão. O Management Studio reconhece a extensão do arquivo ao abri-lo e exibe as informações de deadlock graficamente, em vez de como XML.</p>

        <p>Se você preferir trabalhar diretamente com traces no servidor, eliminando a sobrecarga do cliente Profiler, pode capturar as informações do gráfico de deadlock diretamente dos seus scripts, utilizando o conjunto de procedimentos armazenados do sistema <code><strong>SP_TRACE_*</strong></code>. Os gráficos capturados serão gravados em um arquivo de rastreamento SQL no SQL Server. A maneira mais fácil de gerar um script para um trace no servidor é primeiro criar o trace no SQL Profiler e, em seguida, exportá-lo para um script usando <strong>Arquivo</strong> | <strong>Exportar</strong> | <strong>Exportar Definição de Trace</strong>, conforme descrito em detalhes no <a href="cap05.html#worload" target="_self">Capítulo 5</a>.</p>

        <p>Um arquivo de trace no servidor pode ser lido usando a função de sistema <code>fn_trace_gettable</code> ou abrindo-o no SQL Profiler. Ao usar o SQL Profiler para visualizar o conteúdo do arquivo de trace, os eventos de deadlock podem ser exportados para arquivos XDL individuais, que podem ser abertos graficamente usando o SQL Server Management Studio, através do menu <strong>Arquivo</strong> | <strong>Exportar</strong> | <strong>Extrair Eventos do SQL Server</strong> | <strong>Extrair Eventos de Deadlock</strong>.</p>

        <h3 id="servicebroker">Notificações de eventos do Service Broker</h3>

        <p>Também novo no SQL Server 2005, as notificações de eventos permitem capturar informações de gráficos de deadlock usando o SQL Server Service Broker, criando um <strong>serviço</strong> e uma <strong>fila</strong> para o evento de rastreamento <code>DEADLOCK_GRAPH</code>. As informações contidas no gráfico de deadlock capturado por notificações de eventos não diferem das informações contidas no gráfico de deadlock capturado pelo SQL Trace; a única diferença é o mecanismo de captura.</p>

        <p>Configurar uma notificação de evento para capturar informações de gráficos de deadlock requer três objetos do Service Broker:</p>

        <ul>
            <li>Uma <code><strong>FILA</strong></code> para armazenar as mensagens do evento <code>DEADLOCK_GRAPH</code></li>
            <li>Um <code><strong>SERVIÇO</strong></code> para encaminhar as mensagens para a fila</li>
            <li>Uma <code><strong>NOTIFICAÇÃO DE EVENTO</strong></code> para capturar o gráfico de deadlock e empacotá-lo em uma mensagem que é enviada para o Serviço.</li>
        </ul>

        <p>A Listagem 7.2 mostra como criar esses objetos usando T-SQL. Observe que é necessário criar os objetos em um banco de dados com suporte ao broker, como o <code><strong>msdb</strong></code>. O banco de dados <code><strong>master</strong></code> não tem o broker habilitado por padrão.</p>
        
        <div id="container">
            <pre><code>
<cls>USE</cls> msdb;

<com>-- Create a service broker queue to hold the events</com>
<cls>CREATE QUEUE</cls> DeadlockQueue
<cls>GO</cls>

<com>-- Create a service broker service receive the events</com>
<cls>CREATE SERVICE</cls> DeadlockService
<cls>ON QUEUE</cls> DeadlockQueue ([http://schemas.microsoft.com/SQL/Notifications/
PostEventNotification])
<cls>GO</cls>

<com>-- Create the event notification for deadlock graphs on the service</com>
<cls>CREATE EVENT NOTIFICATION</cls> CaptureDeadlocks
<cls>ON SERVER</cls>
<cls>WITH</cls> FAN_IN
<cls>FOR</cls> DEADLOCK_GRAPH
<cls>TO SERVICE</cls> <string>'DeadlockService'</string>, <string>'current database'</string> ;
<cls>GO</cls>
            </code></pre>
        </div>
        
        <p class="legenda"><strong>Listagem 7.2</strong>: Criando os objetos de serviço, fila e notificação de evento do Service Broker.</p>

        <p>Com os objetos criados, os gráficos de deadlock serão coletados na fila à medida que os deadlocks ocorrerem no servidor. Embora a fila possa ser consultada usando uma instrução <code>SELECT</code>, como se fosse uma tabela, o conteúdo permanece na fila até que seja processado usando o comando <code>RECEIVE</code>, conforme demonstrado na Listagem 7.3.</p>

        <div id="container">
            <pre><code>

<cls>USE</cls> msdb ;

<com>-- Cast message_body to XML and query deadlock graph from TextData</com>
<cls>SELECT</cls> message_body.valuequery(<string>'(/EVENT_INSTANCE/TextData/</string>
                                 <string>deadlock-list)[1]', 'varchar(128)'</string>)
                                 <cls>AS</cls> DeadlockGraph
<cls>FROM</cls> ( <cls>SELECT</cls> CAST(message_body <cls>AS</cls> <cls>XML</cls>) <cls>AS</cls> message_body
       <cls>FROM</cls> DeadlockQueue
     ) <cls>AS</cls> sub ;
<cls>GO</cls>

<com>-- Receive the next available message FROM the queue</com>
DECLARE @message_body <cls>XML</cls> ;

<cls>RECEIVE TOP</cls>(1) -- just handle one message at a time
@message_body=message_body
<cls>FROM</cls> DeadlockQueue ;

<com>-- Query deadlock graph from TextData</com>
<cls>SELECT</cls> @message_body.valuequery(<string>'(/EVENT_INSTANCE/TextData/</string>
                                  <string>deadlock-list)[1]','varchar(128)'</string>)
                                  <cls>AS</cls> DeadlockGraph
<cls>GO</cls>
            </code></pre>
        </div>
        
        <p class="legenda">Listing 7.3: Query and processing DEADLOCK_GRAPH event messages in the queue.</p>
        
        <p>Como as Notificações de Eventos utilizam uma fila do service broker para processamento, ações adicionais podem ser realizadas quando o evento de deadlock é disparado. Quando ocorre um evento de deadlock, o Service Broker pode "ativar" uma procedure armazenada que processa a mensagem e responde adequadamente, por exemplo, enviando uma notificação por email usando Database Mail, registrando o evento em uma tabela ou coletando informações adicionais, como os planos de execução de ambas as instruções, a partir do SQL Server, com base nas informações contidas dentro do gráfico de deadlock. A cobertura completa desse tópico está além do escopo deste capítulo. No entanto, um exemplo completo de como usar a ativação de fila para automatizar completamente a coleta de deadlocks pode ser encontrado no arquivo de download do código deste livro.</p>

        <h3 id="wmiprovider">Provedor WMI para eventos de servidor</h3>

        <p>Também novo no SQL Server 2005, o Provedor WMI para Eventos de Servidor permite que o WMI seja usado para monitorar eventos do SQL Server à medida que ocorrem. Qualquer evento que possa ser capturado através de notificações de eventos tem um <strong>Objeto de Evento WMI</strong> correspondente, e qualquer aplicativo de gerenciamento WMI pode se inscrever nesses objetos de evento.</p>

        <p>O SQL Server Agent foi atualizado para gerenciar eventos WMI, através do uso da WMI Query Language (WQL), uma linguagem de consulta semelhante ao T-SQL que é usada com WMI e Alertas do Agent para eventos WMI.</p>

        <p>Um exemplo completo de como criar um alerta do SQL Agent para capturar e armazenar gráficos de deadlock está fora do escopo deste capítulo e pode ser encontrado no exemplo do Books Online, <em>Criando um Alerta do SQL Server Agent Usando o Provedor WMI para Eventos de Servidor</em> (<a href="http://msdn.microsoft.com/en-us/library/ms186385.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/ms186385.aspx</a>). No entanto, essencialmente, isso envolve a criação, via o Provedor de Eventos WMI, de um alerta do SQL Agent para monitorar eventos de gráfico de deadlock. O alerta consulta eventos usando WQL e, quando recebe a notificação de que um ocorreu, dispara um job que captura o gráfico de deadlock em uma tabela designada do SQL Server.</p>

        <p>Para capturar gráficos de deadlock usando o Provedor de Eventos WMI e um alerta do SQL Agent dessa maneira, é necessário que a opção "Substituir tokens para todas as respostas de jobs a alertas" nas propriedades do Sistema de Alertas do SQL Server Agent esteja habilitada. Também é necessário que o Service Broker (que processa as mensagens de notificação) esteja habilitado no msdb, bem como no banco de dados em que os gráficos de deadlock são armazenados.</p>

        <div class="dica">
            <p class="destaque">WMI event provider bug</p>
            <p>It is worth noting that there is a known bug in the WMI Event Provider for server names that exceed fourteen characters; this was fixed in Cumulative Update 5 for SQL Server 2005 Service Pack 2.</p>
        </div>

        <h3 id="extendevents">Eventos Estendidos</h3>

        <p>Antes do SQL Server 2008, não havia como encontrar informações sobre deadlocks retroativamente. Obter gráficos de deadlock exigia que um SQL Trace estivesse ativamente em execução, ou que as Trace Flags 1222 ou 1205 estivessem ativadas para a instância. Como rastrear deadlocks por qualquer um desses métodos pode ser intensivo em recursos, isso geralmente significava que uma série de deadlocks precisava ocorrer para motivar o início de um trace ou a ativação das Trace Flags.</p>
        
        <p>O SQL Server 2008 inclui todas as técnicas discutidas anteriormente para capturar gráficos de deadlock e adiciona uma nova, que é a coleta de informações de deadlock através da sessão de eventos padrão <code>system_health</code> em Eventos Estendidos. Esta sessão de eventos padrão (semelhante, em conceito, ao trace padrão) é executada por padrão em todas as instalações do SQL Server 2008 e coleta uma gama de informações úteis para solução de problemas de erros que ocorrem no SQL Server, incluindo deadlocks. Os gráficos de deadlock capturados por Eventos Estendidos no SQL Server 2008 têm a capacidade única de conter informações sobre deadlocks com múltiplas vítimas (deadlocks onde mais de uma sessão foi finalizada pelo Lock Monitor para resolver o conflito).</p>

        <div class="dica">
            <p class="destaque">Mais sobre Eventos Estendidos</p>
            <p>Não podemos cobrir Eventos Estendidos em detalhes neste livro, mas, para uma boa visão geral do tópico, leia o artigo de Paul Randal, "SQL 2008: Advanced Troubleshooting with Extended Events".(<a href="http://technet.microsoft.com/en-us/magazine/2009.01.sql2008.aspx" target="_blank">http://technet.microsoft.com/en-us/magazine/2009.01.sql2008.aspx</a>).</p>
        </div>

        <p>A sessão <code>system_health</code> usa um alvo <code>ring_buffer</code>, que armazena as informações coletadas pelos eventos disparados na memória como um documento XML na DMV <code>sys.dm_xe_session_targets</code>. Esta DMV pode ser juntada à DMV <code>sys.dm_xe_sessions</code> para obter as informações da sessão juntamente com os dados armazenados no alvo <code>ring_buffer</code>, conforme mostrado na Listagem 7.4.</p>

        <div id="container">
            <pre>
                <code>
<cls>SELECT</cls> <func>CAST</func>(target_data <cls>AS XML</cls>) <cls>AS</cls> TargetData
<cls>FROM</cls> <com>sys.dm_xe_session_targets</com> st
JOIN <com>sys.dm_xe_sessions</com> s <cls>ON</cls> s.<cls>address</cls> = st.event_session_address
<cls>WHERE</cls> name = <string>'system_health'</string>
            </code></pre>
        </div>
        
        <p class="legenda"><strong>Listagem 7.4</strong>: Recuperando informações da sessão <code>system_health</code>.</p>
        
        <p>A consulta no Listagem 7.5 mostra como recuperar um gráfico de deadlock XML válido da sessão padrão <code>system_health</code> usando XQuery, a coluna <code>target_data</code> e um <code>CROSS APPLY</code> para obter os nós individuais do evento. Observe que, devido às mudanças no gráfico de deadlock para suportar deadlocks com múltiplas vítimas e para minimizar o tamanho dos dados do evento, o XML resultante não pode ser salvo como um arquivo XDL para representação gráfica.</p>

        <div id="container">
            <pre><code>
<cls>SELECT</cls> <func>CAST</func>(event_data.value(<string>'(event/data/value)[1]'</string>,
                              <string>'varchar(max)'</string>) <cls>AS XML</cls>) <cls>AS</cls> DeadlockGraph
<cls>FROM</cls>   ( <cls>SELECT</cls>    XEvent.query(<string>'.'</string>) <cls>AS</cls> event_data
         <cls>FROM</cls>      (    <com>-- Cast the target_data to XML</com>
                     <cls>SELECT</cls>    <func>CAST</func>(target_data <cls>AS XML</cls>) <cls>AS</cls> TargetData
                     <cls>FROM</cls>      <com>sys.dm_xe_session_targets</com> st
                               <join>JOIN</join> <com>sys.dm_xe_sessions</com> s
                                <cls>ON</cls> s.<cls>address</cls> = st.event_session_address
                     <cls>WHERE</cls>     name = <string>'system_health'</string>
                               <join>AND</join> target_name = <string>'ring_buffer'</string>
                   ) <cls>AS</cls> Data <com>-- Split out the Event Nodes</com>
                   <join>CROSS APPLY</join> TargetData.nodes(<string>'RingBufferTarget/</string>
                                    <string>event[@name="xml_deadlock_report"]'</string>)
                   <cls>AS</cls> XEventData ( XEvent )
       ) <cls>AS</cls> tab ( event_data )
                </code></pre>
        </div>
        
        <p class="legenda"><strong>Listagem 7.5</strong>: Recuperando um gráfico de deadlock XML.</p>
        
        <p>Observe também que há um bug na versão RTM do SQL Server 2008 que faz com que os gráficos de deadlock não sejam capturados e retidos em uma sessão de Extended Events. Esse bug foi corrigido na Atualização Cumulativa 1 para o SQL Server 2008 e também está incluído no último Service Pack. Existe um bug adicional relacionado ao XML malformado no gráfico de deadlock gerado por Extended Events, que foi corrigido no Pacote de Atualização Cumulativa 6 para o SQL Server 2008 Service Pack 1. Ainda é possível gerar um documento XML válido nessas versões anteriores, manipulando o gráfico de deadlock sendo gerado por Extended Events. No entanto, como a correção para o SQL Server já foi lançada, os detalhes da solução alternativa não serão abordados neste capítulo.</p>
        
        <div class="dica">
            <p class="destaque">Mudanças no Extended Events no SQL Server Denali</p>
            <p>No momento das edições finais deste capítulo, o SQL Server Denali CTP3 foi lançado, com mudanças relacionadas a como os alvos do Extended Events armazenam dados XML dentro do elemento value na saída XML do Evento. A Listagem 7.5 mostra o uso do método .value() do XML no SQL Server, mas no Denali CTP3, o método .query() deve ser usado para recuperar o gráfico de deadlock da saída XML do Evento.</p>
        </div>

        <h2 id="deadlockgraphs">Lendo Gráficos de Deadlock</h2>
        
        <p>O formato exato do gráfico de deadlock no SQL Server mudou de versão para versão, e principalmente para melhor. Em geral, ele agora contém informações mais detalhadas em um formato mais fácil de entender, como a exibição gráfica fornecida no SQL Server Management Studio e no SQL Profiler, permitindo que possamos resolver deadlocks com mais facilidade.</p>

        <p>Mesmo com as mudanças no XML do gráfico de deadlock gerado pelo Extended Events no SQL Server 2008, os fundamentos de como interpretar o gráfico são os mesmos que para qualquer outro gráfico de deadlock em XML.</p>

        <h3 id="traceflag_1204">Interpretando Gráficos de Deadlock do Trace Flag 1204</h3>

        <p>Talvez um dos aspectos mais difíceis de solucionar deadlocks no SQL Server 2000 seja interpretar a saída do Trace Flag 1204. O processo é complicado pela necessidade de consultar as tabelas de sistema <code>sysobjects</code> e <code>sysindexes</code> para descobrir exatamente quais objetos estão envolvidos no deadlock.</p>

        <p>A Listagem 7.6 mostra um exemplo de gráfico de deadlock gerado ao habilitar o Trace Flag 1204 e, em seguida, criar uma situação de deadlock (o código para fazer isso está disponível como parte do download de código deste livro).</p>
        
        <div id="container">
            <pre>
                <code>
Deadlock encountered .... Printing deadlock information

Wait-for graph

Node:1
<CLS>KEY:</CLS> 13:1993058136:2 (08009d1c9ab1) <CLS>CleanCnt:</CLS>2 <CLS>Mode:</CLS> S <CLS>Flags:</CLS> 0x0
 Grant List 0::
   <CLS>
       <CLS>Owner:</CLS>0x567e7660 <CLS>Mode:</CLS> S <CLS>Flg:</CLS>0x0 <CLS>Ref:</CLS>1 <CLS>Life:</CLS>00000000 <CLS>SPID:</CLS>54 <CLS>ECID:</CLS>0
   </CLS>
   <CLS>SPID:</CLS> 54 <CLS>ECID:</CLS> 0 <CLS>Statement Type:</CLS> SELECT <CLS>Line #:</CLS> 3
   <CLS>Input Buf:</CLS> Language <cls>Event:</cls> WHILE (1=1)
BEGIN
    INSERT INTO #t1 EXEC BookmarkLookupSelect 4
    TRUNCATE TABLE #t1
END

 Requested By:
   <cls>ResType:</cls>LockOwner <cls>Stype:</cls>'OR' <cls>Mode:</cls> X <cls>SPID:</cls>55 <cls>ECID:</cls>0 <cls>Ec:</cls>(0x26F7DBD8)
<cls>Value:</cls>0x58f80880 <cls>Cost:</cls>(0/3C)

Node:2
<CLS>KEY:</CLS> 13:1993058136:1 (040022ae5dcc) <CLS>CleanCnt:</CLS>2 <CLS>Mode:</CLS> X <CLS>Flags:</CLS> 0x0
 Grant List 1::
   <CLS>Owner:</CLS>0x58f80940 <CLS>Mode:</CLS> X <CLS>Flg:</CLS>0x0 <CLS>Ref:</CLS>0 <CLS>Life:</CLS>02000000 <CLS>SPID:</CLS>55 <CLS>ECID:</CLS>0
   <CLS>SPID:</CLS> 55 <CLS>ECID:</CLS> 0 <CLS>Statement Type:</CLS> UPDATE <CLS>Line #:</CLS> 4
   <CLS>Input Buf:</CLS> Language <CLS>Event:</CLS> SET NOCOUNT ON
WHILE (1=1)
BEGIN
    EXEC BookmarkLookupUpdate 4
END

 Requested By:
   <cls>ResType:</cls>LockOwner <cls>Stype:</cls>'OR' <cls>Mode:</cls> S <cls>SPID:</cls>54 <cls>ECID:</cls>0 <cls>Ec:</cls>(0x2F881BD8)
<cls>Value:</cls>0x567e76c0 <cls>Cost:</cls>(0/0)

Victim Resource Owner:
 <cls>ResType:</cls>LockOwner <cls>Stype:</cls>'OR' <cls>Mode:</cls> S <cls>SPID:</cls>54 <cls>ECID:</cls>0 <cls>Ec:</cls>(0x2F881BD8)
<cls>Value:</cls>0x567e76c0 <cls>Cost:</cls>(0/0)
                </code></pre>
        </div>
        
        <p class="legenda"><strong>Listagem 7.6</strong>: Exemplo de gráfico de deadlock do Trace Flag 1204, envolvendo bloqueios KEY.</p>
        
        <p>A primeira coisa a se observar na saída do gráfico é que há dois <strong>nós</strong>, cada um representando um recurso bloqueado. A primeira linha de saída para cada nó mostra o recurso sobre o qual o bloqueio está mantido, e então a seção <strong>Grant List</strong> fornece detalhes da situação de deadlock, incluindo:</p>

        <ul>
            <li>Modo do bloqueio sendo mantido no recurso;</li>
            <li>SPID do processo associado;</li>
            <li>Tipo de instrução que o SPID está executando atualmente;</li>
            <li>Número da linha (line number) que marca o início da instrução atualmente em execução;</li>
            <li>Input Buf, o conteúdo do buffer de entrada para esse SPID (a última instrução enviada).</li>
        </ul>
        
        <p>Então, para o Nó 1, podemos ver que um bloqueio de leitura compartilhada (<code>S</code>) está sendo mantido pelo <code>SPID 54</code> em uma chave de índice de um índice não-clustered (<code>:2</code>) em um objeto com ID <code>1993058136</code>. O Nó 2 mostra que um bloqueio exclusivo (<code>X</code>) está sendo mantido pelo <code>SPID 55</code> em uma chave de índice do índice clustered (<code>:1</code>) do mesmo objeto.</p>
        
        <p>Mais adiante, para cada nó, está a seção <strong>Requested By</strong>, que detalha quaisquer solicitações de recursos que não podem ser concedidas devido ao bloqueio. Para o Nó 1, podemos ver que o <code>SPID 55</code> está aguardando um bloqueio exclusivo na chave do índice não-clustered (ele está bloqueado pelo bloqueio <code>S</code> mantido pelo <code>SPID 54</code>). Para o Nó 2, podemos ver que o <code>SPID 54</code> está aguardando adquirir um bloqueio de leitura compartilhada na chave do índice clustered (ele está bloqueado pelo bloqueio exclusivo mantido pelo <code>SPID 55</code>).</p>
        
        <p>Além disso, na seção <strong>Grant List</strong>, podemos ver que o <code>SPID 54</code> emitiu a instrução <code>SELECT</code> na Linha # 3 da stored procedure <code>BookmarkLookupSelect</code> (mas não consegue adquirir um bloqueio de leitura compartilhada) e o <code>SPID 55</code> emitiu a instrução <code>UPDATE</code> na Linha # 4 da stored procedure <code>BookmarkLookupUpdate</code> (mas não consegue adquirir um bloqueio exclusivo).</p>
        
        <p>Esta é uma situação clássica de deadlock, e é um dos tipos mais comuns de deadlock, abordado com mais detalhes posteriormente neste capítulo, na seção intitulada <a href="#" target="_self">Deadlock de busca de bookmark</a>.</p>
        
        <p>Finalmente, na seção <strong>Victim Resource Owner</strong>, podemos descobrir qual <code>SPID</code> foi escolhido como a vítima do deadlock, neste caso, o <code>SPID 54</code>. Alternativamente, podemos identificar a vítima do deadlock combinando as informações binárias no <code>Value</code> com as informações binárias na parte <code>Owner</code> da Grant List.</p>
        
        <p>Discutimos muito sobre o incidente de deadlock, mas até agora sabemos apenas que ocorreu em um objeto com ID <code>1993058136</code>. Para identificar corretamente os objetos envolvidos no deadlock, as informações na entrada <code>KEY</code> de cada nó precisam ser usadas para consultar <code>sysobjects</code> e <code>sysindexes</code>. A entrada <code>KEY</code> é formatada como <code>databaseid:objectid:indexid</code>. Então, neste exemplo, o <code>SPID 54</code> estava mantendo um bloqueio Shared (<code>S</code>) no <code>índice id 2</code>, um índice não-clustered, com objectID <code>1993058136</code>. A consulta na Listagem 7.7 mostra como determinar os nomes da tabela e do índice associados ao deadlock.</p>
        
        <div id="container">
            <pre>
                <code>
<cls>SELECT</cls>  o.name <cls>AS</cls> TableName ,
        i.name <cls>AS</cls> IndexName
<cls>FROM</cls>    <com>sysobjects</com> <cls>AS</cls> o
        <join>JOIN</join> <com>sysindexes</com> <cls>AS</cls> i <cls>ON</cls> o.id = i.id
<cls>WHERE</cls>   o.id = 1993058136
        <join>AND</join> i.indid <join>IN</join> ( 1, 2 )
                </code></pre>
        </div>
        
        <p>Listing 7.7: Finding the names of the objects associated with the deadlock.</p>
        
        <p>If a deadlock involves a PAG lock instead of a KEY lock, the deadlock graph might look as shown in Listing 7.8.</p>
        
        <div>
            <pre>
                <code>
                    Wait-for graph
                    Node:1
                    PAG: 8:1:96 CleanCnt:2 Mode: X Flags: 0x2
                    Grant List 0::
                    Owner:0x195fb2e0 Mode: X Flg:0x0 Ref:1 Life:02000000
                    SPID: 56 ECID: 0 Statement Type: UPDATE Line #: 4
                    Input Buf: Language Event: SET NOCOUNT ON
                    WHILE (1=1)
                    BEGIN253
                    Chapter 7: Handling Deadlocks
                    EXEC BookmarkLookupUpdate 4
                    END
                    Requested By:
                    ResType:LockOwner Stype:'OR' Mode: S SPID:55 ECID:0 Ec:(0x1A5E1560)
                    Value:0x1960dba0 Cost:(0/0)
                </code>
            </pre>
        </div>
        
        <p>Listing 7.8: Page lock example, generated by Trace Flag 1204.</p>
        
        <p>Notice now that the lock reference is of the form databaseid:fileid:pageid. In order to identify the object to which this page belongs, we need to enable Trace Flag 3604, dump the page header information to the client message box DBCC PAGE(), and then disable the Trace Flag, as shown in Listing 7.9.</p>
        
        <div>
            <pre>
                <code>
                    DBCC TRACEON(3604)
                    DBCC PAGE(8,1,96,1)
                    DBCC TRACEOFF(3604)
                </code>
            </pre>
        </div>
        
        <p>Listing 7.9: Identifying the objects involved in a deadlock involving page locks.</p>
        
        The output of the DBCC PAGE() command will include a PAGE HEADER section, shown in Listing 7.10, which contains the IDs of the object (m_objId field) and index (m_indexId) to which the page belongs.
        
        <div>
            <pre>
                <code>
                    Page @0x1A5EC000
                    ----------------
                    m_pageId = (1:96) m_headerVersion = 1 m_type = 1
                    m_typeFlagBits = 0x0 m_level = 0 m_flagBits = 0x4
                    m_objId = 1977058079 m_indexId = 0 m_prevPage = (0:0)
                    m_nextPage = (1:98) pminlen = 116 m_slotCnt = 66
                    m_freeCnt = 110 m_freeData = 7950 m_reservedCnt = 0
                    m_lsn = (912:41:3) m_xactReserved = 0 m_xdesId = (0:0)
                    m_ghostRecCnt = 0 m_tornBits = 2
                </code>
            </pre>
        </div>
        
        <p>Listing 7.10: Page Header section from the output of the DBCC PAGE().</p>
        
        <p>Understanding the statements that are being executed along with the indexes and objects involved in the deadlock is critical to troubleshooting the problem. However, there are situations where the currently executing statement may not be the actual statement that caused the deadlock. Multi-statement stored procedures and batches that enlist an explicit transaction will hold all of the locks acquired under the transaction scope until the transaction is either committed or rolled back. In this situation, the deadlock may involve locks that were acquired by a previous statement that was executed inside the same transaction block. To completely troubleshoot the deadlock it is necessary to look at the executing batch from the Input Buf as a whole, and understand when locks are being acquired and released.</p>

        <p>Bart Duncan is the definitive source for interpreting SQL Server deadlock graphs. For additional information on reading the output of Trace Flag 1204, see his blog post Interpreting Trace Flag 1204 Output (http://blogs.msdn.com/b/bartd/archive/2006/09/09/deadlock-troubleshooting_2c00_-part-1.aspx).</p>

        <p>Interpreting Trace Flag 1222 deadlock graphs</p>

        <p>The format of the information, as well as the amount of information, returned by Trace Flag 1222 is very different than the output from Trace Flag 1204. Listing 7.11 shows the Trace Flag 1222 output, in SQL Server 2005, for an identical deadlock to the one previously seen for the Trace Flag 1204 output, from SQL Server 2000.</p>

        <div>
            <pre>
                <code>
                    deadlock-list
                    deadlock victim=process8d8c58
                    process-list
                    process id=process84b108 taskpriority=0 logused=220 waitresource=KEY:
                    34:72057594038452224 (0c006459e83f) waittime=5000 ownerId=899067977
                    transactionname=UPDATE lasttranstarted=2009-12-13T00:22:46.357 XDES=0x157be250
                    lockMode=X schedulerid=1 kpid=4340 status=suspended spid=102 sbid=0
                    ecid=0 priority=0 transcount=2 lastbatchstarted=2009-12-13T00:13:37.510
                    lastbatchcompleted=2009-12-13T00:13:37.507 clientapp=Microsoft SQL Server
                    Management Studio - Query hostname=SQL2K5TEST hostpid=5516 loginname=sa
                    isolationlevel=read committed (2) xactid=899067977 currentdb=34
                    lockTimeout=4294967295 clientoption1=673187936 clientoption2=390200
                    executionStack
                    frame procname=DeadlockDemo.dbo.BookmarkLookupUpdate line=4 stmtstart=260
                    stmtend=394 sqlhandle=0x03002200e7a4787d08a10300de9c00000100000000000000
                    UPDATE BookmarkLookupDeadlock SET col2 = col2-1 WHERE col1 = @col2
                    frame procname=adhoc line=4 stmtstart=82 stmtend=138 sqlhandle=0x020000002a709
                    3322fbd674049d04f1dc0f3257646c4514b
                    EXEC BookmarkLookupUpdate 4
                    inputbuf
                    SET NOCOUNT ON
                    WHILE (1=1)
                    BEGIN
                    EXEC BookmarkLookupUpdate 4
                    END
                    process id=process8d8c58 taskpriority=0 logused=0 waitresource=KEY:
                    34:72057594038386688 (0500b49e5abb) waittime=5000 ownerId=899067972
                    transactionname=INSERT EXEC lasttranstarted=2009-12-13T00:22:46.357
                    XDES=0x2aebba08 lockMode=S schedulerid=2 kpid=5864 status=suspended
                    spid=61 sbid=0 ecid=0 priority=0 transcount=1 lastbatchstarted=2009-12-
                    13T00:22:46.347 lastbatchcompleted=2009-12-13T00:22:46.343 clientapp=Microsoft
                    SQL Server Management Studio - Query hostname=SQL2K5TEST hostpid=5516
                    loginname=sa isolationlevel=read committed (2) xactid=899067972 currentdb=34
                    lockTimeout=4294967295 clientoption1=673187936 clientoption2=390200
                    executionStack
                    frame procname=DeadlockDemo.dbo.BookmarkLookupSelect line=3 stmtstart=118
                    stmtend=284 sqlhandle=0x03002200ae80847c07a10300de9c00000100000000000000
                    SELECT col2, col3 FROM BookmarkLookupDeadlock WHERE col2 BETWEEN @col2 AND @col2+1
                    frame procname=adhoc line=3 stmtstart=50 stmtend=146 sqlhandle=0x02000000e00b6
                    6366c680fabe2322acbad592a896dcab9cb
                    INSERT INTO #t1 EXEC BookmarkLookupSelect 4
                    inputbuf
                    WHILE (1=1)
                    BEGIN
                    INSERT INTO #t1 EXEC BookmarkLookupSelect 4
                    TRUNCATE TABLE #t1
                    END
                    resource-list
                    keylock hobtid=72057594038386688 dbid=34 objectname=DeadlockDemo.dbo.
                    BookmarkLookupDeadlock indexname=cidx_BookmarkLookupDeadlock id=lock137d65c0 mode=X
                    associatedObjectId=72057594038386688
                    owner-list
                    owner id=process84b108 mode=X
                    waiter-list
                    waiter id=process8d8c58 mode=S requestType=wait
                    keylock hobtid=72057594038452224 dbid=34 objectname=DeadlockDemo.dbo.
                    BookmarkLookupDeadlock indexname=idx_BookmarkLookupDeadlock_col2 id=lock320d5900
                    mode=S associatedObjectId=72057594038452224
                    owner-list
                    owner id=process8d8c58 mode=S
                    waiter-list
                    waiter id=process84b108 mode=X requestType=wait
                </code>
            </pre>
        </div>
        
        <p>Listing 7.11: Sample deadlock graph, generated by Trace Flag 1222.</p>
        
        <p>The new format breaks a deadlock down into sections that define the deadlock victim, the processes involved in the deadlock (process-list), and the resources involved in the deadlock (resource-list). Each process has an assigned process id that is used to uniquely identify it in the deadlock graph. The deadlock victim lists the process that was selected as the victim and killed by the deadlock monitor. Each process includes the SPID as well as the hostname and loginname that originated the request, and the isolation level under which the session was running when the deadlock occurred. The execution stack section, for each process, displays the entire execution stack, starting from the most recently executed (deadlocked) statement backwards to the start of the call stack. This eliminates the need to perform additional steps to identify the statement being executed.</p>

        <p>The resource-list contains all of the information about the resources involved in the deadlock and is generally the starting point for reading a deadlock graph. The index names are included in the output and each resource displays the owner process and the type of locks being held, as well as the waiting process and the type of locks being requested.</p>

        <p>As with the Trace Flag 1204 output, the definitive source for understanding the output from Trace Flag 1222 is Bart Duncan. He has a three-part series on troubleshooting deadlocks with the output from Trace Flag 1222 on his blog, starting with Deadlock Troubleshooting, Part 1 (http://blogs.msdn.com/bartd/archive/2006/09/09/747119.aspx).</p>

        <p>Using the same technique employed in these posts, we can construct a description of the deadlock described, as shown in Listing 7.12.</p>

        <div>
            <pre>
                <code>
                    SPID 102 (process84b108) is running this query (line 4 of the BookmarkLookupUpdate
                    sproc):
                    UPDATE BookmarkLookupDeadlock SET col2 = col2-1 WHERE col1 = @col2
                    SPID 61 (process8d8c58 )is running this query (line 3 of BookmarkLookupSelect
                    sproc):
                    SELECT col2, col3 FROM BookmarkLookupDeadlock WHERE col2
                    BETWEEN @col2 AND @col2+1
                    SPID 102 is waiting for an Exclusive KEY lock on the idx_BookmarkLookupDeadlock_
                    col2 index (on the BookmarkLookupDeadlock table).
                    (SPID 61 holds a conflicting S lock)
                    SPID 61 is waiting for a Shared KEY lock on the index cidx_BookmarkLookupDeadlock
                    (on the BookmarkLookupDeadlock table)..
                    (SPID 102 holds a conflicting X lock)
                </code>
            </pre>
        </div>

        <p>Listing 7.12: Deadlock analysis, constructed from the Trace Flag 1222 deadlock graph.</p>

        <p>As we can see from the deadlock list section of Listing 7.11, SPID 61, attempting to run the SELECT statement against cidx_BookmarkLookupDeadlock, is chosen as the deadlock victim.</p>

        <p>Interpreting XML deadlock graphs</p>

        <p>The information contained in XML deadlock graph, obtained from SQL Profiler, or Service Broker Event notifications, and so on, is essentially the same as that obtained from the output of Trace Flag 1222, and it is interpreted in exactly the same way. However, the format in which the information is presented is very different. The XML deadlock graph can be displayed graphically in Management Studio by saving the XML to a file with a .XDL extension and then opening the file in Management Studio (although, as discussed earlier, the XML generated by Extended Events can't be displayed graphically, in this manner).</p>

        <p>Figure 7.4 displays graphically the same deadlock graph that we saw for the two Trace Flags.</p>

        <p>Figure 7.4: SSMS graphical deadlock graph.</p>

        <p>In the graphical display, the deadlock processes are displayed as ovals. The process information is displayed inside of the oval, and includes a tooltip, which pops up when the mouse hovers over the process, and displays the statement being executed, as shown in Figure 7.5. The deadlock victim process is shown crossed out.</p>

        <p>Figure 7.5: SSMS graphical deadlock graph: the victim process.</p>
        
        <p>The resources contributing to the deadlock are displayed in rectangular boxes in the center of the graphical display. The locks, and their respective modes, are displayed by arrows between the processes and the resources. Locks owned by a process are shown with the arrow pointed towards the process, while locks being requested are shown with the arrow pointed towards the resource as shown in Figure 7.6.</p>

        <p>Figure 7.6: SSMS graphical deadlock graph: processes and resources.</p>

        <p>A visual display like this makes it much easier to understand the circular blocking that caused the deadlock to occur.</p>

        <p>Common types of deadlock and how to eliminate them</p>

        <p>When troubleshooting any type of problem in SQL Server, you learn with experience how to recognize, from a distance, the particular varieties of problem that tend to crop up on a regular basis. The same is true of deadlocks; the same types of deadlock tend to appear with predictable regularity and, once you understand what patterns to look for, resolving the deadlock becomes much more straightforward.</p>

        <p>This section assumes knowledge of basic locking mechanisms inside SQL Server (see Chapter 6) and examines how to resolve the most common types of deadlock, namely the bookmark lookup deadlock, the serializable range scan deadlock, the cascading constraint deadlock, the intra-query parallelism deadlock and the accessing objects in different orders deadlock.</p>

        <p>Bookmark lookup deadlock</p>

        <p>Bookmark lookup deadlocks are one of the most common deadlocks in SQL Server. Fortunately, although they have a habit of appearing randomly, without any changes to the database or the code inside of it, they are also one of the easiest types of deadlock to troubleshoot.</p>

        <p>Bookmark lookup deadlocks generally have a SELECT statement as the victim, and an INSERT, UPDATE, or DELETE statement as the other contributing process to the deadlock. They occur partly as a general consequence of SQL Server's pessimistic locking mechanisms for concurrency, but mainly due to the lack of an appropriate covering index for the SELECT operation.</p>

        <p>When a column is used in the WHERE clause to filter the SELECT statement and a non-clustered index exists on that column, then the database engine takes a shared lock on the required rows or pages in the non-clustered index. In order to return any additional columns from the table, not covered by the non-clustered index, the database engine performs an operation known as KEY, or RID, lookup (in SQL Server 2000, the term "bookmark lookup" was used). This operation uses either the Clustered Index Key or RID (in the case of a heap) to look up the row in the table data and retrieve the additional columns.</p>

        <p>When a lookup operation occurs, the database engine takes additional shared locks on the rows or pages needed from the table. These locks are held for the duration of the SELECT operation, or until lock escalation is triggered to increase the lock granularity from row or page to table.</p>

        <p>The deadlock occurs, as we have seen in previous sections, when an operation that changes the data in a table (for example, an INSERT, UPDATE, or DELETE operation) occurs simultaneously with the SELECT. When the data-changing session executes, it acquires an exclusive lock on the row or page of the clustered index or table, and performs the data change operation. At the same time the SELECT operation acquires a shared lock on the non-clustered index. The data-changing operation requires an exclusive lock on the non-clustered index to complete the modification, and the SELECT operation requires a shared lock on the clustered index, or table, to perform the bookmark lookup. Shared locks and exclusive locks are incompatible, so if the data-changing operation and the SELECT operation affect the same rows then the data-changing operation will be blocked by the SELECT, and the SELECT will be blocked by the data change, resulting in a deadlock.</p>

        <p>One of the most common online recommendations for curing this type of deadlock is to use a NOLOCK table hint in the SELECT statement, to prevent it from acquiring shared locks. This is bad advice. While it might prevent the deadlock, it can have unwanted side effects, such as allowing operations to read uncommitted changes to the database data, and so return inaccurate results.</p>

        <p>The correct fix for this type of deadlock is to change the definition of the non-clustered index so that it contains, either as additional key columns or as INCLUDE columns (see Chapter 5), all the columns it needs to cover the query. Columns returned by the query that are not used in a JOIN, WHERE, or GROUP BY clause, can be added to the index as INCLUDE columns. Any column used in a JOIN, the WHERE clause, or in a GROUP BY should ideally be a part of the index key but, in circumstances where this exceeds the 900-byte limit, addition as an INCLUDE column may work as well. Implementing the covering index will resolve the deadlock without the unexpected side effects of using NOLOCK.</p>
        
        <p>A shortcut to finding the appropriate covering index for a query is to run it through the Database Engine Tuning Advisor (DTA). However, as discussed in Chapter 5, the DTA recommendations are only as good as the supplied workload, and repeated single-query evaluations against the same database can result in an excessive number of indexes, which often overlap. Manual review of any index recommendation made by the DTA should be made to determine if modification of an existing index can cover the query without creating a new index. A good video example, Using the DTA to Assist in Performance Tuning, can be found on the SQL Share website (http://www.sqlshare.com/using-thedta-to-assist-in-performance-tuning_599.aspx).</p>

        <p>Range scans caused by SERIALIZABLE isolation</p>

        <p>The SERIALIZABLE isolation level is the most restrictive isolation level in SQL Server for concurrency control, ensuring that every transaction is completely isolated from the effects of any other transaction.</p>

        <p>To accomplish this level of transactional isolation, range locks are used when reading data, in place of the row or page level locking used under READ COMMITTED isolation. These range locks ensure that no data changes can occur that affect the result set, allowing the operation to be repeated inside the same transaction with the same result. While the default isolation level for SQL Server is READ COMMITTED, certain providers, like COM+ and BizTalk, change the isolation to SERIALIZABLE when connections are made.</p>

        <p>Range locks have two components associated with their names, the lock type used to lock the range and then the lock type used for locking the individual rows within the range. The four most common range locks are shared-shared (RangeS-S), shared-update (RangeS-U), insert-null (RangeI-N), and exclusive (RangeX-X). Deadlocks associated with SERIALIZABLE isolation are generally caused by lock conversion, where a lock of higher compatibility, such as a RangeS-S or RangeS-U lock, needs to be converted to a lock of lower compatibility, such as a RangeI-N or RangeX-X lock.</p>

        <p>A common deadlock that occurs under SERIALIZABLE isolation has a pattern that involves a transaction that checks if a row exists in a table before inserting or updating the data in the table. A reproducible example of this deadlock is included in the code examples for this chapter. This type of deadlock will generally produce a deadlock graph with a resource-list similar to the one shown in Listing 7.13.</p>

        <div>
            <pre>
                <code>
                    <resource-list>
                    <keylock hobtid="72057594050969600" dbid="5" objectname="AdventureWorks.
                    Sales.SalesOrderHeader" indexname="IX_SalesOrderHeader_CustomerID" id="lock35bcc80"
                    mode="RangeS-U" associatedObjectId="72057594050969600">
                    <owner-list>
                    <owner id="processad4d2e8" mode="RangeS-U" />
                    <owner id="process9595b8" mode="RangeS-S" />
                    </owner-list>
                    <waiter-list>
                    <waiter id="processad4d2e8" mode="RangeI-N" requestType="convert" />
                    <waiter id="process9595b8" mode="RangeI-N" requestType="convert" />
                    </waiter-list>
                    </keylock>
                    </resource-list>
                </code>
            </pre>
        </div>

        <p>Listing 7.13: Extract from a deadlock graph for a SERIALIZABLE range scan deadlock.</p>

        <p>In this example, two processes have acquired compatible shared locks, RangeS-S and RangeS-U, on the SalesOrderHeader table. When one of the processes requires a lock conversion to a lock type that is incompatible with the lock being held by the other process, in this case a RangeI-N, it is blocked. If both processes require a lock conversion to RangeI-N locks, the result is a deadlock since each session is waiting on the other to release its high compatibility lock.</p>

        <p>There are several possible solutions to this type of deadlock and the most appropriate one depends on the database and the application it supports. If it is not necessary for the database to maintain the range locks acquired during the SELECT operation that checks for row existence and the SELECT operation can be moved outside of the transaction that performs the data change, then the deadlock can be prevented.</p>
        
        <p>If the operation doesn't require the use of SERIALIZABLE isolation, then changing the isolation level to a less restrictive isolation level, for example READ COMMITTED, will prevent the deadlock and allow a greater degree of concurrency.</p>

        If neither of these solutions is appropriate, the deadlock can be resolved by forcing the SELECT statement to use a lower-compatibility lock, through the use of an UPDLOCK or XLOCK table hint. This will block any other transactions attempting to acquire locks of higher compatibility. This fix is specific to this particular type of deadlock due to the usage of SERIALIZABLE isolation. Using UPDLOCK hints under READ COMMITTED may result in deadlocks occurring more frequently under certain circumstances.

        <p>Cascading constraint deadlocks</p>

        <p>Cascading constraint deadlocks are generally very similar to a Serializable Range Scan deadlock, even though the isolation level under which the victim transaction was running isn't SERIALIZABLE. To enforce cascading constraints, SQL Server has to traverse the FOREIGN KEY hierarchy to ensure that orphaned child records are not left behind, as the result of an UPDATE or DELETE operation to a parent table. To do this requires that the transaction that modifies the parent table be isolated from the effects of other transactions, in order to prevent a change that would violate FOREIGN KEY constraints, when the cascade operation subsequently completes.</p>

        <p>Under the default READ COMMITTED isolation, the database engine would acquire and hold, for the duration of the transaction, Exclusive locks on all rows that had to be changed. This blocks users from reading or changing the affected rows, but it doesn't prevent another session from adding a new row into a child table for the parent key being deleted. To prevent this from occurring, the database engine acquires and holds range locks, which block the addition of new rows into the range affected by the cascading operation. This is essentially an under-the-cover use of SERIALIZABLE isolation, during the enforcement of the cascading constraint, but the isolation level for the batch is not actually changed; only the type of locks used for the cascading operation are changed.</p>
        
        <p>When a deadlock occurs during a cascading operation, the first thing to look for is whether or not non-clustered indexes exist for the FOREIGN KEY columns that are used (see Chapter 5 for more on Indexing Foreign Keys). If appropriate indexes on the FOREIGN KEY columns do not exist, the locks being taken to enforce the constraints will be held for longer periods of time, increasing the likelihood of a deadlock between two operations, if a lock conversion occurs.</p>

        <p>Intra-query parallelism deadlocks</p>

        <p>An intra-query parallelism deadlock occurs when a single session executes a query that runs with parallelism, and deadlocks itself. Unlike other deadlocks in SQL Server, these deadlocks may actually be caused by a bug in the SQL Server parallelism synchronization code, rather than any problem with the database or application design. Since there are risks associated with fixing some bugs, it may be that the bug is known and won't be fixed, since it is possible to work around it by reducing the degree of parallelism for that the query, using the MAXDOP query hint, or by adding or changing indexes to reduce the cost of the query or make it more efficient.</p>

        <p>The deadlock graph for a parallelism deadlock will have the same SPID for all of the processes, and will have more than two processes in the process-list. The resourcelist will have threadpool, exchangeEvent, or both, listed as resources, but it won't have lock resources associated with it. In addition, the deadlock graph for this type of deadlock will be significantly longer than any other type of deadlock, depending on the degree of parallelism and the number of nodes that existed in the execution plan.</p>

        <p>Additional information about this specific type of deadlock can be found on Bart Duncan's blog post, Today's Annoyingly-Unwieldy Term: "Intra-Query Parallel Thread Deadlocks" (http://blogs.msdn.com/bartd/archive/2008/09/24/today-s-annoyinglyunwieldy-term-intra-query-parallel-thread-deadlocks.aspx).</p>
        
        <p>Accessing objects in different orders</p>

        <p>One of the easiest deadlocks to create, and consequently one of the easiest to prevent, is caused by accessing objects in a database in different operation orders inside of T-SQL code, inside of transactions, as shown in Listings 7.14 and 7.15.</p>

        <div>
            <pre>
                <code>
                    BEGIN TRANSACTION
                    UPDATE TableA
                    SET Column1 = 1
                    SELECT Column2
                    FROM TableB
                </code>
            </pre>
        </div>

        <p>Listing 7.14: Transaction1 updates TableA then reads TableB.</p>

        <div>
            <pre>
                <code>
                    BEGIN TRANSACTION
                    UPDATE TableB
                    SET Column2 = 1
                    SELECT Column1
                    FROM TableA
                </code>
            </pre>
        </div>
        
        <p>Listing 7.15: Transaction2 updates TableB then reads TableA.</p>
        
        <p>Transaction1's UPDATE against TableA will result in an exclusive lock being held on the table until the transaction completes. At the same time, Transaction2 runs an UPDATE against TableB, which also results in an exclusive lock being held until the transaction completes. After completing the UPDATE to TableA, Transaction1 tries to read TableB but is blocked and unable to acquire the necessary shared lock, due to the exclusive lock being held by Transaction2. After completing its UPDATE to TableB, Transaction2 reads TableA and is also blocked, unable to acquire a shared lock due to the exclusive lock held by Transaction1. Since the two transactions are both blocking each other, the result is a deadlock and the Lock Monitor will kill one of the two sessions, rolling back its transaction to allow the other to complete.</p>

        <p>When using explicit transactions in code, it is important that objects are always accessed in the same order, to prevent this type of deadlock from occurring.</p>

        <p>Handling Deadlocks to Prevent Errors</p>

        <p>In most cases, the same issues that cause severe blocking in the database, such as poor database design, lack of indexing, poorly designed queries, inappropriate isolation level and so on (all discussed in Chapter 6), are also the common causes of deadlocking. In most cases, by fixing such issues, we can prevent deadlocks from occurring. Unfortunately, the time deadlocks become a problem, it may not be possible to make the necessary design changes to correct them.</p>

        <p>Therefore, an important part of application and database design is defensive programming; a technique that anticipates and handles exceptions as a part of the general code base for an application or database. Defensive programming to handle deadlock exceptions can be implemented in two different ways:</p>

        <ul>
            <li>database-side, through the use of T-SQL TRY…CATCH blocks</li>
            <li>application-side, through the use of application TRY…CATCH blocks.</li>
        </ul>

        <p>In either case, proper handling of the 1205 exception raised by SQL Server for the deadlock victim can help avoid UnhandledException errors in the application and the ensuing end-user phone calls to Help Desk or Support.</p>
        
        <p>T-SQL TRY…CATCH blocks</p>

        <p>Depending on how an application is designed, and whether there is separation between application code and database code, the simplest implementation of deadlock error handling could be via the use of BEGIN TRY/CATCH blocks inside of the T-SQL being executed.</p>

        <p>This technique is most applicable in cases where an application calls stored procedures for all of its data access. In such cases, changing the code in a stored procedure so that it handles the deadlock exception doesn't require changes to application code, or recompiling and redistribution of the application. This greatly simplifies the implementation of such changes.</p>

        <p>The best way to deal with a deadlock, within your error handling code, will depend on your application and its expected behavior in the event of a deadlock. One way of handling the deadlock would be to retry the transaction a set number of times before actually raising an exception back to the application for handling. The cross-locking situation associated with a deadlock generally only lasts a very short duration, usually timed in milliseconds so, more often than not, a subsequent attempt at executing the T-SQL code selected as a victim will succeed, and there will be no need to raise any exceptions to the application.</p>

        <p>However, it is possible that the deadlock will continue to occur, and we need to avoid getting into an infinite loop, attempting repeatedly to execute the same failing code. To prevent this, a variable is used to count down from a maximum number of retry attempts; when zero is reached, an exception will be raised back to the application. This technique is demonstrated in Listing 7.16.</p>

        <div>
            <pre>
                <code>
                    DECLARE @retries INT ;
                    SET @retries = 4 ;
                    WHILE ( @retries > 0 )
                    BEGIN269
                    Chapter 7: Handling Deadlocks
                    BEGIN TRY
                    BEGIN TRANSACTION ;
                    -- place sql code here
                    SET @retries = 0 ;
                    COMMIT TRANSACTION ;
                    END TRY
                    BEGIN CATCH
                    -- Error is a deadlock
                    IF ( ERROR_NUMBER() = 1205 )
                    SET @retries = @retries - 1 ;
                    -- Error is not a deadlock
                    ELSE
                    BEGIN
                    DECLARE @ErrorMessage NVARCHAR(4000) ;
                    DECLARE @ErrorSeverity INT ;
                    DECLARE @ErrorState INT ;
                    SELECT @ErrorMessage = ERROR_MESSAGE() ,
                    @ErrorSeverity = ERROR_SEVERITY() ,
                    @ErrorState = ERROR_STATE() ;
                    -- Re-Raise the Error that caused the problem
                    RAISERROR (@ErrorMessage, -- Message text.
                    @ErrorSeverity, -- Severity.
                    @ErrorState -- State.
                    ) ;
                    SET @retries = 0 ;
                    END
                    IF XACT_STATE() <> 0
                    ROLLBACK TRANSACTION ;
                    END CATCH ;
                    END ;
                    GO
                </code>
            </pre>
        </div>
        
        <p>Listing 7.16: TRY…CATCH handling of deadlock exceptions, in T-SQL.</p>
        
        <p>Handling ADO.NET SqlExceptions in .NET code</p>

        <p>While it is possible to handle deadlocks in SQL Server 2005 and 2008, using BEGIN TRY and BEGIN CATCH blocks, the same functionality doesn't exist in SQL Server 2000, and in any event it may not be acceptable to have the database engine retry the operation automatically. In either case, the client application should be coded to handle the deadlock exception that is raised by SQL Server.</p>

        <p>There isn't much difference between the error handling in .NET and the error handling in T-SQL. A TRY…CATCH block is used to execute the SQL call from the application and catch any resulting exception raised by SQL Server. If the code should reattempt the operation in the event of a deadlock, a maximum number of retries should be set by a member variable that is decremented each time a deadlock is encountered.</p>

        <p>The example in Listing 7.17 shows how to catch the SqlException in C#, but can be used as a model to handle deadlocks in other languages as well.</p>

        <div>
            <pre>
                <code>
                    int retries = 4;
                    while (retries > 0)
                    {
                        try
                        {
                            // place sql code here
                            retries = 0;
                        }
                        catch (SqlException exception)
                        {
                            // exception is a deadlock
                            if (exception.Number == 1205)
                            {
                                // Delay processing to allow retry.
                                Thread.Sleep(500);
                                retries --;
                            }
                            // exception is not a deadlock
                            else
                            {
                                throw;
                            }
                        }
                    }
                </code>
            </pre>
        </div>
        
        <p>Listing 7.17: TRY…CATCH handling of deadlock exceptions, in C#.</p>

        <p>Rather than retrying the operation, it may be desirable to log the exception in the Windows Application Event Log, or perhaps display a MessageBox dialog and determine whether or not to retry the operation, based on user input. These are two examples of how handling the deadlock exception in the application code allows for more flexibility over handling the deadlock in the database engine.</p>

        <p>Controlling Deadlock Behavior with Deadlock Priority</p>

        <p>There are circumstances (for example, a critical report that performs a long running SELECT that must complete even if it is the ideal deadlock victim) where it may be preferable to specify which process will be chosen as the deadlock victim in the event of a deadlock, rather than let SQL Server decide based purely on the cost of rollback. As demonstrated in Listing 7.18, SQL Server offers the ability to set, at the session or batch level, a deadlock priority using the SET DEADLOCK PRIORITY option.</p>

        <div>
            <pre>
                <code>
                    -- Set a Low deadlock priority
                    SET DEADLOCK_PRIORITY LOW ;
                    GO
                    -- Set a High deadlock priority
                    SET DEADLOCK_PRIORITY HIGH ;
                    GO
                    -- Set a numeric deadlock priority
                    SET DEADLOCK_PRIORITY 2 ;
                </code>
            </pre>
        </div>
        
        <p>Listing 7.18: Setting deadlock priority.</p>
        
        <p>A process running in a batch or session with a low deadlock priority will be chosen as the deadlock victim over one that is running with a higher deadlock priority. Like all other SET options in SQL Server, the DEADLOCK PRIORITY is only in effect for the current execution scope. If it is set inside of a stored procedure, then when the stored procedure execution completes, the priority returns to the original priority of the calling execution scope.</p>

        <p>Note that SQL Server 2000 offers only two deadlock priorities; Low and Normal. This allows the victim to be determined by setting its priority to Low. SQL Server 2005 and 2008 however, have three named deadlock priorities; Low, Normal, and High, as well as a numeric range from -10 to +10, for fine-tuning the deadlock priority of different operations.</p>

        <p>The deadlock priority is set at execution time, and all users have the permission to set a deadlock priority. This can be a problem if users have ad hoc query access to SQL Server, and set their deadlock priority higher than other processes, in order to prevent their own process from being selected as a victim.</p>

        <p>Summary</p>

        <p>This chapter has covered how to capture and interpret deadlock graph information in SQL Server to troubleshoot deadlocking. The most common deadlocks have also been covered to provide a foundation for troubleshooting other types of deadlocks that might occur. Most often, deadlocks are the result of a design problem in the database or code that can be fixed to prevent the deadlock from occurring. However, when changes to the database are not possible to resolve the deadlock, adding appropriate error handling in the application code reduces the impact caused by a deadlock occurring. The information included in this chapter should allow rapid and efficient troubleshooting of most deadlocks in SQL Server.</p>
    </main>

    <div id="topo">
        <a href="#" target="_self"><i class="material-symbols-outlined">stat_2</i></a>
    </div>

    <footer>
        <p>Criado por Agnaldo Mota</p>
    </footer>

    <script src="scripts/script.js"></script>
</body>
</html>
