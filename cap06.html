<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBA Acidental</title>
    <link rel="stylesheet" href="estilo/style.css">
    <link rel="stylesheet" href="estilo/media-queries.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
</head>

<body onresize="mudouTamanho()">
    <header>
        <h1>Troubleshooting SQL Server</h1>
        <h2>Um Guia para o DBA Acidental</h2>
    </header>

    <nav>
        <i id="burger" class="material-icons" onclick="clickMenu()">menu</i>
        <menu id="itens">
            <ul>
                <li><a href="index.html" target="_self"><i id="home" class="material-icons">home</i></a></li>
                <li><a href="abertura.html" target="_self">Abertura</a></li>
                <li><a href="introducao.html" target="_self">Introdução</a></li>
                <li><a href="cap01.html" target="_self">Cap.1</a></li>
                <li><a href="cap02.html" target="_self">Cap.2</a></li>
                <li><a href="cap03.html" target="_self">Cap.3</a></li>
                <li><a href="cap04.html" target="_self">Cap.4</a></li>
                <li><a href="cap05.html" target="_self">Cap.5</a></li>
                <li><a href="cap07.html" target="_self">Cap.7</a></li>
				<li><a href="cap08.html" target="_self">Cap.8</a></li>
            </ul>
        </menu>
    </nav>
    
    <main>
        <h1>Capítulo 6: Bloqueio</h1>

        <p>Em um banco de dados típico e movimentado, muitas transações de usuários competirão por acesso simultâneo a vários recursos compartilhados do banco de dados (tabelas, índices, etc.). Por padrão, o SQL Server media o acesso a esses recursos usando vários tipos de bloqueios. Esses bloqueios impedem que transações concorrentes interfiram "destrutivamente" umas nas outras, garantindo assim que cada transação possa ler e modificar dados de maneira consistente.</p>

        <p>Essa atividade de bloqueio e interrupção faz parte normal do funcionamento diário de um banco de dados. No entanto, em condições de acesso de usuários altamente concorrentes, o número de bloqueios aumentará, aumentando também o potencial para bloqueios. À medida que a duração do bloqueio de processos aumenta, o desempenho geral do banco de dados diminui, e os usuários começam a se queixar.</p>

        <p>Em sistemas com muitas transações simultâneas, algum grau de bloqueio é provavelmente inevitável, mas a situação pode ser significativamente exacerbada por consultas que são mais longas ou mais complexas do que precisam ser, ou que leem mais dados do que necessário; ou por bancos de dados mal projetados que carecem de chaves e indexação adequadas, ou por transações que precisam usar níveis mais restritivos de isolamento transacional (como REPEATABLE READ ou SERIALIZABLE). Todos esses fatores podem aumentar o número e a duração dos bloqueios sendo mantidos, e, assim, aumentar a incidência de bloqueios.</p>

        <p>Este capítulo descreverá como analisar o SQL Server para verificar se um problema está relacionado a bloqueio, identificar qual processo está sendo bloqueado e qual processo está causando o bloqueio, e em seguida, como resolver algumas causas comuns de bloqueio.</p>

        <h2 id="blockconcor">Bloqueios e Concorrência (uma Breve Revisão)</h2>

        <p>Por padrão, o SQL Server utiliza bloqueio pessimista para garantir a concorrência transacional, onde todas as operações no banco de dados adquirem bloqueios. Por exemplo, quando uma operação lê dados, o SQL Server adquire bloqueios <strong>compartilhados</strong> (S)  - shared - nas linhas ou páginas acessadas pela instrução <code><code>SELECT</code></code>. Quando uma operação altera dados, ou seja, um <code>INSERT</code>, <code>UPDATE</code> ou <code>DELETE</code>, um bloqueio <strong>exclusivo</strong> (X) é adquirido na linha ou página no índice agrupado ou tabela. Um bloqueio S <strong>impedirá</strong> que outra transação modifique os dados enquanto o <code>SELECT</code> estiver em execução, mas não impede que outras transações leiam os dados. Se uma transação mantiver um bloqueio X em um recurso, qualquer outra transação que deseje ler ou gravar os mesmos dados será <strong>bloqueada</strong> até que o bloqueio X seja liberado. Isso garante que uma transação não leia dados que estão em fluxo (ou seja, evita "leituras sujas") e que duas transações não possam alterar a mesma linha de dados ou tentar inserir duas linhas de dados no mesmo local em uma página.</p>

        <p>Vários fatores afetam o tipo e o modo de bloqueio usado pelo SQL Server durante condições de acesso concorrente a um determinado recurso, bem como o momento exato em que esses bloqueios são adquiridos e liberados. Nesta seção, vamos apenas revisar brevemente alguns dos conceitos fundamentais por trás do bloqueio e da concorrência no SQL Server.</p>

        <h3 id="lockmode">Modos de Bloqueio</h3>

        <p>O SQL Server utiliza diversos <strong>modos de bloqueio</strong> para controlar como transações concorrentes podem acessar um recurso compartilhado. Alguns dos bloqueios mais comumente encontrados são <strong>compartilhados</strong> (shared), de <strong>atualização</strong> (update), <strong>exclusivos</strong> (exclusive) e os bloqueios de <strong>intenção</strong> associados.</p>

        <p>Observe que existem vários outros modos, uma discussão completa dos quais está fora do escopo deste capítulo. Uma lista completa e descrições podem ser encontradas no MSDN (<a href="http://msdn.microsoft.com/en-us/library/ms175519.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/ms175519.aspx</a> e <a href="http://msdn.microsoft.com/en-us/library/ms186396.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/ms186396.aspx</a>).</p>

        <h4>Compartilhado</h4>

        <p>Um bloqueio compartilhado (representado por S) é um bloqueio que é adquirido, por padrão, por consultas que estão lendo de uma tabela ou índice. Bloqueios compartilhados são compatíveis com outros bloqueios compartilhados e bloqueios de atualização, mas não com bloqueios exclusivos.</p>

        <h4>Atualização</h4>

        <p>Um bloqueio de atualização (representado por U) é adquirido como parte de uma operação de atualização. Ele é compatível com bloqueios compartilhados, mas não com outros bloqueios de atualização ou bloqueios exclusivos.</p>

        <h4>Exclusivo</h4>
        
        <p>Um bloqueio exclusivo (representado por X) é adquirido para qualquer modificação de dados (inserção, atualização, exclusão). Ele não é compatível com nenhum outro tipo de bloqueio.</p>

        <p>Para uma operação de atualização, o SQL Server primeiro adquire um bloqueio de atualização e depois o converte em um bloqueio exclusivo para realizar a atualização real (as razões para isso são explicadas no Books Online, <a href="http://msdn.microsoft.com/en-us/library/ms175519.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/ms175519.aspx</a>, e não serão discutidas mais detalhadamente aqui).</p>

        <h4>Bloqueios de intenção</h4>

        <p>Cada modo de bloqueio tem associado um bloqueio de intenção correspondente (representado por I). Portanto, você verá bloqueios IS (Intent Shared), bloqueios IU (Intent Update) e bloqueios IX (Intent Exclusive).</p>

        <p>Um bloqueio de intenção é usado para reduzir o trabalho que o SQL precisa fazer para determinar se um bloqueio pode ser concedido. Se um bloqueio de linha é necessário por uma consulta, o SQL primeiro adquire o bloqueio de intenção apropriado no nível da tabela e, em seguida, um bloqueio de intenção apropriado no nível da página, antes de adquirir o bloqueio de linha necessário.</p>

        <p>Os bloqueios IS são compatíveis com bloqueios compartilhados e de atualização, bem como com todos os outros bloqueios de intenção. Bloqueios IU são compatíveis com bloqueios compartilhados e outros bloqueios de intenção. Bloqueios IX são compatíveis apenas com outros bloqueios de intenção. </p>
        
        <h3 id="locktype">Tipos de bloqueio</h3>

        <p>O SQL Server pode bloquear vários tipos diferentes de recursos, sendo os mais óbvios as <strong>tabelas</strong> (bloqueios de OBJETO), <strong>páginas</strong> (bloqueios de PÁGINA) e <strong>linhas</strong> (bloqueios de RID ou CHAVE), em ordem crescente de granularidade. Bloqueios são concedidos e liberados nesses objetos conforme necessário, a fim de atender aos requisitos dos níveis de isolamento em uso pelas diversas sessões. Na hierarquia de bloqueio, os bloqueios de linha e chave são os tipos mais baixos e mais granulares de bloqueio. Quanto mais granular o bloqueio, maior o grau de acesso simultâneo que pode ser suportado. No entanto, isso vem acompanhado de uma sobrecarga de memória mais elevada, devido à necessidade de gerenciar um grande número de bloqueios individuais.</p>

        <p>O SQL Server escolhe automaticamente bloqueios da granularidade <strong>mais alta possível</strong>, adequada para a carga de trabalho fornecida. No entanto, se estiverem sendo mantidos muitos bloqueios individuais em um índice ou heap, ou se for forçado a fazer isso devido à pressão de memória, o SQL Server pode usar a escalada de bloqueio para reduzir o número total de bloqueios mantidos. Por exemplo, um grande número de bloqueios individuais de linha pode ser escalado para um único bloqueio de tabela, ou vários bloqueios de página podem ser escalados para um bloqueio de tabela (a escalada é sempre para um bloqueio de tabela). Embora isso resulte em uma sobrecarga menor no SQL Server, o custo será uma menor concorrência. Mais adiante no capítulo, mostraremos como investigar a escalada de bloqueio e seu impacto na concorrência.</p>

        <p>Outro tipo de bloqueio que precisa ser discutido aqui é o bloqueio em <strong>nível de banco de dados</strong>. As pessoas frequentemente ficam preocupadas quando veem um grande número de bloqueios em nível de banco de dados listados nos resultados retornados pela consulta às DMVs (Visualizações de Gerenciamento Dinâmico) relacionadas a bloqueios. Esses serão descritos mais tarde, na seção de Monitoramento de Bloqueios. Na realidade, isso não é motivo de preocupação. Cada sessão realiza um bloqueio compartilhado no banco de dados ao qual está conectado. Isso é feito para garantir que o banco de dados não possa ser restaurado, excluído, fechado ou desanexado enquanto ainda houver sessões usando-o. Esses bloqueios não causarão bloqueios, exceto no caso de restaurar, excluir, alterar, desanexar ou fechar um banco de dados em uso.</p>
        
        <h3 id="lockscalation">Escalada de Bloqueio</h3>
        
        <p>A escalada de bloqueio é o processo pelo qual o SQL Server eleva um bloqueio de baixo nível e granular para um bloqueio de nível superior. Os bloqueios podem começar como bloqueios de linha ou página; isso não faz diferença no processo de escalada de bloqueio. Se o SQL decidir realizar a escalada dos bloqueios, em todos os casos ela ocorrerá diretamente para bloqueios de tabela (exceto quando esse comportamento for explicitamente alterado usando a opção <code>LOCK_ESCALATION</code>, discutida em breve). Bloqueios não escalonam, em nenhuma circunstância, de linha para página e depois para tabela.</p>

        <p>No SQL Server, a escalada de bloqueio é completamente dinâmica. Os limiares que o SQL utiliza para a escalada de bloqueio são detalhados no Books Online (<a href="http://msdn.microsoft.com/en-us/library/ms184286.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/ms184286.aspx</a>). Para os propósitos deste capítulo, é suficiente dizer que o SQL tentará realizar a escalada de bloqueio quando um determinado número de bloqueios tiver sido obtido na tabela/índice, ou quando o número total de bloqueios, ou a quantidade de memória de bloqueio, ultrapassar os limites configurados.</p>

        <p>Em alguns casos, a escalada de bloqueio pode causar bloqueios porque o SQL escalou os bloqueios, resultando no travamento da tabela inteira e restringindo o acesso simultâneo a essa tabela. Para identificar escaladas de bloqueio, o SQL Trace ou o Profiler podem ser utilizados com o evento Lock:Escalation, em conjunto com os eventos <code>SP:Started</code> ou <code>T-SQL:StmtStarted</code> e <code>SP:Completed</code> ou <code>T-SQL:StmtCompleted</code>, na tentativa de correlacionar a escalada de bloqueio com as instruções e procedimentos em execução no momento.</p>

        <p>Se este evento estiver registrado e houver bloqueios mensuráveis em torno do momento em que o evento foi registrado, é possível que a escalada de bloqueio esteja causando problemas. Nesse caso, os procedimentos que estavam em execução no momento do evento podem precisar ser otimizados para reduzir a quantidade ou duração dos bloqueios.</p>
        
        <p>O SQL Server 2008 introduziu uma nova opção para alterar a forma como ocorre a escalada de bloqueio no SQL Server. A instrução <code>ALTER TABLE</code> agora possui a opção <code>LOCK_ESCALATION</code>. As opções para essa configuração são <code>AUTO</code>, <code>TABLE</code> (padrão) e <code>DISABLE</code>. Antes do SQL Server 2008, a escalada de bloqueio ocorria apenas para o nível da tabela.</p>

        <p>A configuração <code>TABLE</code> é o comportamento padrão; os bloqueios são elevados apenas para o nível da tabela. A configuração <code>DISABLE</code> desativa completamente a escalada de bloqueio nesta tabela. Isso pode ser útil em algumas circunstâncias, mas deve ser usado com cuidado. A alteração na escalada de bloqueio é discutida posteriormente, na seção intitulada <em>"Dicas, Flags de Trace e Outros Últimos Recurso"</em>.</p>

        <p>A configuração <code>AUTO</code> é a de interesse. Se uma tabela for particionada e a opção <code>LOCK_ESCALATION</code> estiver definida como <code>AUTO</code>, e se o SQL decidir escalar os bloqueios, qualquer bloqueio mantido na tabela será elevado para o nível da partição, não para o nível da tabela. Isso pode ser útil ao lidar com uma tabela particionada em que as modificações de dados são restritas a uma partição, mas as leituras são realizadas em várias partições. Se as modificações causassem uma escalada para o nível da tabela, as leituras seriam bloqueadas. No entanto, se as modificações apenas escalarem para o nível da partição, as leituras podem não ser afetadas. Alguma cautela é necessária ao considerar essa configuração, pois ela pode, em alguns casos, resultar em deadlocks. Para um exemplo de tal deadlock, consulte <a href="http://www.sqlskills.com/blogs/paul/post/SQL-Server-2008-Partition-level-lock-escalation-details-and-examples.aspx" target="_blank">http://www.sqlskills.com/blogs/paul/post/SQL-Server-2008-Partition-level-lock-escalation-details-and-examples.aspx</a>.</p>

        <h3 id="concurisolation">Concorrência e os níveis de isolamento de transações</h3>

        <p>O grau em que sessões concorrentes podem acessar o mesmo recurso simultaneamente é ditado pelos <strong>níveis de isolamento de transações</strong> em vigor para as sessões estão acessando o banco de dados.</p>

        <p>Nas normas ANSI, os níveis de isolamento são definidos pelo tipo de anomalias de dados que eles permitem, não pela maneira como são aplicados. Cada nível de isolamento (do menos restritivo ao mais restritivo) permite menos anomalias de dados. <code>SERIALIZABLE</code> não deve permitir nenhuma anomalia de dados; <code>REPEATABLE READ</code> é definido como um nível de isolamento que só permite linhas fantasmas; <code>READ COMMITTED</code> é identificado como um nível de isolamento que permite linhas fantasmas e leituras não repetíveis; <code>READ UNCOMMITTED</code> é identificado como um nível de isolamento que permite linhas fantasmas, leituras não repetíveis e leituras sujas.</p>

        <p>À medida que o nível de isolamento se torna mais restritivo, o SQL Server adquirirá diferentes modos de bloqueio e os manterá por períodos mais longos, a fim de garantir que o nível necessário seja aplicado. Vamos abordar brevemente os níveis de isolamento aqui, e o blog de Craig Freedman (<a href="http://blogs.msdn.com/b/craigfr/archive/tags/isolation+levels/" target="_blank">http://blogs.msdn.com/b/craigfr/archive/tags/isolation+levels/</a>) é uma boa fonte para leituras adicionais sobre esse tópico.</p>

        <h4>READ UNCOMMITTED</h4>

        <p>Neste nível de isolamento, o SQL Server não realiza nenhum bloqueio compartilhado. Como nenhum bloqueio é realizado, uma sessão não será bloqueada por bloqueios exclusivos. Bloqueios de atualização e exclusivos ainda são adquiridos ao modificar dados. Devido à ausência de bloqueios compartilhados, este nível de isolamento permite leituras sujas (leituras de dados não confirmados), assim como todas as anomalias de dados dos níveis de isolamento mais elevados.</p>

        <h4>READ COMMITED</h4>

        <p>Este é o modo de operação padrão. O SQL Server impedirá "leituras sujas" (ou seja, garantirá que as transações só possam retornar dados confirmados). Para fazer isso, o SQL Server adquirirá bloqueios S de curta duração em cada linha que é lida, liberando o bloqueio à medida que o processamento da instrução avança para a próxima linha, embora possa manter esses bloqueios até que toda a instrução tenha terminado o processamento, caso seja necessário para garantir resultados consistentes. Os bloqueios compartilhados são retidos por, no máximo, a duração da instrução em execução, mesmo que a transação da qual a instrução faz parte ainda esteja ativa. Portanto, se a mesma instrução for executada novamente, como parte da mesma transação, ela poderá retornar resultados diferentes. Essa é a anomalia de dados conhecida como "leitura não repetível".</p>
        
        <h4>REPEATABLE READ</h4>
        <p>Os bloqueios compartilhados são mantidos por mais tempo, durante toda a transação. Portanto, se uma instrução for executada novamente dentro da mesma transação, você obterá o mesmo resultado. Portanto, esse nível de isolamento não permite mais leituras não repetíveis. Ainda permite que novas linhas tenham sido inseridas no intervalo de tempo que correspondem aos critérios da consulta. Essas novas linhas que aparecem dentro de um conjunto de resultados são conhecidas como linhas fantasmas.</p>

        <h4>SERIALIZABLE</h4>

        <p>A transação A nunca verá nenhum dos efeitos da Transação B durante toda a duração da Transação A. Para impor esse nível, a Transação A fará com que o SQL Server adquira bloqueios de intervalo de chaves nas linhas que foram lidas, o que impede que qualquer outra transação as modifique ou insira novas linhas até que a Transação A seja concluída. O nível de isolamento <code>SERIALIZABLE</code> não permite nenhuma anomalia de dados, mas isso ocorre com a restrição significativa do grau em que o banco de dados pode suportar acesso simultâneo.</p>
        
        <h4>Otimismo de concorrência usando versionamento de linha</h4>

        <p>Além dos níveis de isolamento tradicionais discutidos na seção anterior, o SQL Server 2005 introduziu dois níveis de isolamento adicionais que utilizam concorrência otimista em vez de pessimista. Ambos usam versionamento de linha em vez de bloqueios para a aplicação de concorrência.</p>

        <p>Há muito mais sobre o versionamento de linha do que pode ser abordado aqui, então esta é apenas uma breve síntese. Para obter detalhes completos sobre como a concorrência otimista funciona, consulte o artigo "Isolamento de Transações Baseado em Versionamento de Linha no SQL Server 2005" em <a href="http://msdn.microsoft.com/en-us/library/ms345124(v=sql.90).aspx" target="_blank">http://msdn.microsoft.com/en-us/library/ms345124(v=sql.90).aspx</a>. Apesar de ter sido escrito para o SQL 2005, ainda é válido para o SQL 2008.</p>
        
        <p>Existem dois níveis de isolamento de concorrência otimista: <code>READ_COMMITTED_SNAPSHOT</code> e <code>SNAPSHOT</code>. Eles costumam ser confundidos entre si, então vou tentar abordar as diferenças significativas aqui. Ambos esses níveis de isolamento utilizam versionamento de linha para consistência de leitura, não bloqueios. Portanto, consultas de leitura não geram bloqueios. Em vez de bloquear quando encontram uma linha sujeita a um bloqueio exclusivo, elas simplesmente "contornam" o bloqueio, recuperando da versão armazenada (em TempDB) a versão da linha consistente com um determinado ponto no tempo, seja o momento em que a instrução começou ou o momento em que a transação pai começou.</p>

        <p>O <code>READ_COMMITTED_SNAPSHOT</code> é uma versão de concorrência otimista do nível de isolamento <code>READ COMMITTED</code>, portanto, permite as mesmas anomalias de dados. No entanto, como discutido anteriormente, se uma instrução em execução sob o tradicional nível de isolamento <code>READ COMMITTED</code> encontra dados sendo modificados por outra transação, ela deve aguardar até que essas alterações sejam confirmadas ou revertidas antes de poder adquirir um bloqueio compartilhado e continuar. No nível de isolamento <code>READ_COMMITTED_SNAPSHOT</code>, quando uma linha bloqueada é encontrada, o SQL Server busca a versão da linha na versão armazenada, conforme existia quando a instrução começou. Em outras palavras, os dados retornados refletirão apenas o que foi confirmado no momento em que a instrução atual começou. Isso significa que a consistência é garantida dentro da instrução, não dentro da transação como um todo.</p>

        <p>O isolamento <code>SNAPSHOT</code> é uma versão de concorrência otimista do nível de isolamento <code>SERIALIZABLE</code>. Como tal, não permite anomalias de dados. Neste nível de isolamento, quando uma linha bloqueada é encontrada, o SQL busca a versão mais recente da linha conforme ela existia quando a transação começou. Em outras palavras, os dados retornados refletirão apenas o que foi confirmado no momento em que a transação atual começou.</p>

        <p>A outra diferença entre os dois níveis está em como eles são habilitados. Se a opção de banco de dados <code>READ_COMMITTED_SNAPSHOT</code> estiver ativada, o nível de isolamento padrão do banco de dados se tornará <code>READ_COMMITTED_SNAPSHOT</code>, e serão necessárias dicas ou declarações explícitas <code>SET TRANSACTION ISOLATION LEVEL</code> para obter o nível de isolamento <code>READ COMMITTED</code> (que usará bloqueios). Se a opção de banco de dados <code>ALLOW_SNAPSHOT_ISOLATION</code> estiver ativada, tudo o que acontece é que as sessões podem solicitar o isolamento <code>SNAPSHOT</code> usando uma instrução <code>SET TRANSACTION ISOLATION LEVEL</code>.</p>

        <h4>Maximizando a concorrência.</h4>

        <p>Em um banco de dados movimentado, o SQL Server precisa manter uma grande quantidade de diferentes tipos de bloqueio para mediar o acesso a recursos compartilhados e garantir resultados consistentes, com bloqueio mínimo. No entanto, mesmo um número relativamente pequeno de sessões concorrentes pode resultar na aquisição de um número surpreendentemente alto de bloqueios, mesmo que momentaneamente retidos. Isso é especialmente verdadeiro quando se considera que raramente é tão simples para o SQL Server quanto adquirir "um único bloqueio em uma única linha de dados de destino". Considere, por exemplo, que se uma modificação afeta uma coluna que faz parte de um índice não clusterizado, seja como uma coluna de chave ou uma coluna incluída, então o índice não clusterizado também deve ser alterado para refletir a alteração nos dados, e isso requer um bloqueio exclusivo adicional nas linhas ou páginas afetadas pela mudança.</p>

        <p>Em geral, no entanto, o SQL Server gerenciará tudo isso de forma transparente e escolherá automaticamente os modos e tipos de bloqueios apropriados para o nível de isolamento em uso, o tipo e número de operações sendo realizadas, entre outros fatores.</p>

        <p>Podemos colaborar nisso, por exemplo, escrevendo consultas SQL rápidas e eficientes, fornecendo índices úteis e utilizando o nível de isolamento menos restritivo compatível com os requisitos do negócio. Isso permitirá que o SQL Server adquira o número mínimo necessário de bloqueios, pelo menor tempo possível, minimizando assim bloqueios e maximizando o acesso concorrente. No entanto, além disso, raramente é aconselhável influenciar diretamente o tipo de bloqueios que o SQL Server adquire. Em ocasiões excepcionais, o SQL Server fornece algumas sugestões de bloqueio que podem ser utilizadas para especificar quais bloqueios o SQL Server adquire para determinadas operações e até mesmo, por exemplo, para "proibir" bloqueios de página e de linha em um índice específico. Essas opções serão discutidas mais adiante no capítulo, na seção de <a href="#">Resolução de Bloqueios</a>.</p>
        
        <h3 id="latches">Latches e conteção de latches</h3>

        <p>Latches podem ser considerados como bloqueios leves e de curta duração. Enquanto os bloqueios são utilizados para proteger a consistência lógica e transacional das linhas, os latches são geralmente usados para proteger a consistência física de páginas ou estruturas de memória. Existem três tipos de latches que podem ser encontrados no motor do SQL.</p>

        <p>Para mais detalhes, consulte <a href="http://blogs.msdn.com/b/psssql/archive/2009/07/08/q-a-onlatches-in-the-sql-server-engine.aspx" target="_blank">http://blogs.msdn.com/b/psssql/archive/2009/07/08/q-a-onlatches-in-the-sql-server-engine.aspx</a>:</p>

        <ul>
            <li><strong>Latch</strong> - utilizado para proteger várias estruturas de memória dentro do SQL Server.</li>
            <li><strong>Latch de Página</strong> - utilizado quando o SQL está modificando a estrutura da página. Portanto, quando o cabeçalho da página é modificado ou uma linha é adicionada a uma página, o SQL adquire um Latch de Página antes de começar e o libera após a conclusão.</li>
            <li><strong>Latch de E/S de Página</strong> - utilizado quando as páginas estão sendo movidas entre o disco e a memória. Assim, um Latch de E/S de Página seria adquirido antes que uma página seja buscada do disco e liberado uma vez que a página esteja em cache.</li>
        </ul>

        <p>Os latches (geralmente Latch de Página ou Latch de E/S de Página) podem causar bloqueios de maneira semelhante aos bloqueios. No entanto, como os latches geralmente têm curta duração, é muito mais raro encontrar bloqueios devido a latches do que devido a bloqueios.</p>

        <p>Os detalhes sobre as causas e resoluções para a contenção de latches estão fora do escopo deste capítulo, e alguns casos específicos são mencionados em outras partes do livro. Para mais informações, consulte <a href="http://sqlcat.com/sqlcat/b/whitepapers/archive/2011/07/05/diagnosing-and-resolving-latch-contention-on-sql-server.aspx" target="_blank">http://sqlcat.com/sqlcat/b/whitepapers/archive/2011/07/05/diagnosing-and-resolving-latch-contention-on-sql-server.aspx</a>.</p>
        
        <h2 id="lockmon">Monitoramento de Bloqueio</h2>

        <p>Nesta seção, abordaremos algumas das ferramentas e técnicas importantes que podem ser utilizadas para diagnosticar, solucionar e resolver problemas de bloqueio em um banco de dados do SQL Server. Vamos explorar técnicas que podem ser empregadas para resolver instâncias "ao vivo" de bloqueio, onde processos de negócios importantes estão impedidos de avançar, a função comercial normal é prejudicada, e os usuários finais (e gerentes) estão reclamando. Geralmente, nesses casos, o problema se manifesta como desempenho fraco ou tempos de espera dentro da aplicação.</p>

        <p>Quando o bloqueio está ocorrendo ativamente no momento em que você é notificado, existem várias DMVs (ou visões do sistema, no caso do SQL 2000) e procedimentos armazenados do sistema que podem ser utilizados para diagnosticar o problema. Também examinaremos maneiras de obter bloqueios cumulativos ou agregados e estatísticas de espera no log, para obter uma visão geral da gravidade do bloqueio dentro da instância.</p>

        <p>É claro que nosso objetivo final é monitorar possíveis problemas de bloqueio de forma contínua e lidar com eles antes que afetem os usuários finais. Para alcançar esse objetivo, passaremos a discutir o monitoramento contínuo, utilizando DMVs, notificações de eventos, e eventos como blocked_process_report e lock_escalation, para obter notificações automáticas quando um evento de bloqueio ocorre.</p>

        <p>Antes de começarmos, vale a pena observar brevemente a maneira como os vários bloqueios aparecem nas visões do sistema e DMVs, quando se apresentam como tipos de espera. O tipo de espera para bloqueios tem a forma <code>LCK_M_&lt;tipo de bloqueio&gt;</code>. Assim, uma espera para adquirir um bloqueio compartilhado aparece como <code>LCK_M_S</code> (observe que não há indicação da granularidade do bloqueio, apenas do tipo solicitado), uma espera por um bloqueio exclusivo aparecerá como <code>LCK_M_X</code>, e uma espera por um bloqueio de intenção compartilhada aparecerá como <code>LCK_M_IS</code>. Esse formato pode ser extrapolado para os outros tipos de bloqueio.</p>

        <h3 id="usesysproc">Usando sysprocesses (SQL Server 2000 e posterior)</h3>

        <p>No SQL Server 2000, podemos usar a visualização do sistema sysprocesses para encontrar processos de bloqueio e processos bloqueados, conforme mostrado na Listagem 6.1.</p>

        <div id="container">
            <pre><code>
<cls>SELECT</cls>  spid ,
        status ,
        blocked ,
        open_tran ,
        waitresource ,
        waittype ,
        waittime ,
        cmd ,
        lastwaittype
<cls>FROM</cls>    master.dbo.<com>sysprocesses</com>
<cls>WHERE</cls>   blocked <> 0
            </code></pre>
        </div>

        <p class="legenda"><strong>Listing 6.1</strong>: Using sysprocesses to find blocking.</p>

        <p>A coluna <code>Blocked</code> mostra o SPID que está causando o bloqueio, como mostrado na Figura 6.1, sendo o principal indicador de eventos de bloqueio. Ela terá um valor de 0 para qualquer sessão que não esteja bloqueada.</p>

        <img src="imagens/fig61.png" alt="blocking">

        <p class="legenda"><strong>Figura 6.1</strong>: O SPID 52 está bloqueando uma solicitação de bloqueio compartilhado pelo SPID 53.</p>

        <p>Observe que os procedimentos do sistema <code>sp_who</code> e <code>sp_who2</code> são simplesmente visões da visualização do sistema <code>sysprocesses</code> e podem ser usados de maneira semelhante. Uma vez que tenhamos os SPIDs das sessões de bloqueio e bloqueadas, podemos verificar o que estão executando usando o <code>DBCC INPUTBUFFER</code>, que retornará os primeiros 4.000 caracteres do lote que cada sessão está executando, conforme mostrado na Figura 6.2.</p>

        <img src="imagens/fig62.png" alt="DBCC INPUTBUFFER">

        <p class="legenda"><strong>Figura 6.2</strong>: Utilizando o <code>DBCC INPUTBUFFER</code> para retornar o texto das consultas envolvidas no bloqueio.</p>

        <p>Se quisermos saber quais bloqueios o SPID 52 está mantendo e que estão impedindo o SPID 53 de obter o bloqueio de leitura compartilhada que deseja, podemos consultar a tabela do sistema <code>syslockinfo</code> ou usar o procedimento armazenado do sistema <code>sp_lock</code>. Este último é menos críptico e muito mais fácil de entender.</p>

        <p>Se executarmos o procedimento <code>sp_lock</code> para o SPID 52, então, entre todos os outros bloqueios, podemos ver a partir da saída na Figura 6.3 que o SPID 52 possui um bloqueio <code>IX</code> na página <code>1:1961</code> no banco de dados <code>5</code>. Esta é a página à qual o SPID 53 está bloqueado de acessar, como visto na coluna <code>waitresource</code> em <code>sysprocesses</code> (Figura 6.1). O bloqueio <code>IX</code> mantido pelo SPID 52 não é compatível com o bloqueio S que o SPID 53 solicitou. Portanto, o SPID 53 deve aguardar até que esse bloqueio <code>IX</code> seja liberado antes de poder adquirir o bloqueio S que deseja.</p>

        <img src="imagens/fig63.pgn.PNG" alt="Figura 6.3: Utilizando o procedimento armazenado sp_lock.">

        <p class="legenda"><strong>Figura 6.3</strong>: Utilizando o procedimento armazenado sp_lock.</p>

        <p>Antes do SQL Server 2000 SP4, um SPID só seria exibido na coluna <code>blocked</code> na visualização <code>sysprocesses</code> se essa sessão estivesse causando espera por <strong>bloqueio</strong>. Pós-SP4, o SPID é mostrado para sessões que causam tanto espera por bloqueio quanto por <strong>latch</strong>; em outras palavras, se o SPID 53 estivesse aguardando para adquirir um latch em vez de um bloqueio, ele não apareceria na coluna <code>blocked</code> pré-SP4, mas apareceria pós-SP4.</p>

        <p>Na maioria dos casos, isso parece muito semelhante ao bloqueio, exceto que a coluna <code>waittype</code> mostra uma espera de Latch, Page Latch ou Page I/O Latch em vez de uma espera de <code>LCK</code>. Em alguns casos, especificamente em latches relacionados à E/S, o valor na coluna <code>blocked</code> é o valor para o SPID da sessão bloqueada em vez do SPID do bloqueador, então parece ser um bloqueio autoimposto.</p>

        <p>Para obter mais recursos sobre as alterações no bloqueio do SQL Server 2000 e na visualização do sistema <code>sysprocesses</code>, consulte: <em>A coluna blocked na tabela sysprocesses é populada para esperas de latches após a instalação do SQL Server 2000 SP4</em> em <a href="http://support.microsoft.com/kb/906344" target="_blank">http://support.microsoft.com/kb/906344</a>.</p>

        <h3 id="SQLPERF">Estatísticas acumulativas de espera com DBCC SQLPERF (waitstats)</h3>

        <p>No SQL Server 2000, as informações estatísticas acumulativas de espera para a instância estavam disponíveis apenas por meio do comando <code>DBCC SQLPERF(waitstats)</code>. Ele fornece o número total de tarefas em espera e o tempo total de espera desde que a instância foi iniciada ou desde que as estatísticas de espera foram limpas usando o comando <code>DBCC SQLPERF(waitstats, clear)</code>.</p>

        <p>Embora este comando não possa ajudar a diagnosticar problemas individuais de bloqueio, pode ser utilizado para obter uma visão geral dos waits mais comuns no sistema. Isso ajuda a garantir que o problema real seja investigado, em vez de algo que tenha sido erroneamente assumido como o problema. Quando o bloqueio é predominante em uma das bases de dados em execução em uma instância, um dos principais tipos de espera para a instância será um tipo de espera <code>LCK_*</code>, que é uma espera ao tentar adquirir um tipo específico de bloqueio.</p>

        <h3 id="dmvs">Visões de Gerenciamento Dinâmico (DMVs)</h3>

        <p>Embora a visualização do sistema <code>sysprocesses</code> e o comando <code>DBCC SQLPERF(waitstats)</code> ainda possam ser utilizados para encontrar bloqueios ativos no SQL Server 2005 e 2008, as Visões de Gerenciamento Dinâmico (DMVs) oferecem informações mais detalhadas para solucionar problemas de bloqueio.</p>
        
        <p>Para ver isso em ação, precisaremos criar um evento de bloqueio no banco de dados. Para os fins desta demonstração, estou utilizando o banco de dados <code>AdventureWorks</code> 2008 (disponível para download em <a href="http://sqlserversamples.codeplex.com/" target="_blank">http://sqlserversamples.codeplex.com/</a>).</p>
        
        <div id="container">
            <pre><code>
<cls>DECLARE</cls> @SalesOrderHeaderID <cls>INT</cls>

<cls>BEGIN </cls>TRANSACTION

<cls>INSERT INTO</cls> Sales.SalesOrderHeader
      (RevisionNumber, OrderDate, DueDate, ShipDate, Status,
      OnlineOrderFlag, PurchaseOrderNumber, AccountNumber, CustomerID,
      SalesPersonID, TerritoryID, BillToAddressID, ShipToAddressID,
      ShipMethodID, CreditCardID, CreditCardApprovalCode,
      CurrencyRateID, Comment, rowguid, ModifiedDate)
<cls>VALUES</cls>
     (5, <string>‘2011/06/20'</string>, <string>‘2011/06/25'</string>, <string>‘2011/06/30'</string>, 5, 0, <join>NULL</join>,
       <string>‘10-4030-018749'</string>, 18749, <join>NULL</join>, 6, 28374, 28374, 1, 8925,
       <string>‘929849Vi46003'</string>, <join>NULL</join>, <join>NULL</join>, <func>NEWID</func>(), <func>GETDATE</func>()
     )
<cls>SET</cls> @SalesOrderHeaderID = <func>@@IDENTITY</func>

<cls>INSERT  INTO</cls> Sales.SalesOrderDetail
        ( SalesOrderID, CarrierTrackingNumber, OrderQty, ProductID,
        SpecialOfferID, UnitPrice, UnitPriceDiscount, rowguid,
        ModifiedDate )
<cls>VALUES</cls>  ( @SalesOrderHeaderID, <string>‘4911-403C-98'</string>, 15, 722, 1, 2039.994, 0,
          <func>NEWID</func>(), <func>GETDATE</func>() ),
        ( @SalesOrderHeaderID, <string>‘4911-403C-98'</string>, 4, 709, 1, 5.70, 0,
          <func>NEWID</func>(), <func>GETDATE</func>() ),
        ( @SalesOrderHeaderID, <string>‘4911-403C-98'</string>, 24, 716, 1, 28.8404, 0,
          <func>NEWID</func>(), <func>GETDATE</func>() )
            </code></pre>
        </div>

        <p class="legenda"><strong>Listagem 6.2</strong>: Uma transação <code>INSERT</code> não confirmada no <code>AdventureWorks</code> 2008.</p>

        <p>Observe que deixei a transação não confirmada. Portanto, os bloqueios exclusivos obtidos nas duas tabelas ainda estão sendo mantidos. Para um exemplo realista, podemos dizer que há uma <code>SELECT</code> de longa duração após isso, ou algo mais que será executado por um tempo, ou talvez um erro tenha causado a interrupção do lote, deixando a transação aberta.</p>

        <p>Agora, abra uma nova janela do SSMS e conecte-se ao banco de dados <code>AdventureWorks</code> 2008. Execute um relatório simples em uma das tabelas que estavam envolvidas na transação <code>INSERT</code>.</p>

        <div id="container">
            <pre><code>
<cls>SELECT</cls>  FirstName ,
        LastName ,
        <func>SUM</func>(soh.TotalDue) <cls>AS</cls> TotalDue ,
        <func>MAX</func>(OrderDate) <cls>AS</cls> LastOrder
<cls>FROM</cls>    Sales.SalesOrderHeader AS soh
        <join>INNER JOIN</join> Sales.Customer <cls>AS</cls> c <cls>ON</cls> soh.CustomerID = c.CustomerID
        <join>INNER JOIN</join> Person.Person <cls>AS</cls> p <cls>ON</cls> c.PersonID = p.BusinessEntityID
<cls>WHERE</cls>   soh.OrderDate >= <string>‘2011/01/01'</string>
<cls>GROUP BY</cls> c.CustomerID ,
        FirstName ,
        LastName
            </code></pre>
        </div>

        <p class="legenda"><strong>Listagem 6.3</strong>: Uma consulta contra a tabela SalesOrderHeader.</p>

        <p>Imediatamente, perceberemos que a instrução <code>SELECT</code> vai "pendurar", enquanto, na ausência de bloqueio, ela seria concluída em milissegundos. Agora, vamos examinar as Visões de Gerenciamento Dinâmico (DMVs) para ver como detectaríamos isso se fosse um sistema real com um problema real de bloqueio.</p>

        <h4>Usando as DMVs sys.dm_exec_requests e sys.dm_exec_sessions</h4>

        <p>Um dos primeiros lugares para procurar é a DMV que mostra as tarefas atualmente em execução. Esta é a substituição para <code>sysprocesses</code> no SQL Server 2005 e acima, e mostra informações bastante semelhantes às que <code>sysprocesses</code> fornecia (e um pouco mais).</p>

        <p>O script na Listagem 6.4 mostrará uma lista de todas as sessões bloqueadas, bem como as sessões que as estão bloqueando. Isso pode ser muito útil quando há uma cadeia longa de bloqueios.</p>

        <div id="container">
            <pre><code>
<cls>SELECT</cls>  er.session_id ,
        <func>host_name</func> , <func>program_name</func> , original_login_name , er.reads ,
        er.writes ,er.cpu_time , wait_type , wait_time , wait_resource ,
        blocking_session_id , st.text
<cls>FROM</cls>    <com>sys.dm_exec_sessions</com> es
        <join>LEFT JOIN</join> <com>sys.dm_exec_requests</com> er
                     <cls>ON</cls> er.session_id = es.session_id
        <join>OUTER APPLY</join> <com>sys.dm_exec_sql_text</com>(er.sql_handle) st
<cls>WHERE</cls>   blocking_session_id > 0
<cls>UNION</cls>
<cls>SELECT</cls>  es.session_id , <func>host_name</func> , <func>program_name</func> , original_login_name ,
        es.reads , es.writes , es.cpu_time , wait_type , wait_time ,
        wait_resource , blocking_session_id , st.text
<cls>FROM</cls>    <com>sys.dm_exec_sessions</com> es
        <join>LEFT JOIN</join> <com>sys.dm_exec_requests</com> er
                     <cls>ON</cls> er.session_id = es.session_id
        <join>OUTER APPLY</join> <com>sys.dm_exec_sql_text</com>(er.sql_handle) st
<cls>WHERE</cls>   es.session_id IN ( <cls>SELECT</cls> blocking_session_id
                           <cls>FROM</cls> <com>sys.dm_exec_requests</com>
                           <cls>WHERE</cls> blocking_session_id > 0 )
            </code></pre>
        </div>

        <p class="legenda"><strong>Listagem 6.4</strong>: Encontrar bloqueios com sys.<code>dm_exec_requests</code> e sys.<code>dm_exec_sessions</code>.</p>

        <p>A saída desta consulta, para o bloqueio simulado que configuramos anteriormente, é mostrada na Figura 6.4.</p>

        <img src="imagens/fig64.png" alt="Detalhes de bloqueado e bloqueador">

        <p>Figura 6.4: Detalhes das sessões bloqueadas e bloqueadoras.</p>

        <p>Isso mostra a sessão bloqueada e bloqueadora. Os valores <code>NULL</code> visíveis na sessão bloqueadora (52) indicam que ela não está executando atualmente nenhuma consulta e, portanto, não possui nenhuma entrada em <code>sys.dm_exec_requests</code>. Podemos obter o último comando que ela executou consultando <code>sys.dm_exec_connections</code> e usando a coluna <code>most_recent_sql_handle</code> como parâmetro para <code>sys.dm_exec_sql_text</code>, conforme mostrado na Listagem 6.5.</p>

        <div id="container">
            <pre><code>
<cls>SELECT</cls>  ec.session_id ,
        ec.connect_time ,
        st.<cls>dbid AS</cls> DatabaseID ,
        st.objectid ,
        st.text
<cls>FROM</cls>    <com>sys.dm_exec_connections</com> ec
        <join>CROSS APPLY</join> <com>sys.dm_exec_sql_text</com>(ec.most_recent_sql_handle) st
<cls>WHERE</cls>   session_id = 207
            </code></pre>
        </div>

        <p class="legenda"><strong>Listagem 6.5</strong>: Encontrando o comando que causou o bloqueio via sys.dm_exec_connections.</p>
        
        <p>Isso é o suficiente para identificar a origem da consulta de bloqueio, a máquina, o nome de login e o nome da aplicação. Se esta foi uma consulta improvisada executada por alguém que simplesmente não sabe melhor, então a solução pode ser tão simples quanto pedir a essa pessoa para parar de executar a consulta e ensiná-la, para que o problema não se repita.</p>

        <p>Se a consulta está vindo de uma aplicação, então entre o nome da aplicação e o texto da consulta deve ser possível identificar a origem do código problemático com o objetivo de corrigi-lo (algumas opções de correção são apresentadas posteriormente no capítulo).</p>

        <h4>Using the sys.dm_os_waiting_tasks DMV</h4>
        
        <p>O DMV <code>sys.dm_os_waiting_tasks</code> é usado principalmente para exibir todas as tarefas em espera atualmente ativas ou bloqueadas. Para aproveitar ao máximo este DMV, faça um JOIN com o DMV <code>sys.dm_exec_requests</code> e utilize <code>CROSS APPLY</code> com <code>sys.dm_exec_sql_text</code>.</p>

        <div id="container">
            <pre><code>
<cls>SELECT</cls>  blocking.session_id <cls>AS</cls> blocking_session_id ,
        blocked.session_id <cls>AS</cls> blocked_session_id ,
        waitstats.wait_type <cls>AS</cls> blocking_resource ,
        waitstats.wait_duration_ms ,
        waitstats.resource_description ,
        blocked_cache.<cls>text AS</cls> blocked_text ,
        blocking_cache.<cls>text AS</cls> blocking_text
<cls>FROM</cls>    <com>sys.dm_exec_connections</com> <cls>AS</cls> blocking
        <join>INNER JOIN</join> <com>sys.dm_exec_requests</com> blocked
                    <cls>ON</cls> blocking.session_id = blocked.blocking_session_id
        <join>CROSS APPLY</join> <com>sys.dm_exec_sql_text</com>(blocked.<cls>sql_handle</cls>)
                                                      blocked_cache
        <join>CROSS APPLY</join> <com>sys.dm_exec_sql_text</com>(blocking.most_recent_sql_handle)
                                                      blocking_cache
        <join>INNER JOIN</join> <com>sys.dm_os_waiting_tasks</com> waitstats
                    <cls>ON</cls> waitstats.session_id = blocked.session_id
            </code></pre>
        </div>

        <p class="legenda"><strong>Listagem 6.6</strong>: Investigando bloqueios usando o DMV sys.dm_os_waiting_tasks.</p>

        <p>Os resultados para o nosso caso simulado de bloqueio são mostrados na Figura 6.5.</p>

        <img src="imagens/fig65.png" alt="Resultados da consulta sys.dm_os_waiting_tasks.">

        <p class="legenda"><strong>Figura 6.5</strong>: Resultados da consulta sys.dm_os_waiting_tasks.</p>

        <p>Nos resultados da consulta que considera qualquer correspondência ao ter uma entrada válida de <code>SPID</code> bloqueado para um <code>SPID</code> e uma entrada correspondente em <code>sys.dm_os_waiting_tasks</code>, podemos ver que a sessão 53 está sendo bloqueada pela sessão 52. Isso não nos fornece muitas informações adicionais em relação à consulta anterior (as colunas adicionais retornadas na seção anterior podem ser adicionadas aqui também e foram omitidas apenas por clareza), embora forneça mais detalhes sobre o recurso em que o bloqueio está ocorrendo.</p>

        <p>Poderíamos usar essas informações para ajudar a resolver o problema e evitá-lo de acontecer novamente. Para obter mais informações sobre <code>sys.dm_os_waiting_tasks</code>, consulte a documentação online (<a href="http://msdn.microsoft.com/en-us/library/ms188743.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/ms188743.aspx</a>).</p>

        <h4>Utilizando o DMV sys.dm_tran_locks</h4>

        <p>Este não é necessariamente o primeiro DMV que alguém consultaria ao diagnosticar bloqueios, pois certamente não é tão fácil de usar quanto os DMVs discutidos anteriormente. Este é o substituto para a tabela de sistema <code>syslockinfo</code>. Ele fornece uma imagem instantânea do estado de bloqueio em uma instância do SQL Server, abrangendo todas as bancos de dados. Retorna uma linha para cada <em>solicitação atualmente ativa ao gerenciador de bloqueio para um bloqueio que foi concedido ou está aguardando ser concedido</em>. As colunas fornecidas oferecem informações sobre o recurso no qual o bloqueio está sendo mantido (ou foi solicitado) e o proprietário da solicitação.</p>

        <p>O principal uso deste DMV é obter informações adicionais sobre os bloqueios mantidos por processos que se sabe estar bloqueando uns aos outros. Usando o Exemplo 6.7, podemos dar uma olhada nos bloqueios mantidos e solicitados pelos dois processos que já sabemos estar causando bloqueios.</p>

        <div id="container">
            <pre><code>
<cls>SELECT</cls>  request_session_id ,
        resource_type ,
        <func>DB_NAME</func>(resource_database_id) <cls>AS</cls> DatabaseName ,
        resource_associated_entity_id ,
        resource_description ,
        request_mode ,
        request_status
<cls>FROM</cls>    sys.dm_tran_locks <cls>AS</cls> dtl
<cls>WHERE</cls>   request_session_id <join>IN</join> ( 52, 53 )
        <join>AND</join> resource_type <join>NOT IN</join> ( <string>'DATABASE'</string>, <string>'METADATA'</string> )
            </code></pre>
        </div>

        <p class="legenda"><strong>Exemplo 6.7</strong>: Consultando o DMV <code>sys.dm_tran_locks</code>.</p>
        
        <p>Isso revela detalhes de todos os bloqueios mantidos e solicitados por essas duas sessões, conforme mostrado na Figura 6.6.</p>

        <img src="imagens/fig66.png" alt="Informações detalhadas de bloqueio do DMV sys.dm_tran_locks.">

        <p class="legenda"><strong>Figura 6.6</strong>: Informações detalhadas de bloqueio do DMV sys.dm_tran_locks.</p>
        
        <p>Apenas para essas duas consultas simples, existem 84 bloqueios no nível de objeto, página ou chave. É por isso que eu digo que este provavelmente não é o primeiro lugar para procurar, mas sim um local para buscar informações adicionais uma vez que um problema seja identificado.</p>

        <p>A linha destacada (o único bloqueio com status de espera) e a linha acima mostram o problema no exemplo simulado. A sessão 53 deseja um bloqueio compartilhado na página <code>1:1961</code>, mas a sessão 52 já possui um bloqueio <code>IX</code> (intenção exclusiva) nessa página e, como mencionado anteriormente, os bloqueios <code>IX</code> são compatíveis apenas com outros bloqueios de intenção, não com um bloqueio compartilhado. Portanto, a sessão 53 terá que aguardar até que a sessão 52 libere esse bloqueio <code>IX</code>.</p>

        <h4>Estatísticas acumuladas de espera usando sys.dm_os_wait_stats</h4>

        <p>A qualquer momento em que uma tarefa em execução é forçada a esperar por um recurso no mecanismo, o tempo gasto aguardando é rastreado, acumulativamente, pelo SQL Server 2005 (e versões posteriores), na visão de gerenciamento dinâmico (DMV) <code>sys.dm_os_wait_stats</code>. Os valores fornecidos neste DMV são totais em execução, acumulados em todas as sessões desde a última reinicialização do servidor ou desde que as estatísticas tenham sido reiniciadas manualmente usando o comando <code>DBCC SQLPERF</code>, conforme mostrado na Listagem 6.8.</p>

        <div id="container">
            <pre><code>
DBCC SQLPERF("sys.dm_os_wait_stats",CLEAR);
            </code></pre>
        </div>

        <p class="legenda"><strong>Listagem 6.8</strong>: Limpando as estatísticas de espera existentes usando DBCC SQLPERF.</p>

        <p>Embora as informações neste DMV não possam ser usadas por si só para diagnosticar problemas de bloqueio individuais, elas podem ser utilizadas para determinar se as esperas por bloqueio são uma das esperas mais comuns no sistema. Basta executar a consulta na <a href="cap03.html#lista32" target="_self"><em>Listagem 3.2 (Capítulo 3)</em></a> e procurar por altas incidências dos tipos de espera <code>LCK_*</code>, que indicam que uma tarefa teve que esperar que bloqueios mantidos por outra tarefa fossem liberados antes de continuar a execução. Por exemplo, após limpar as estatísticas de espera existentes, podemos recriar nossa simulação de bloqueio anterior (listagens 6.2 e 6.3). Ao repetidamente simular esse bloqueio, deveríamos observar contagens crescentes para o evento de espera <code>LCK_M_IX</code>, conforme mostrado na Figura 6.7.</p>

        <img src="imagens/fig67.PNG" alt="Investigando o evento de espera LCK_M_IX.">

        <p class="legenda"><strong>Figura 6.7</strong>: Investigando o evento de espera LCK_M_IX.</p>

        <p>Em geral, um tempo de espera elevado pode originar-se de uma única instância de espera elevada, de muitos processos com esperas individuais muito baixas ou de alguns processos com esperas moderadas. A visão de gerenciamento dinâmico (DMV) <code>sys.dm_os_wait_stats</code> pode fornecer uma visão do comportamento geral em toda a instância.</p>

        <h3 id="perfmon">Performance Monitor</h3>

        <p>Não vou entrar em muitos detalhes aqui, mas vale a pena observar que o Performance Monitor (PerfMon) possui diversos contadores que podem ser usados para monitorar bloqueios e bloqueios dentro de uma instância do SQL. Assim como as estatísticas de espera agregadas, os dados do PerfMon podem ser usados para indicar que pode haver um problema, mas são insuficientes por si só para identificar a causa do problema. Identificar a causa requer o uso das DMVs ou de alguns dos relatórios automatizados (discutidos a seguir). O principal uso desses contadores é estabelecer um nível de atividade básico para esses eventos, para que possamos determinar o comportamento "normal" e, assim, identificar rapidamente o comportamento anormal. Os principais contadores de interesse são <code>Avg Wait Time (ms)</code>, <code>Lock Waits/sec</code> e <code>Number of Deadlocks/sec</code>, como mostrado na Figura 6.8.</p>

        <p>O contador <code>Lock requests/sec</code> também pode ser rastreado, mas, como a aquisição de um grande número de bloqueios é um comportamento bastante normal no SQL Server, esse contador pode não fornecer informações valiosas por si só.</p>

        <img src="imagens/fig68.PNG" alt="">

        <p class="legenda"><strong>Figura 6.8</strong>: Monitorando os contadores do PerfMon relacionados a bloqueios.</p>

        <h2 id="autodetect">Automatização da Detecção e Notificação de Bloqueios</h2>

        <p>A detecção automática e notificação requer algum tipo de trabalho ou processo agendado que consulta o servidor em intervalos regulares. Embora isso seja eficaz na detecção de bloqueios, a execução de um processo contra o servidor consumirá recursos de processamento e deve ser feita estrategicamente para minimizar o impacto do processo na coleta das informações em si.</p>

        <p>No SQL Server 2000, a única opção nessa área era o procedimento <code>sp_blocker_pss80</code>, mas as coisas melhoraram significativamente no SQL Server 2005 e posterior, com o surgimento do <code>Blocked Process Report</code> e das classes de eventos <code>Lock Escalation</code>, juntamente com notificações de eventos.</p>

        <h3 id="spblockerpss80">O processo sp_blocker_pss80</h3>

        <p>No SQL Server 2000, a única opção disponível para detecção e notificação automatizadas era executar o procedimento <code>sp_blocker_pss80</code> usando um loop infinito com <code>WAITFOR DELAY</code>, ou um trabalho ou tarefa agendada com um intervalo muito curto. O procedimento <code>sp_blocker_pss80</code> registrará informações sobre o processo de bloqueio e o processo bloqueado, juntamente com a coleta da instrução batch e estatísticas de bloqueio e espera durante o evento de bloqueio.</p>

        <div class="dica">
            <p class="destaque">O processo sp_blocker_pss80</p>
            O <code>sp_blocker_pss80</code> é uma solução fornecida pela Microsoft para investigar bloqueios no SQL Server 7.0 e 2000, e está bem documentada. Para obter mais informações sobre a configuração e utilização desse processo, consulte o artigo da Base de Conhecimento (KB) 271509 em <a href="http://support.microsoft.com/kb/271509/" target="_blank">http://support.microsoft.com/kb/271509/</a>.
        </div>

        <p>Se o <code>sp_blocker_pss80</code> não for utilizado, é possível escrever um script personalizado usando <code>sysprocesses</code> ou <code>sp_who2</code> para realizar funções semelhantes.</p>

        <h3 id="sqltrace">SQL Trace</h3>

        <p>O SQL Trace é um recurso poderoso que permite a criação de rastreamentos de eventos dentro do SQL Server, utilizando um conjunto de stored procedures. Essas procedures são as mesmas que o SQL Profiler utiliza para executar seus rastreamentos. Os eventos que o SQL Trace coleta variam desde eventos de deadlock, comandos <code>ALTER</code>, segurança ou bloqueios, até eventos completos de lotes SQL. O SQL Trace deve ser utilizado apenas quando há a necessidade de capturar eventos para solucionar problemas. Eventos como <code>SP:Stmt*</code> ou <code>Lock*</code> ocorrerão com muita frequência em um servidor movimentado, e rastreamentos que capturam esses eventos consumirão muitos recursos para registrar todos os eventos.</p>
        
        <p>A solução de problemas de bloqueio com o SQL Trace pode ser extremamente eficaz quando usada estrategicamente para capturar tanto as consultas que estão sendo bloqueadas quanto aquelas que estão causando o bloqueio. Embora o relatório de processos bloqueados (discutido na próxima seção) tenha sido introduzido apenas no SQL Server 2005, o monitoramento de travas e estatísticas de consultas do SQL Trace no SQL Server 2000 ainda é uma ferramenta poderosa para encontrar e resolver bloqueios e outros eventos.</p>

        <p>A melhor maneira, com menor impacto nos recursos, de capturar rastreamentos é executar um rastreamento no lado do servidor, com a saída direcionada para um arquivo em um disco local rápido. A forma mais simples de criar um script do lado do servidor é usar o Profiler para configurar o rastreamento inicial e, em seguida, exportá-lo (todos os detalhes sobre como fazer isso estão no Capítulo 5). Para a detecção automática de bloqueios, o evento mais provável para rastrear é o relatório de processos bloqueados, embora o rastreamento de conclusão de declarações ou lotes, escalonamento de travas ou expiração de travas também possa ser útil. Novamente, tenha muito cuidado ao rastrear eventos que ocorrem com muita frequência, como <code>LockAcquired</code>, pois isso pode resultar em um rastreamento que tem um impacto severo no servidor.</p>

        <h4>O relatório de processos bloqueados</h4>

        <p>O relatório de processos bloqueados é implementado como um evento que é acionado quando uma tarefa não relacionada ao sistema é bloqueada por uma trava detectável por deadlock. Um evento é acionado toda vez que ocorre um bloqueio que ultrapassa a duração do valor limite, configurado pela opção "blocked process threshold" no <code>sp_configure</code>. A limitação de que deve ser uma trava detectável por deadlock decorre da implementação do evento no mecanismo de banco de dados, que utiliza o monitor de deadlock em segundo plano (abordado no próximo capítulo) para percorrer a lista de tarefas em espera que ultrapassam o limite definido.</p>

        <p>O valor padrão para a opção "blocked process threshold" é zero, o que significa que o mecanismo do banco de dados não realiza verificações adicionais de tarefas em espera e não gera os relatórios de processos bloqueados. O valor para a opção é um número inteiro entre 0 e 86.400 e determina o número de segundos que uma tarefa deve esperar por um recurso bloqueado antes que o relatório seja gerado. Múltiplos relatórios podem ser gerados para a mesma cadeia de bloqueio se o valor do limiar for ultrapassado várias vezes. Por exemplo, se definirmos o limiar para 5 segundos e uma tarefa for bloqueada por 18 segundos, serão gerados três relatórios de processos bloqueados. Para obter mais informações sobre como configurar e usar o evento de relatório de processos bloqueados, consulte <a href="http://www.simple-talk.com/content/article.aspx?article=671" target="_blank">http://www.simple-talk.com/content/article.aspx?article=671</a> ou <a href="http://bit.ly/qC6zz3" target="_blank">http://bit.ly/qC6zz3</a>.</p>

        <p>O Exemplo 6.9 mostra como habilitar o relatório de processos bloqueados e define o limiar para 2 segundos, utilizando o procedimento <code>sp_configure</code> (geralmente, esse valor seria considerado baixo para a maioria dos sistemas, mas eu o configurei assim apenas para fins de demonstração).</p>

        <div id="container">
            <pre><code>
<proc>sp_configure</proc> <string>‘show advanced options'</string>, 1
<cls>go</cls>
<cls>RECONFIGURE</cls>
<cls>go</cls>
<proc>sp_configure</proc> <string>‘blocked process threshold'</string>, 2
<cls>go</cls>
<cls>RECONFIGURE</cls>
<cls>go</cls>
            </code></pre>
        </div>

        <p class="legenda"><strong>Listing 6.9</strong>: Enabling the blocked process report and setting the threshold.</p>

        <p>O relatório de processos bloqueados pode ser capturado de várias maneiras. O SQL Server Profiler pode ser usado para capturar ativamente a classe de evento <code>Blocked Process Report</code>, ou alternativamente, você pode criar um script de rastreamento SQL do lado do servidor, usando as stored procedures <code>sp_trace_*</code>, conforme explicado anteriormente.</p>

        <p>Quando o limite de processos bloqueados é atingido, o rastreamento registrará o evento no arquivo de rastreamento. A função <code>fn_trace_gettable</code> pode ser usada para ler o arquivo em um formato tabular no SSMS, conforme mostrado na Figura 6.9.</p>

        <img src="imagens/fig69.PNG" alt="Lendo o relatório de processos bloqueados usando fn_trace_gettable.">

        <p class="legenda"><strong>Figura 6.9</strong>: Lendo o relatório de processos bloqueados usando fn_trace_gettable.</p>

        <p>Cada evento é registrado com o ID da sessão, o horário de término e, como mostrado na Figura 6.9, a duração do bloqueio. O ID da sessão tem pouco interesse, pois é o ID da tarefa do sistema que está verificando as tarefas em espera, não o das sessões bloqueadas ou bloqueadoras. No SSMS, clicar no XML abrirá uma nova janela com o XML formatado de maneira agradável. Na primeira linha da Figura 6.9, os resultados registrados são da simulação de bloqueio realizada anteriormente neste capítulo e são mostrados no Exemplo 6.10.</p>

        <div id="container">
            <pre><code>
&lt;<proc>blocked-process-report</proc>&gt;
  &lt;<proc>blocked-process</proc>&gt;
    &lt;<proc>process</proc> <string>id</string>="<cls>process5a4f708</cls>" <string>taskpriority</string>="<cls>0</cls>" <string>logused</string>="<cls>0</cls>" <string>waitresource</string>="<cls>PAGE:
5:1:1961</cls>" <string>waittime</string>="2143" <string>ownerId</string>="94338" <string>transactionname</string>="<cls>SELECT</cls>"
<string>lasttranstarted</string>="<cls>2011-08-24T18:43:59.553</cls>" <string>XDES</string>="<cls>0x84fbf1e0</cls>" <string>lockMode=</string>"<cls>S</cls>"
<string>schedulerid</string>="<cls>8</cls>" <string>kpid</string>="<cls>2588</cls>" <string>status</string>="<cls>suspended</cls>" <string>spid</string>="<cls>53</cls>" <string>sbid</string>="<cls>0</cls>" <string>ecid</string>="<cls>0</cls>"
<string>priority</string>="<cls>0</cls>" <string>trancount</string>="<cls>0</cls>" <string>lastbatchstarted</string>="<cls>2011-08-24T18:43:59.543</cls>"
<string>lastbatchcompleted</string>="<cls>2011-08-24T18:43:57.873</cls>" <string>clientapp</string>="<cls>Microsoft SQL Server
Management Studio - Query</cls>" <string>hostname</string>="<cls>AMachine</cls>" <string>hostpid</string>="<cls>4344</cls>" <string>loginname</string>="<cls>SomeLogin</cls>"
<string>isolationlevel</string>="<cls>read committed (2)</cls>" <string>xactid</string>="<cls>94338</cls>" <string>currentdb</string>="<cls>5</cls>"
<string>lockTimeout</string>="<cls>4294967295</cls>" <string>clientoption1</string>="<cls>671090784</cls>" <string>clientoption2</string>="<cls>390200</cls>"&gt;
      &lt;<proc>executionStack</proc>&gt;
        &lt;<proc>frame</proc> <string>line</string>="<cls>1</cls>" <string>sqlhandle</string>="<cls>0x02000000314f4a04e43e9f09208ee7f0f3b4ddd93bd13
3f8</cls>"/&gt;
      &lt;/<proc>executionStack</proc>&gt;
      &lt;<proc>inputbuf</proc>&gt;
SELECT FirstName, LastName,
    SUM(soh.TotalDue) AS TotalDue, MAX(OrderDate) AS LastOrder
  FROM Sales.SalesOrderHeader AS soh
    INNER JOIN Sales.Customer AS c ON soh.CustomerID = c.CustomerID INNER JOIN
Person.Person AS p ON c.PersonID = p.BusinessEntityID WHERE soh.OrderDate &gt;=
&apos;2011/01/01&apos;
  GROUP BY c.CustomerID, FirstName, LastName
      &lt;/<proc>inputbuf</proc>&gt;
    &lt;/<proc>process</proc>&gt;
  &lt;/<proc>blocked-process</proc>&gt;
  &lt;<proc>blocking-process</proc>&gt;
    &lt;<proc>process</proc> <string>status</string>="<cls>sleeping</cls>" <string><cls>spid</cls></string>="<cls>52</cls>" <string>sbid</string>="<cls>0</cls>" <string>ecid</string>="<cls>0</cls>" <string>priority</string>="<cls>0</cls>" <string>trancount</string>="<cls>1</cls>"
<string>lastbatchstarted</string>="<cls>2011-08-24T18:43:43.493</cls>" <string>lastbatchcompleted</string>="<cls>2011-08-
24T18:43:44.817</cls>" <string>clientapp</string>="<cls>Microsoft SQL Server Management Studio - Query</cls>"
<string>hostname</string>=" <cls>AMachine</cls> " <string>hostpid</string>="<cls>4344</cls>" <string>loginname</string>="<cls>SomeLogin</cls>" <string>isolationlevel</string>="<cls>read
committed (2)</cls>" <string>xactid</string>="<cls>93835</cls>" <string>currentdb</string>="<cls>5</cls>" <string>lockTimeout</string>="<cls>4294967295</cls>"
<string>clientoption1</string>="<cls>671090784</cls>" <string>clientoption2</string>="<cls>390200</cls>"&gt;
    &lt;<proc>executionStack</proc>/&gt;
    &lt;<proc>inputbuf</proc>&gt;
DECLARE @SalesOrderHeaderID INT

BEGIN TRANSACTION

INSERT INTO Sales.SalesOrderHeader
     (RevisionNumber, OrderDate, DueDate, ShipDate, Status,
      OnlineOrderFlag, PurchaseOrderNumber, AccountNumber, CustomerID,
      SalesPersonID, TerritoryID, BillToAddressID, ShipToAddressID,
      ShipMethodID, CreditCardID, CreditCardApprovalCode, CurrencyRateID,
      Comment, rowguid, ModifiedDate)
VALUES
    (5, &apos;2011/06/20&apos;, &apos;2011/06/25&apos;, &apos;2011/06/30&apos;, 5,
0, NULL,
       &apos;10-4030-018749&apos;, 18749, NULL, 6, 28374, 28374, 1, 8925,
       &apos;929849Vi46003&apos;, NULL, NULL, NEWID(), GETDATE()
      )
SET @SalesOrderHeaderID = @@IDENTITY

INSERT INTO Sales.SalesOrderDetail
     (SalesOrderID, CarrierTrackingNumber, OrderQty, ProductID,
       SpecialOfferID, UnitPrice, UnitPriceDiscount, rowguid,
       ModifiedDate)
VALUES
     (@SalesOrderHeaderID, &apos;4911-403C-98&apos;, 15, 722, 1, 2039.994, 0,
       NEWID(), GETDATE()),
     (@SalesOrderHeaderID, &apos;4911-403C-98&apos;, 4, 709, 1, 5.70, 0,
       NEWID(), GETD &lt;/inputbuf&gt;
    &lt;/<proc>process</proc>&gt;
  &lt;/<proc>blocking-process</proc>&gt;
&lt;/<proc>blocked-process-report</proc>&gt;
            </code></pre>
        </div>

        <p class="legenda"><strong>Exemplo 6.10</strong>: Saída do relatório de processos bloqueados.</p>
        
        <p>O processo bloqueado é exibido como a instrução <code>SELECT</code>, enquanto o processo de bloqueio é a transação aberta com <code>INSERT</code>s não confirmados.</p>

        <p>Alguns eventos de bloqueio podem ocorrer apenas periodicamente ao longo de um dia normal ou semana de operações no SQL Server. O relatório de processos bloqueados, capturado por uma trace do lado do servidor, pode ser usado para registrar automaticamente esses eventos. As informações da trace podem posteriormente ser importadas para o SQL e utilizadas no Reporting Services ou em outros containers de relatórios para análise e resolução desses tipos de problemas de desempenho.</p>

        <h3 id="eventnotif">Notificações de Eventos</h3>

        <p>Notificações de eventos estão disponíveis desde o SQL Server 2005 e oferecem a capacidade de capturar, em tempo real, a maioria dos eventos DDL (Data Definition Language) e eventos de rastreamento no SQL Server. As notificações de eventos utilizam filas do Service Broker para registrar os eventos que você deseja monitorar. Quando usadas em conjunto com o evento <code>BLOCKED_PROCESS_REPORT</code> e o evento <code>LOCK_ESCALATION</code> (apenas no SQL Server 2008), isso permite que instâncias de ambos os eventos sejam registradas assincronamente, à medida que ocorrem. Esse modelo assíncrono significa que o registro de eventos tem um impacto menor no desempenho geral do servidor em comparação com o uso do SQL Trace ou Profiler.</p>

        <p>Para configurar notificações de eventos, primeiro precisamos configurar e ativar o Service Broker no banco de dados que desejamos monitorar. Uma vez que o Service Broker estiver pronto, uma fila e um serviço, baseado na fila, serão criados. Por fim, podemos criar a notificação de evento que usará o serviço. Se ainda não o fez, ative o evento <code>BLOCKED_PROCESS_REPORT</code>, conforme mostrado na Lista 6.9. Em seguida, certifique-se de que o Service Broker esteja ativado, conforme mostrado na Lista 6.11.</p>

        <div id="container">
            <pre><code>
<cls>ALTER DATABASE</cls> AdventureWorks <cls>SET ENABLE_BROKER</cls>
<cls>GO</cls>
            </code></pre>
        </div>

        <p class="legenda"><strong>Listagem 6.11</strong>: Ativar o Service Broker.</p>
        
        <p>Configure a fila:</p>

        <div id="container">
            <pre><code>
<cls>CREATE QUEUE</cls> systemeventqueue
<cls>GO</cls>
            </code></pre>
        </div>

        <p class="legenda"><strong>Listagem 6.12</strong>: Criar a fila do Service Broker.</p>
        
        <p>Configure o serviço:</p>

        <div id="container">
            <pre><code>
<cls>CREATE SERVICE</cls> systemeventservice
<cls>ON QUEUE</cls> systemeventqueue ( [http://schemas.microsoft.com/SQL/Notifications/
PostEventNotification] )
<cls>GO</cls>
            </code></pre>
        </div>

        <p class="legenda"><strong>Listagem 6.13</strong>: Criar o serviço do Service Broker.</p>

        <p>Criar a notificação de evento no serviço:</p>

        <div id="container">
            <pre><code>
<cls>CREATE EVENT NOTIFICATION</cls> notification_blocking
<cls>ON SERVER</cls>
<cls>WITH FAN_IN</cls>
<cls>FOR</cls> blocked_process_report
<cls>TO SERVICE</cls> <string>'systemeventservice'</string>, <string>'current database'</string> ;
<cls>GO</cls>
            </code></pre>
        </div>

        <p class="legenda"><strong>Listagem 6.14</strong>: Criar a notificação de evento para eventos de bloqueio.</p>

        <p>Tudo o que resta agora é receber quaisquer mensagens de eventos bloqueados que estejam registradas na fila, convertendo a coluna <code>MESSAGE_BODY</code> para o formato XML, como mostrado na Lista 6.15.</p>

        <div id="container">
            <pre><code>
<cls>RECEIVE</cls> <func>CAST</func>(message_body <cls>AS XML</cls>), * <cls>FROM</cls> systemeventqueue
            </code></pre>
        </div>

        <p class="legenda"><strong>Listagem 6.15</strong>: Recuperando mensagens da fila do Service Broker.</p>

        <p>A saída desta consulta, para o exemplo de bloqueio que usamos ao longo do capítulo, é mostrada na Figura 6.10.</p>

        <img src="imagens/fig610.PNG" alt="Notificação de evento para o relatório de processo bloqueado">

        <p class="legenda"><strong>Figura 6.10</strong>: Notificação de evento para o relatório de processo bloqueado.</p>

        <p>Observe que várias entradas foram inseridas na fila, devido ao fato de termos definido o limite para o evento como dois segundos. Portanto, se um evento de bloqueio durasse dez segundos, cinco linhas únicas seriam registradas na <code>systemeventqueue</code>.</p>

        <p>Criar uma sessão de notificação de evento para o evento <code>LOCK_ESCALATION</code> é feito exatamente da mesma maneira, conforme mostrado na listagem 6.16.</p>

        <div id="container">
            <pre><code>
<cls>CREATE EVENT NOTIFICATION</cls> notification_lockescalation
<cls>ON SERVER</cls>
<cls>WITH</cls> FAN_IN
<cls>FOR lock_escalation</cls>
<cls>TO SERVICE</cls> <string>'systemeventservice'</string>, <string>'current database'</string> ;
<cls>GO</cls>
            </code></pre>
        </div>

        <p class="legenda"><strong>Listagem 6.16</strong>: Criar uma notificação de evento para eventos de escalonamento de bloqueio.</p>

        <h3 id="extendevent">Eventos Estendidos</h3>

        <p>No SQL Server 2008, não existem Extended Events para detectar bloqueios. No entanto, no Denali (a próxima grande versão do SQL Server), o evento <code>sqlserver.blocked_process_report</code> foi adicionado. Isso, assim como o evento de rastreamento de processo bloqueado e a notificação de evento de processo bloqueado, requer que a configuração do servidor, chamada <code>blocked process threshold</code>, seja definida usando <code>sp_configure</code>.</p>

        <p>A sessão Extended Event pode ser configurada com o assistente Denali Extended Events, conforme mostrado na Figura 6.11.</p>

        <img src="imagens/fig611.png" alt="Configurando uma sessão de Evento Estendido.">

        <p class="legenda"><strong>Figura 6.11</strong>: Configurando uma sessão de Evento Estendido.</p>

        <p>Os eventos podem ser enviados para um buffer de memória, como neste exemplo, mas em um ambiente de produção provavelmente seriam enviados para o disco, como fizemos ao usar o SQL Trace. Para monitoramento rápido, os dados também podem ser visualizados ao vivo, como mostrado na Figura 6.12.</p>

        <img src="imagens/fig612.png" alt="Visualizando dados do Evento Estendido.">
        
        <p class="legenda"><strong>Figura 6.12</strong>: Visualizando dados do Evento Estendido.</p>

        <p>Para obter mais informações sobre Extended Events, a série "Um XEvent por dia" de Jonathan é muito útil de ser lida: <a href="http://www.sqlskills.com/blogs/jonathan/category/XEvent-a-Day-Series.aspx" target="_blank">http://www.sqlskills.com/blogs/jonathan/category/XEvent-a-Day-Series.aspx</a>.</p>
        
        <h2 id="resolvingblocks">Resolvendo Bloqueios</h2>

        <p>A maneira pela qual resolvemos bloqueios variará dependendo do motivo específico do bloqueio e, em alguns casos, da versão e edição do SQL Server que está sendo utilizada. Como observado anteriormente neste capítulo, o bloqueio é mais frequentemente causado por consultas de longa duração que mantêm determinados bloqueios em uma linha, tabela, página ou até mesmo banco de dados. Nos casos em que declarações T-SQL estão causando a definição e a manutenção de bloqueios por longos períodos, a única resposta real para o problema é ajustar as consultas para garantir que elas sejam executadas o mais rápido possível. Isso pode não erradicar completamente o bloqueio, mas seu objetivo é certamente ver, por exemplo, uma redução significativa no número de eventos de relatório de processo bloqueado registrados, à medida que os bloqueios são adquiridos e liberados mais rapidamente, e menos instâncias de bloqueio alcançam o limite configurado para o evento.</p>

        <p>Para todos os bancos de dados e as aplicações que os utilizam, estão associados um conjunto específico de requisitos e tempos de resposta esperados. O que é considerado "normal" para uma aplicação pode ser considerado muito preocupante em outra. Por exemplo, uma aplicação pode acionar um processo longo que requer um bloqueio exclusivo em uma tabela durante toda a sua duração e ainda assim ser considerada uma parte aceitável dos procedimentos operacionais normais do negócio. Por outro lado, outro processo, um que nunca mantém bloqueios por mais do que alguns segundos, pode ser motivo de preocupação.</p>

        <p>Em resumo, antes de começar a ajustar, é necessário conhecer o comportamento normal e esperado, e como isso se reflete nos tempos de execução e períodos de bloqueio. Pode ser que seu limite de bloqueio esteja definido em um nível que está capturando eventos de bloqueio para processos que estão se comportando perfeitamente normalmente; certifique-se de que esse limite esteja configurado adequadamente para o seu sistema (consulte a Listagem 6.9).</p>

        <h3 id="baddb">Design de banco de dados ruim</h3>

        <p>Um banco de dados que está mal normalizado, de modo que as mudanças nos dados precisam ser feitas em vários lugares em vez de um único, resultará em transações que são executadas por mais tempo do que o necessário. Transações de modificação adquirem bloqueios exclusivos, e o risco de bloqueio aumenta quanto mais são adquiridos e quanto mais tempo são mantidos.</p>

        <p>Isso não é algo que seja facilmente corrigido depois que o banco de dados está em produção; a normalização adequada é uma questão que deve ser considerada durante a fase de design.</p>

        <div class="dica">
            <p class="destaque">Denormalização e sistemas OLTP.</p>
            As pessoas frequentemente afirmam que a denormalização de um banco de dados melhora o desempenho. A verdadeira história é que a denormalização pode melhorar o desempenho de leitura às custas do desempenho de escrita. Por isso, a denormalização pode ser útil para data warehouses ou sistemas de suporte à decisão, mas raramente é apropriada para sistemas do tipo OLTP.
        </div>

        <h3 id="inisolevel">Nível de isolamento inadequado.</h3>

        <p>Uma causa bastante comum de bloqueios graves é o uso de um nível de isolamento inadequadamente alto, muitas vezes sem o conhecimento do desenvolvedor da aplicação. Já vi mais de uma biblioteca de acesso a dados que, por padrão, solicita um nível de isolamento <code>SERIALIZABLE</code> ao se conectar ao SQL Server. Isso resulta em um grande número de linhas sendo bloqueadas por longos períodos, para praticamente qualquer operação. Em muitos casos, o grau de isolamento de transação necessário pela aplicação não justifica o uso de <code>SERIALIZABLE</code>; se estiver causando problemas, a aplicação precisa ser examinada para ver se o nível pode ser reduzido para <code>REPEATABLE READ</code> ou até mesmo <code>READ COMMITTED</code>, ou se um dos níveis de isolamento <code>SNAPSHOT</code> pode ser usado. Isso é algo que precisa ser avaliado caso a caso; não há um único nível de isolamento que seja apropriado para todas as aplicações.</p>
        
        <p>Uma das maneiras mais eficazes, no SQL Server 2005 ou superior, de lidar com aplicações e bancos de dados que são altamente propensos a bloqueios é usar o isolamento <code>READ COMMITTED SNAPSHOT</code> em todo o banco de dados, ou habilitar o isolamento <code>SNAPSHOT</code> e usá-lo nas áreas mais afetadas. O custo de manter o armazenamento de versão de linha no <code>TempDB</code> geralmente não é severo, especialmente diante das consideráveis vantagens de ter consultas de leitura que não bloqueiam escritores e vice-versa.</p>

        <p>É claro que testes precisam ser realizados antes de fazer uma mudança tão radical quanto a alteração de todo o banco de dados para <code>READ COMMITTED SNAPSHOT</code>, mas isso deve ser considerado seriamente ao lidar com uma aplicação propensa a bloqueios severos.</p>

        <h3 id="poorlyqueries">Consultas mal escritas</h3>

        <p>Consultas escritas de forma ineficiente manterão bloqueios por mais tempo do que o necessário. Quando várias dessas consultas são executadas simultaneamente, há uma boa chance de ocorrerem bloqueios severos. Cobrir completamente como escrever consultas eficientes exigiria pelo menos um livro por si só; dois bons exemplos são: <em>Inside SQL Server 2005 Query Tuning and Optimization</em> (<a href="http://www.amazon.com/Inside-Microsoft®-SQL-Server-2005/dp/0735621969" target="_blank">http://www.amazon.com/Inside-Microsoft®-SQL-Server-2005/dp/0735621969</a>) e <em>SQL Server 2008 Query Performance Tuning Distilled</em> (<a href="http://www.amazon.com/Server-Performance-Tuning-Distilled-Experts/dp/1430219025" target="_blank">http://www.amazon.com/Server-Performance-Tuning-Distilled-Experts/dp/1430219025</a>). Aqui, vamos nos ater a alguns princípios gerais:</p>

        <ul>
            <li>Mantenha as transações o mais curtas possível (mas não mais curtas que o necessário). Por exemplo, se um select não precisa ser executado dentro da transação, coloque-o fora.</li>
            <li>Certifique-se de que as colunas que são comparadas/juntadas tenham o mesmo tipo de dados para evitar problemas de conversão implícita.</li>
            <li>Mantenha as consultas o mais simples possível. Teste se dividir uma consulta complexa e usar tabelas temporárias para armazenar resultados intermediários será mais rápido ou não.</li>
            <li>Use métodos baseados em conjunto (set-based) sempre que possível. Eles são mais rápidos do que o processamento linha por linha na grande maioria dos casos.</li>
        </ul>
        
        <h3 id="missidx">Índices ausentes</h3>

        <p>Se o SQL estiver sem um índice que seria útil para a consulta, então essa consulta levará mais tempo para ser executada do que o necessário, mantendo bloqueios por mais tempo do que o necessário, e lerá mais dados do que é necessário, dessa forma, adquirindo e liberando muitos mais bloqueios do que faria na presença do índice. Isso aumenta as chances de a consulta bloquear outra consulta ou ser bloqueada ela mesma. Para mais informações sobre como prevenir, encontrar e corrigir índices duplicados e ausentes, consulte o <a href="cap05.html">Capítulo 5</a>.</p>

        <h3 id="desbadapp">Design de aplicação ruim</h3>

        <p>Frequentemente, um design de aplicação ruim impõe ao banco de dados um fluxo de processo que pode aumentar enormemente a ocorrência de eventos de bloqueio no banco de dados. Corrigir problemas causados pelo design da aplicação nunca é fácil, pois geralmente exige uma cooperação próxima entre DBAs, desenvolvedores e fornecedores. No entanto, se a aplicação for realmente a fonte do problema, isso precisa ser feito.</p>

        <p>Algumas das práticas clássicas de design de aplicativos que podem causar bloqueios são: entrada de usuário dentro de transações; aplicativos que leem muito mais informações do que precisam; e aplicativos excessivamente comunicativos. Vou dedicar alguns parágrafos a cada um.</p>

        <h4>Entrada do usuário dentro de transações</h4>

        <p>Isso acontece quando um aplicativo inicia uma transação, realiza algum trabalho e depois espera que o usuário confirme uma ação, ou insira dados, ou algo similar. Isso é potencialmente um problema sério, porque a transação permanece aberta e os bloqueios são mantidos até que o usuário tome alguma ação. Há inúmeras histórias de usuários saindo para almoçar ou indo embora no final do dia com transações ainda abertas e bloqueios mantidos no banco de dados, causando graves problemas de bloqueio.</p>
        
        <p>A solução é nunca permitir qualquer forma de interação do usuário dentro de uma transação de banco de dados. Uma transação de banco de dados deve ser iniciada e confirmada (ou revertida) em uma única operação no banco de dados.</p>

        <h4>Lendo dados em excesso</h4>

        <p>Há alguns anos, vi um aplicativo que, para obter um conjunto filtrado de linhas correspondentes de duas tabelas, buscava todo o conteúdo de ambas as tabelas para o front end, percorria-os para obter as linhas correspondentes e, em seguida, filtrava as que não precisava. Ele lia várias centenas de milhares de linhas do servidor de banco de dados para obter as dez linhas de que precisava.</p>
        
        <p>Isso causou enormes problemas, não menos importante pela enorme quantidade de bloqueios que isso gerou como resultado. A regra geral aqui é que um aplicativo deve ler apenas o necessário e nada mais. Deixe o banco de dados fazer o trabalho de junção e filtragem; para isso que ele é bom.</p>

        <h4>Aplicativos tagarelas</h4>

        <p>Se um aplicativo faz consultas repetidas e frequentes ao banco de dados para dados que ele já possui ou que realmente não precisa, isso pode causar sérias dificuldades, incluindo enormes problemas de bloqueio no banco de dados. Um exemplo disso seria um aplicativo que, em uma tela de pesquisa, dispara uma consulta ao banco de dados para cada tecla pressionada, em vez de quando o usuário concluiu a inserção dos detalhes da pesquisa necessária.</p>

        <h3 id="outhard">Hardware desatualizado</h3>

        <p>Em casos raros, hardware desatualizado, com capacidade insuficiente de CPU, memória e E/S de disco, será a causa dos problemas de bloqueio. Se todas as outras opções forem investigadas e os problemas de bloqueio persistirem, pode ser simplesmente que o aplicativo tenha superado seu hardware e você precisará fazer um upgrade.</p>

        <h2 id="lastresorts">Hints, Trace Flags e outros últimos recursos</h2>

        <p>Se nada mais funcionar, existem dicas e flags de rastreamento que influenciam o comportamento de bloqueio do SQL Server. Estes devem ser usados apenas como medidas temporárias de curto prazo, enquanto soluções mais permanentes são investigadas.</p>

        <h3 id="lckhint">Dicas de bloqueio</h3>

        <p>Existem várias dicas que afetam de várias maneiras como o SQL Server realiza bloqueios. Elas podem ser divididas em três grupos principais, conforme a seguir:</p>

        <ul>
            <li>dicas de nível de isolamento</li>
            <li>dicas de modo de bloqueio</li>
            <li>dicas de granularidade de bloqueio.</li>
        </ul>

        <h4>Dicas de nível de isolamento</h4>
        
        <p>As dicas de nível de isolamento alteram o nível de isolamento efetivo usado para bloqueios em uma tabela que está sendo acessada dentro de uma consulta. Essas dicas são por tabela, não para toda a consulta. As dicas de nível de isolamento disponíveis são as seguintes:</p>

        <ul>
            <li><strong>ReadUncommitted/Nolock</strong> – o nível de isolamento <code>READ UNCOMMITTED</code>.</li>
            <li><strong>ReadCommitted</strong> – o nível de isolamento <code>READ COMMITTED</code> usando bloqueios ou versões de linhas, dependendo da configuração <code>READ_COMMITTED_SNAPSHOT</code> no banco de dados.</li>
            <li><strong>ReadCommittedLock</strong> – o nível de isolamento <code>READ COMMITTED</code>, usando bloqueios.</li>
            <li><strong>RepeatableRea</strong>d – o nível de isolamento <code>REPEATABLE READ</code>.</li>
            <li><strong>Serializable</strong> – o nível de isolamento <code>SERIALIZABLE</code>.</li>
        </ul>

        <h4>Dicas de modo de bloqueio</h4>

        <p>As dicas de modo de bloqueio da tabela ditam um modo (por exemplo, compartilhado, atualização, exclusivo) para os bloqueios tomados na tabela durante o processamento de uma consulta. Existem apenas dois tipos de dicas de modo de bloqueio:</p>

        <ul>
            <li><code>UPDLOCK</code> – toma bloqueios naquela tabela como bloqueios de <code>Update (U)</code>.</li>
            <li><code>XLOCK</code> – toma bloqueios naquela tabela como bloqueios <code>Exclusives (X)</code>.</li>
        </ul>

        <p>Um ponto muito importante a ser observado é que essa dica apenas especifica o modo mais baixo (ou seja, menos restritivo) que pode ser usado; o SQL pode e irá adotar um modo de bloqueio mais alto, se necessário. Por exemplo, se uma tabela em uma consulta <code>DELETE</code> recebe a dica <code>UPDLOCK</code> e essa é a tabela da qual as linhas estão sendo excluídas, o SQL ainda tomará bloqueios exclusivos, pois um bloqueio de atualização não é suficiente para uma exclusão.</p>

        <p>O principal uso dessas dicas é tomar bloqueios mais restritivos em consultas de leitura para reduzir a chance de deadlocks mais tarde em uma transação.</p>

        <h4>Dicas de granularidade de bloqueio</h4>

        <p>As dicas de granularidade de bloqueio ditam ao SQL Server a granularidade do bloqueio que deve ser inicialmente tomado em uma determinada tabela. O SQL ainda está livre para escalar bloqueios, se necessário. As dicas de granularidade de bloqueio são as seguintes:</p>
        
        <ul>
            <li><code>ROWLOCK</code> – os bloqueios naquela tabela começam como bloqueios de linha.</li>
            <li><code>PAGLOCK</code> – os bloqueios naquela tabela começam como bloqueios de página.</li>
            <li><code>TABLOCK</code> – os bloqueios naquela tabela começam como bloqueios de tabela.</li>
        </ul>

        Também existe uma dica <code>TABLOCKX</code> que é equivalente a uma combinação de <code>TABLOCK</code> e <code>XLOCK</code>.
        
        <h4>Opções de bloqueio de índice</h4>

        <p>Existem duas opções relacionadas a bloqueio que podem ser definidas em índices e ambas estão ATIVADAS por padrão.</p>
        
        <ul>
            <li><code>ALLOW_ROW_LOCKS</code></li>
            <li><code>ALLOW_PAGE_LOCKS</code></li>
        </ul>

        <p>Essas duas opções controlam se as granularidades específicas de bloqueio podem ser aplicadas ao índice. Se <code>ALLOW_ROW_LOCKS</code> estiver <code>OFF</code>, o SQL Server só pode tomar bloqueios de nível de página e tabela nesse índice. Se <code>ALLOW_PAGE_LOCKS</code> estiver <code>OFF</code>, o SQL Server só pode tomar bloqueios de nível de linha e tabela nesse índice. Se ambos estiverem <code>OFF</code>, o SQL só poderá tomar bloqueios de nível de tabela.</p>

        <p>Existem poucas razões válidas para mexer nessas opções e elas nunca devem ser alteradas sem testes significativos, pois haverá efeitos colaterais. Por exemplo, um índice que tem <code>ALLOW_PAGE_LOCKS</code> definido como <code>OFF</code> não pode ser reorganizado, apenas reconstruído.</p>

        <p>Às vezes, desabilitar bloqueios de linha em índices pode resolver deadlocks causados por pesquisas de chaves, mas isso de forma alguma é uma correção garantida. Outra razão para desabilitar bloqueios de página é quando há <code>INSERTs</code> de única linha muito, muito frequentes na tabela e há contenção no gerenciador de bloqueios, conforme descrito em <a href="http://blog.kejser.org/2011/05/30/diagnosing-and-fixing-sos_object_store-spins-for-singleton-inserts/" target="_blank">http://blog.kejser.org/2011/05/30/diagnosing-and-fixing-sos_object_store-spins-for-singleton-inserts/</a>.</p>
        
        <h4>Trace Flags 1211 e 1224</h4>
        
        <p>Se a escalonamento de bloqueio for persistente e problemático, o processo de escalonamento de bloqueio pode ser alterado usando as flags de rastreamento 1211 e 1224.</p>

        <p>A Flag de Rastreamento 1211 fornece a capacidade de desativar o escalonamento de bloqueio completamente. Esta Flag de Rastreamento deve ser usada apenas se todas as outras tentativas de solucionar problemas com o escalonamento de bloqueio tiverem falhado. Desabilitar o escalonamento de bloqueio em si pode causar impacto no SQL Server, permitindo muitos bloqueios de baixo nível e causando bloqueios prolongados. Se a memória de bloqueio crescer para 60% do total de memória alocada dinamicamente, as solicitações de bloqueio adicional falharão.</p>

        <p>A Flag de Rastreamento 1224 é mais flexível do que a 1211, pois restringe o escalonamento de bloqueio no nível da instrução e baseia-se apenas no número de bloqueios que estão sendo mantidos. No entanto, o SQL Server ainda tem a flexibilidade de escalonar bloqueios se a memória bloqueada exceder 40% da memória total. Essas Flags de Rastreamento devem ser habilitadas apenas após cuidadosa consideração e testes, e quaisquer instâncias com elas habilitadas precisam ser monitoradas cuidadosamente. Com a Flag de Rastreamento 1211, em particular, é possível que o SQL Server fique sem memória de bloqueio porque não pode escalonar bloqueios. Se isso acontecer, nenhum bloqueio adicional pode ser feito e cada consulta contra essa instância do SQL falhará, com a seguinte mensagem, até que alguma memória de bloqueio esteja disponível.</p>

        <div id="container">
            <pre><code>
Server: Msg 1204, Level 19, State 1, Line 1
The SQL Server cannot obtain a LOCK resource at this time. Rerun your statement
when there are fewer active users or ask the system administrator to check the SQL
Server lock and memory configuration.
            </code></pre>
        </div>

        <p>Para obter mais informações sobre como definir essas e outras Flags de Rastreamento, consulte: <a href="http://msdn.microsoft.com/en-us/library/ms188396.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/ms188396.aspx</a>.</p>
        
        <h2 id="resumo">Resumo</h2>
        
        <p>O bloqueio é um dos problemas de desempenho mais comuns no SQL Server. Com as ferramentas e etapas de monitoramento abordadas, o bloqueio pode ser rapidamente identificado e resolvido. Os administradores de banco de dados devem sempre monitorar ativamente o bloqueio, especialmente quando novas consultas e aplicativos são adicionados ao SQL Server em resposta a novos requisitos de negócios.</p>
    </main>    

    <div id="topo">
        <a href="#" target="_self"><i class="material-symbols-outlined">stat_2</i></a>
    </div>

    <footer>
        <p>Criado por Agnaldo Mota</p>
    </footer>

    <script src="scripts/script.js"></script>
</body>
</html>