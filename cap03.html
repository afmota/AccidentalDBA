<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBA Acidental</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <main>
        <h1>Capítulo 3: Utilização Elevada da CPU</h1>
        <p>Um sistema dependente da CPU é relativamente fácil de identificar, mas nem sempre é tão fácil de diagnosticar. Se você perceber que uma ou mais CPUs estão trabalhando próximo à capacidade máxima, juntamente com uma diminuição drástica no desempenho do servidor, então provavelmente há um problema com a CPU. A CPU está envolvida em quase todas as atividades do SQL Server, desde a execução de consultas até a movimentação de dados dentro e fora da memória, e assim por diante, o que significa que uma CPU sobrecarregada pode ter consequências graves.</p>
        <p>Infelizmente, a origem da pressão sobre a CPU nem sempre é fácil de identificar, uma vez que o que parece ser um problema da CPU pode ter sua causa raiz em outro lugar, como memória insuficiente, fazendo com que o SQL Server mova constantemente os dados dentro e fora da memória, consultas mal escritas, indexação inadequada ou até mesmo configurações inapropriadas de opções de configuração. A fonte da pressão sobre a CPU também pode ser um processo não relacionado ao SQL Server em execução no servidor.</p>
        <p>Independentemente do que tenha causado o problema, o objetivo da fase de investigação para solucionar a utilização excessiva da CPU no SQL Server é isolar o problema em uma fonte específica. Geralmente, isso exigirá a coleta de várias informações, usando ferramentas como o Monitor de Desempenho (PerfMon), SQLTrace e várias das Visualizações de Gerenciamento Dinâmico do SQL Server.</p>
        <p>Uma vez confirmado que o alto uso da CPU é devido ao processo do SQL Server, e o problema foi isolado para uma consulta específica (ou conjunto de consultas), podemos buscar aliviar a pressão da CPU por meio de mudanças no design, como ajustar consultas que consomem muita CPU, adicionar índices apropriados, substituir consultas SQL improvisadas por stored procedures para melhorar a reutilização de planos e assim por diante, ou ajustar as configurações de configuração do SQL Server e do Windows.</p>
        <h2>Investigando a Pressão da CPU</h2>
        <p>Nesta seção, discutiremos as três principais ferramentas usadas para medir o uso da CPU e diagnosticar a pressão da CPU no SQL Server:</p>
        <ul>
            <li><strong>Performance Monitor</strong> - uma ferramenta de monitoramento do Windows para medir o uso da CPU pelo SQL Server e outros processos em execução no servidor.</li>
            <li><strong>SQLTrace</strong> - um conjunto de stored procedures do sistema para rastrear eventos em tempo real que estão sendo executados no SQL Server durante períodos de alto uso da CPU.</li>
            <li><strong>Dynamic Management Views</strong> - uma coleção de objetos do sistema que fornecem dados instantâneos e agregados sobre o uso de recursos no SQL Server.</li>
        </ul>
        <h3>Performance Monitor</h3>
        <p>Se o seu sistema SQL Server estiver enfrentando uma atividade excessivamente alta da CPU, a primeira ferramenta à qual você deve recorrer é o <strng>Performance Monitor</strng> (PerfMon). Essa ferramenta de monitoramento do Windows irá confirmar se o uso excessivo da CPU é devido à atividade do SQL Server ou se é causado por outros processos no servidor ou pelo próprio sistema operacional. Não faz sentido gastar tempo e energia valiosos investigando o SQL Server por uso excessivo da CPU se a causa raiz for um processo não relacionado ao SQL Server.</p>
        <p>Os principais contadores do PerfMon que são úteis para monitorar o uso da CPU são listados abaixo com breves explicações (citadas do MSDN):</p>
        <ul>
            <li><strong>Processor/ %Privileged Time</strong> - <em>porcentagem de tempo que o processador gasta na execução de comandos do kernel do Microsoft Windows, como atividade principal do sistema operacional e drivers de dispositivos.</em></li>
            <li><strong>Processor/ %User Time</strong> - <em>porcentagem de tempo que o processador gasta executando processos do usuário, como o SQL Server. Isso inclui solicitações de E/S do SQL Server.</em></li>
            <li><strong>Process (sqlservr.exe)/ %Processor Time</strong> - <em>a soma do tempo do processador em cada processador para todos os threads do processo.</em></li>
        </ul>
        <p>Basta abrir o PerfMon (<strong>Painel de Controle | Sistema e Segurança | Ferramentas Administrativas</strong>), clicar no botão <strong>Adicionar</strong> (representado por uma cruz verde) e adicionar os contadores, conforme mostrado na Figura 3.1.</p>
        <img src="imagens/addcounters.PNG" alt="Adicionando contadores">
        <p><strong>Figura 3.1</strong>: Adicionando contadores de CPU no PerfMon.</p>
        <p>Esses três contadores são suficientes para monitorar o uso geral da CPU, bem como o uso pelo SQL Server. No entanto, existem vários contadores de <code>SQL Statistics</code> (e um contador de Cache de Plano) que não monitoram diretamente o uso da CPU, mas monitoram eventos como eventos de compilação e recompilação, que podem consumir muitos ciclos de CPU ou são indicações de problemas que causam alto uso da CPU. Esses contadores são simplesmente listados aqui e discutidos em mais detalhes posteriormente no capítulo, em relação direta com os problemas que eles podem ser usados para investigar.</p>
        <ul>
            <li><strong>SQLServer:SQL Statistics/Auto-Param Attempts/sec</strong></li>
            <li><strong>SQLServer:SQL Statistics/Failed Auto-params/sec</strong></li>
            <li><strong>SQLServer:SQL Statistics/Batch Requests/sec</strong></li>
            <li><strong>SQLServer:SQL Statistics/SQL Compilations/sec</strong></li>
            <li><strong>SQLServer:SQL Statistics/SQL Re-Compilations/sec</strong></li>
            <li><strong>SQLServer:Plan Cache/Cache hit Ratio</strong></li>
        </ul>
        <p>Nenhum desses contadores possui limites rígidos que indicam valores "bons" ou "ruins"; em vez disso, eles devem ser avaliados em relação ao que é considerado normal para o sistema em questão, e se um determinado valor estiver muito fora da faixa normal, a causa deve ser investigada mais a fundo.</p>
        <p><strong><em>Uso do processador em máquinas virtuais</em></strong></p>
        <p><em>Em uma máquina virtual (VM), o </em><code>%ProcessorTime</code> <em>é a porcentagem dos recursos alocados para a VM que está sendo utilizada, e não a porcentagem alocada ao hardware real. Portanto, se a VM tiver sido alocada com recursos de CPU muito mínimos, o PerfMon pode mostrar um </em><code>%ProcessorTime</code> <em>muito alto, mesmo que as CPUs reais estejam sendo pouco utilizadas. Um dos primeiros passos ao investigar alto uso da CPU em uma máquina virtual é verificar o uso de hardware da máquina virtual como um todo e garantir que as alocações de recursos sejam razoáveis.</em></p>
        <h3>SQL Trace</h3>
        <p>A ferramenta Profiler incluída no SQL Server pode ser usada para examinar os detalhes dos comandos que estão sendo executados em um servidor SQL. É uma ferramenta útil para investigar os detalhes de problemas específicos depois que o problema geral foi identificado. A interface gráfica do Profiler faz uso de um conjunto de stored procedures, conhecidas coletivamente como <strong>SQL Trace</strong>. A própria interface gráfica deve ser usada com cautela em servidores mais movimentados, pois pode ter um efeito adverso no desempenho geral e na estabilidade do servidor. Em vez disso, deve-se executar um trace no lado do servidor, com a saída direcionada para um arquivo em uma unidade local rápida.</p>
        <p>O principal uso do SQL Trace é identificar consultas específicas que estão consumindo grandes quantidades de CPU. É menos útil para uma análise pontual do que as Dynamic Management Views, sendo mais útil para capturar cargas de trabalho para análise. Com as Dynamic Management Views (como <code>sys.dm_exec_requests</code>), é possível acompanhar o aumento do uso de recursos enquanto a consulta ainda está em execução, enquanto com o SQL Trace, a instrução ou lote deve ser concluído antes que o evento que mostra o uso total de recursos seja acionado.</p>
        <p>Para capturar um conjunto de consultas que estão usando quantidades excessivas de CPU, é necessário executar um trace durante períodos de alto uso da CPU. Os detalhes sobre como configurar e executar um trace são apresentados no <em>Capítulo 5</em> e não serão repetidos aqui. A consideração adicional ao executar um trace para investigar consultas que consomem grandes quantidades de <strong>CPU</strong> é adicionar um filtro na coluna de CPU para evitar capturar um grande número de consultas sem interesse.</p>
        <h3>Dynamic Management Views (DMVs)</h3>
        <p>Várias Dynamic Management Views (DMVs) fornecem uma variedade de informações que podem ajudar a diagnosticar problemas relacionados à CPU. Essas informações incluem estatísticas de desempenho agregadas das consultas, estatísticas de espera agregadas, detalhes do que está sendo executado, o que está esperando tempo de processamento, o que está esperando por outros recursos e outras informações que são difíceis ou impossíveis de obter de outra forma. Podemos investigar o alto uso da CPU pelo SQL Server examinando as estatísticas de espera relacionadas à CPU, os detalhes do escalonador e as estatísticas de desempenho agregadas das consultas, da seguinte forma:</p>
        <ul>
            <li>Verificar a extensão da pressão da CPU por meio de esperas de sinal, usando <code>sys.dm_os_wait_stats</code>.</li>
            <li>Diagnosticar um sistema com restrição de CPU de acordo com os tipos de espera observados, usando <code>sys.dm_os_wait_stats e sys.dm_os_schedulers</code>.</li>
            <li>Identificar planos em cache com alto uso de CPU e consultas associadas, usando <code>sys.dm_exec_query_stats e sys.dm_exec_sql_text</code>.</li>
            <li>Identificar tarefas atualmente em espera, especialmente aquelas que estão esperando por tipos de espera relacionados à CPU, usando <code>sys.dm_os_waiting_tasks</code>.</li>
            <li>Observar o uso de recursos das consultas em execução atualmente com <code>sys.dm_exec_requests</code>.</li>
        </ul>
        <h2>Investigando estatísticas de espera relacionadas à CPU</h2>
        <p>Sempre que uma sessão precisa esperar antes que o trabalho solicitado possa continuar, o SQL Server registra o motivo da espera (o recurso pelo qual está esperando) e o tempo de espera. A DMV <code>sys.dm_os_wait_stats</code> expõe essas estatísticas de espera, agregadas em todas as sessões desde a última reinicialização do servidor ou desde a última vez em que as estatísticas de espera foram apagadas com o comando <code>DBCC SQLPERF('sys.dm_os_wait_stats', CLEAR)</code>. Essa DMV pode ser usada, entre outras coisas, para confirmar a pressão da CPU e estabelecer os tipos de espera mais comuns que um sistema com restrição de CPU está enfrentando.</p>
        <p>Vale ressaltar que algumas ferramentas de monitoramento de terceiros dependem das estatísticas nesta DMV não serem apagadas entre reinicializações do servidor, pois, se forem apagadas, isso pode afetar a precisão das informações exibidas por essas ferramentas de monitoramento.</p>
        <h3>Tempo de espera do sinal</h3>
        <p>Junto com uma coluna <code>wait_type</code>, que indica o tipo de espera, o DMV <code>sys.dm_os_wait_stats</code> retorna vários tempos de espera úteis, incluindo:</p>
        <ul>
            <li><strong><code>wait_time_ms</code></strong> - quantidade total de tempo que as tarefas esperaram por este determinado tipo de espera; esse valor inclui o tempo na coluna <code>signal_wait_time_ms</code>. O valor aumenta a partir do momento em que uma tarefa interrompe a execução para esperar por um recurso até o momento em que ela retoma a execução.</li>
            <li><strong><code>signal_wait_time_ms</code></strong> - a quantidade total de tempo que as tarefas levam para começar a executar após serem sinalizadas (ou seja, após o recurso pelo qual estavam esperando estar disponível); esse é o tempo gasto na fila de execução e é uma espera puramente da CPU.</li>
        </ul>
        <p>Se o tempo de espera do sinal for uma parte significativa do tempo total de espera, significa que as tarefas estão aguardando um tempo relativamente longo para retomar a execução após os recursos pelos quais estavam esperando ficarem disponíveis. Isso pode indicar que há muitas consultas intensivas de CPU, que podem precisar de otimização, ou que o servidor precisa de mais CPU. A consulta no Exemplo 3.1 fornecerá uma medida de quanto do tempo total de espera é o tempo de espera do sinal.</p>
        <pre>
            <code>
        SELECT  SUM(signal_wait_time_ms) AS TotalSignalWaitTime ,
            ( SUM(CAST(signal_wait_time_ms AS NUMERIC(20, 2)))
              / SUM(CAST(wait_time_ms AS NUMERIC(20, 2))) * 100 )
                             AS PercentageSignalWaitsOfTotalTime
        FROM    sys.dm_os_wait_stats
            </code>
        </pre>
        <p><strong>Exemplo 3.1</strong>: Verificando a pressão da CPU por meio do tempo de espera do sinal.</p>
        <p>Como esta exibição de gerenciamento de espera (DMV) mostra tempos de espera e contagens agregadas desde que as estatísticas foram zeradas ou desde que o servidor foi iniciado, uma visualização pontual das estatísticas de espera geralmente não é muito útil. O que é mais útil é comparar as estatísticas de espera em um determinado momento com as estatísticas em um momento anterior e ver como elas mudaram. A outra opção é zerar as estatísticas de espera da DMV, usando <code>DBCC SQLPERF("sys.dm_os_wait_stats",CLEAR);</code>, esperar um pouco e, em seguida, fazer consultas para ver o que se acumulou nesse período de tempo conhecido e definido.</p>
        <p><strong><em>Acompanhando esperas em nível de sessão e instrução</em></strong></p>
        <p><em>Como os tempos de espera nesta DMV são agregados, é difícil relacionar um tempo de espera a uma consulta específica, a menos que você esteja em um sistema de teste com apenas uma sessão em execução. No entanto, no SQL Server 2008, é possível fazer isso se você usar Eventos Estendidos (Extended Events). Veja o meu artigo no blog: <a href="http://sqlblog.com/blogs/jonathan_kehayias/archive/2010/12/30/an-xevent-a-day-30-of-31-tracking-session-and-statement-level-waits.aspx" target="_blank" rel="external">http://sqlblog.com/blogs/jonathan_kehayias/archive/2010/12/30/an-xevent-a-day-30-of-31-tracking-session-and-statement-level-waits.aspx</a>.</em></p>
        <p>Também podemos usar a DMV <code>sys.dm_os_wait_stats</code> para descobrir quais são as esperas de recursos mais comuns em nosso sistema com restrição de CPU, como mostrado no Exemplo 3.2, onde identificamos os principais eventos de espera, ordenados de acordo com a quantidade total de tempo que os processos esperaram (<code>wait_time_ms</code>) nesse evento. É importante ignorar as esperas benignas, normalmente causadas por processos do sistema que se espera que estejam esperando a maior parte do tempo. Também estamos subtraindo o <code>signal_wait_time</code>, pois essa parte do tempo de espera não está esperando pelo recurso específico, mas esperando por tempo no agendador.</p>
        <pre>
            <code>
        SELECT TOP ( 10 )
            wait_type ,
            waiting_tasks_count ,
            ( wait_time_ms - signal_wait_time_ms ) AS resource_wait_time ,
            max_wait_time_ms ,
            CASE waiting_tasks_count
              WHEN 0 THEN 0
              ELSE wait_time_ms / waiting_tasks_count
            END AS avg_wait_time
        FROM    sys.dm_os_wait_stats
        WHERE   wait_type NOT LIKE '%SLEEP%' -- remove eg. SLEEP_TASK and
                                         -- LAZYWRITER_SLEEP waits
            AND wait_type NOT LIKE 'XE%'
            AND wait_type NOT IN -- remove system waits
        ( 'KSOURCE_WAKEUP', 'BROKER_TASK_STOP', 'FT_IFTS_SCHEDULER_IDLE_WAIT',
          'SQLTRACE_BUFFER_FLUSH', 'CLR_AUTO_EVENT', 'BROKER_EVENTHANDLER',
          'BAD_PAGE_PROCESS', 'BROKER_TRANSMITTER', 'CHECKPOINT_QUEUE',
          'DBMIRROR_EVENTS_QUEUE', 'SQLTRACE_BUFFER_FLUSH', 'CLR_MANUAL_EVENT',
          'ONDEMAND_TASK_QUEUE', 'REQUEST_FOR_DEADLOCK_SEARCH', 'LOGMGR_QUEUE',
          'BROKER_RECEIVE_WAITFOR', 'PREEMPTIVE_OS_GETPROCADDRESS',
          'PREEMPTIVE_OS_AUTHENTICATIONOPS', 'BROKER_TO_FLUSH' )
        ORDER BY wait_time_ms DESC
        -- **** Author: Jonathan Kaheyias ****
            </code>
        </pre>
        <p><strong>Exemplo 3.2</strong>: Encontrando os 10 principais eventos de espera (cumulativos).</p>
        <p>Três tipos de espera interessantes para se observar, em relação à pressão da CPU, são <code>SOS_SCHEDULER_YIELD</code>, <code>CXPACKET</code> e <code>CMEMTHREAD</code>.</p>
        <h3>Esperas <code>SOS_SCHEDULER_YIELD</code></h3>
        <p>O agendador SQL é um agendador cooperativo de multitarefa. Isso significa que ele depende das consultas em execução para voluntariamente ceder a CPU após um determinado tempo de execução. Em contraste, o agendador do Windows é um agendador de multitarefa preemptivo, o que significa que ele remove as tarefas da CPU após um determinado tempo.</p>
        <p>Quando uma tarefa voluntariamente cede a CPU e começa a esperar para retomar a execução, o tipo de espera atribuído à tarefa é <code>SOS_SCHEDULER_YIELD</code>. A tarefa cedente volta para a fila de execução e outra tarefa recebe seu tempo alocado na CPU.</p>
        <p>Se os tempos de espera globais forem baixos, esse tipo de espera é benigno, indicando simplesmente que a consulta passou mais tempo do que o permitido na CPU sem precisar esperar por outros recursos (E/S de disco, bloqueios, latches, concessões de memória etc.).</p>
        <p>Se as consultas mostrarem tempos de espera elevados em <code>sys.dm_exec_requests</code> ou <code>sys.dm_os_waiting_tasks</code> para o tipo de espera <code>SOS_SCHEDULER_YIELD</code>, isso indica que a consulta é extremamente intensiva em CPU. Se houver tempos de espera elevados para esse tipo de espera em geral no servidor, pode indicar que há muitas consultas intensivas em CPU, que podem precisar de otimização, ou que o servidor precisa de mais CPU. A atividade do agendador pode ser investigada ainda mais usando a DMV <code>sys.dm_os_schedulers</code> (discutida em breve).</p>
        <h3>Esperas <code>CXPACKET</code></h3>
        <p>As esperas <code>CXPACKET</code> ocorrem durante a sincronização do iterador de troca do processador de consulta entre os workers, para uma consulta em execução em paralelo em vários processadores. Se o servidor hospeda um data warehouse ou um banco de dados de relatórios que recebe um baixo volume de consultas, mas processa grandes quantidades de dados, o paralelismo pode reduzir substancialmente o tempo necessário para executar essas consultas. No entanto, em contraste, se o servidor hospeda um banco de dados OLTP que possui muitas consultas e transações pequenas, o paralelismo pode afetar negativamente o throughput e o desempenho. Para mais discussão sobre esperas <code>CXPACKET</code> elevadas e como lidar com esse problema, consulte a seção <em>Paralelismo inadequado</em>, posteriormente.</p>
        <h3>Esperas <code>CMEMTHREAD</code></h3>
        <p>As esperas <code>CMEMTHREAD</code> são esperas por objetos de memória sincronizados. Alguns objetos de memória podem ser acessados por vários threads simultaneamente, enquanto outros não podem. Quando vários threads tentam acessar um objeto de memória, normalmente um cache, que deve ser acessado por um thread de cada vez, os threads em espera recebem uma espera <code>CMEMTHREAD</code>.</p>
        <p>Em geral, as esperas <code>CMEMTHREAD</code> não são comuns ou duradouras. No entanto, há um problema de memória conhecido no SQL Server 2005, em que, sob certas circunstâncias, um servidor pode mostrar alto uso de CPU, esperas <code>CMEMTHREAD</code> muito altas e consultas com desempenho muito ruim. Os detalhes disso serão discutidos posteriormente, na seção <em>TokenAndPermUser-Store</em>.</p>
        <h2>Investigando as filas do agendador</h2>
        <p>A DMV <code>sys.dm_os_schedulers</code> pode identificar se uma instância do SQL está com restrição de CPU ou não. Esta DMV retorna uma linha para cada um dos agendadores do SQL Server e lista o número total de tarefas atribuídas a cada agendador, bem como o número que está pronto para execução.</p>
        <p>Uma tarefa pronta para execução é aquela que está nas filas de prontidão, esperando pelo tempo da CPU. Outras tarefas no agendador que estão no <code>current_tasks_count</code>, mas não no <code>runnable_tasks_count</code>, estão ou dormindo ou aguardando um recurso (bloqueio, latch, E/S, memória, etc.).</p>
        <pre>
            <code>
        SELECT  scheduler_id ,
            current_tasks_count ,
            runnable_tasks_count
        FROM    sys.dm_os_schedulers
        WHERE   scheduler_id < 255
            </code>
        </pre>
        <p><strong>Exemplo 3.3</strong>: Investigando as filas do agendador.</p>
        <p>Novamente, não há um valor limite que represente a fronteira entre um número "bom" e "ruim" de tarefas prontas para execução, mas quanto menor, melhor. Um alto número de tarefas prontas para execução, assim como um alto tempo de espera do sinal, indica que não há CPU suficiente para a carga de consultas atual.</p>
        <p>O filtro para agendadores abaixo de 255 remove, do conjunto de resultados, os numerosos agendadores ocultos no SQL Server, que são usados para backups, a Conexão Administrativa Dedicada (DAC) e assim por diante, e não são de interesse ao investigar a carga geral da CPU.</p>
        <h2>Identificando consultas intensivas em CPU</h2>
        <p>Para determinar as consultas de pior desempenho no cache de plano do SQL Server, podem ser utilizadas as DMVs <code>sys.dm_exec_query_stats</code> e <code>sys.dm_exec_sql_text</code>. A DMV <code>sys.dm_exec_query_stats</code> fornece estatísticas agregadas e retorna uma linha para cada instrução de consulta no plano em cache. Muitas das colunas são contadores incrementais e fornecem informações sobre quantas vezes uma consulta foi executada e os recursos que foram utilizados. Por exemplo, as colunas <code>*_worker_time</code> representam o tempo gasto na CPU e as colunas <code>*_elapsed_time</code> mostram o tempo total de execução.</p>
        <p>A consulta mostrada no Exemplo 3.4 retorna as dez consultas mais custosas em cache pelo tempo total de CPU. Juntamos as funções <code>sys.dm_exec_sql_text</code> e <p>sys.dm_exec_query_plan</p> para recuperar o texto e os planos de execução dessas consultas, dentro do lote.</p>
        <pre>
            <code>
        SELECT TOP ( 10 )
            SUBSTRING(ST.text, ( QS.statement_start_offset / 2 ) + 1,
                      ( ( CASE statement_end_offset
                            WHEN -1 THEN DATALENGTH(st.text)
                            ELSE QS.statement_end_offset
                        END - QS.statement_start_offset ) / 2 ) + 1)
                    AS statement_text ,84
            execution_count ,
            total_worker_time / 1000 AS total_worker_time_ms ,
             ( total_worker_time / 1000 ) / execution_count
        AS avg_worker_time_ms ,
        total_logical_reads ,
        total_logical_reads / execution_count AS avg_logical_reads ,
        total_elapsed_time / 1000 AS total_elapsed_time_ms ,
        ( total_elapsed_time / 1000 ) / execution_count
        AS avg_elapsed_time_ms ,
        qp.query_plan
        FROM sys.dm_exec_query_stats qs
        CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) st
        CROSS APPLY sys.dm_exec_query_plan(qs.plan_handle) qp
        ORDER BY total_worker_time DESC
            </code>
        </pre>
        <p><strong>Listagem 3.4</strong>: Encontrando as dez consultas que consomem mais CPU.</p>
        <p>O plano de execução pode ser visualizado clicando no link XML para abrir o plano em sua forma gráfica. O plano de execução retornado é para o lote inteiro, não apenas para a declaração de alto consumo de CPU.</p>
        <p>Ao consultar o cache de planos para investigar planos subótimos, observe que algumas consultas podem não ser listadas. Os planos de execução são retidos em cache até que o SQL Server decida que o plano envelheceu a ponto de ser removido para permitir que novos planos de execução sejam armazenados em cache, ou o cache é totalmente ou parcialmente limpo por comandos <code>DBCC</code>, alterações no estado do banco de dados (restauração de um banco de dados, desanexação ou colocação de um banco de dados offline, etc.) ou determinadas alterações de configuração em todo o servidor, ou o SQL Server é reiniciado. O SQL Server também removerá os planos de execução do cache se ele encontrar que memória extra é necessária em outros lugares do sistema.</p>
        <p><strong><em>Limpando o cache de planos</em></strong></p>
        <p><em>Você pode limpar todos os planos do cache usando</em> <code>DBCC FREEPROCCACHE</code><em>, ou fornecer um</em> <code>plan_handle</code> <em>ou </em><code>sql_handle</code> <em>para remover um plano de um lote específico. Alternativamente,</em> <code>DBCC FREEPROCINDB(db_id)</code> <em>pode ser usado para remover planos deuma base de dados específica.</em></p>
        <p>Também é importante observar que algumas consultas podem nunca aparecer no cache. Procedimentos marcados com <code>WITH RECOMPILE</code> e consultas com a dica <code>OPTION (RECOMPILE)</code> nunca são armazenados em cache. Além disso, as estatísticas da consulta são apagadas quando a consulta é recompilada por qualquer motivo, como alterações nas estatísticas ou no esquema. Como resultado, consultas que estão sujeitas a muitos eventos de recompilação também podem mostrar um tempo total muito baixo de execução, pois esse total se refere apenas ao plano atual, que pode não ter sido armazenado em cache por muito tempo.</p>
        <p>Esse problema vai além da recompilação; os resultados que você obtém de consultas como a Listagem 3.4 serão distorcidos em favor dos planos que estiveram no cache por mais tempo. Um plano frequentemente utilizado que esteve no cache por muito tempo aparecerá mais acima na lista do que um plano realmente ruim que tenha sido adicionado recentemente ao cache.</p>
        <p>Ainda é possível ter uma boa ideia das consultas que foram executadas e como foram executadas, mas a única maneira de garantir uma análise verdadeiramente imparcial é limpar o cache e depois realizar a análise após um período de tempo definido. No entanto, limpar o cache em um servidor de produção pode não ser a melhor ideia, especialmente se esse servidor já estiver conhecido por ter restrições de CPU. Por isso, se uma análise abrangente for necessária, recomendo o uso de rastreamento no lado do servidor para capturar todas as consultas em execução durante um determinado período de tempo.</p>
        <h2>Causas comuns de alto uso de CPU</h2>
        <p>Independentemente do tamanho e custo do hardware e tecnologia que sustentam suas instalações do SQL Server, sempre há o risco de uma ou mais declarações T-SQL mal ajustadas causarem uma utilização excessiva dos recursos.</p>
        <p>Para cada declaração enviada ao SQL Server para execução, o otimizador de consultas tenta encontrar a maneira mais eficiente de recuperar os dados, ou seja, aquela que utiliza menos recursos de CPU, E/S e memória. O plano gerado pelo otimizador será tão bom quanto os caminhos de acesso aos dados disponíveis e as informações que possui sobre os dados e sua distribuição. Se índices apropriados estiverem ausentes ou se as consultas forem escritas de forma a ignorar índices potencialmente úteis, o otimizador não conseguirá elaborar um plano verdadeiramente otimizado. Da mesma forma, se as estatísticas de índice que o otimizador possui sobre os dados forem imprecisas, o otimizador pode selecionar um plano subótimo, uma vez que as informações usadas para calcular o custo dos planos são imprecisas.</p>
        <p>Outra possibilidade é que o otimizador produza um plano que seja ótimo para uma execução da consulta (geralmente aquela que acionou a otimização) e não para outras execuções. Isso é comumente conhecido como "parameter sniffing", embora seja mais apropriado se referir a ele como "parameter sniffing inadequado", uma vez que o parameter sniffing em geral é algo bom, como discutiremos mais adiante no capítulo.</p>
        <h3>Índices ausentes</h3>
        <p>Pode surpreender algumas pessoas saber que índices ausentes podem causar alto uso de CPU, mas, na verdade, a falta de indexação apropriada é uma das causas mais comuns de alta utilização de CPU e E/S no SQL Server. Quando um índice apropriado não existe para satisfazer uma consulta, as leituras em tabela resultantes podem causar um uso significativo de CPU, já que o SQL precisa ler e processar muitas mais linhas do que o necessário para satisfazer a consulta.</p>
        <p>Usando os planos de execução obtidos no cache de planos, como mostrado na Listagem 3.4, podemos identificar quaisquer operações que podem ser substituídas por operações mais eficientes, adicionando índices de cobertura ou, em alguns casos, alterando os índices existentes. Vamos considerar uma consulta simples no banco de dados <code>Adventureworks2008</code>, como mostrado na Listagem 3.5.</p>
        <pre>
            <code>
        SELECT  per.FirstName ,
            per.LastName ,
            p.Name ,
            p.ProductNumber ,
            OrderDate ,
            LineTotal ,
            soh.TotalDue
        FROM    Sales.SalesOrderHeader AS soh
            INNER JOIN Sales.SalesOrderDetail sod
            ON soh.SalesOrderID = sod.SalesOrderID
            INNER JOIN Production.Product AS p ON sod.ProductID = p.ProductID
            INNER JOIN Sales.Customer AS c ON soh.CustomerID = c.CustomerID
            INNER JOIN Person.Person AS per
                          ON c.PersonID = per.BusinessEntityID
        WHERE LineTotal > 25000
            </code>
        </pre>
        <p><strong>Listagem 3.5</strong>: Uma consulta simples no AdventureWorks.</p>
        <p>Esta consulta causa uma leitura completa da tabela SalesOrderDetail, pois não há um índice na coluna LineTotal. As características de execução (com todas as páginas necessárias no cache de dados, portanto, sem espera de E/S) são as seguintes:</p>
        <pre>
            <code>
        SQL Server parse and compile time:
           CPU time = 0 ms, elapsed time = 0 ms.
        SQL Server Execution Times:
           CPU time = 452 ms, elapsed time = 458 ms.
            </code>
        </pre>
        <p>Quase meio segundo de tempo de CPU para retornar 24 linhas; isso não é bom. Agora, vamos adicionar um índice simples, conforme mostrado na Listagem 3.6.</p>
        <pre>
            <code>
        CREATE NONCLUSTERED INDEX idx_SalesOrderDetail_LineTotal
        ON Sales.SalesOrderDetail (LineTotal)
            </code>
        </pre>
        <p><strong>Listagem 3.6</strong>: Adicionando um índice à coluna <code>LineTotal</code> no <code>AdventureWorks</code>.</p>
        <p>Agora, se executarmos a mesma consulta novamente, as características de desempenho serão muito diferentes:</p>
        <pre>
            <code>
        SQL Server parse and compile time:
           CPU time = 0 ms, elapsed time = 0 ms.
        SQL Server Execution Times:
           CPU time = 0 ms, elapsed time = 8 ms.
            </code>
        </pre>
        <p>Este foi um exemplo simplista, mas serve para demonstrar o ponto e um dos principais problemas que observo ao investigar cenários de alto uso de CPU é, simplesmente, a ausência de índices.</p>
        <p>Consulte o <em>Capítulo 5</em> para obter mais informações sobre índices ausentes.</p>
        <h3>Estatísticas desatualizadas</h3>
        <p>O Otimizador do SQL Server usa estatísticas para calcular a cardinalidade estimada para vários operadores de consulta. Essa cardinalidade, essencialmente o número de linhas, afeta o custo dos operadores. O custo dos operadores, por sua vez, determina o custo do plano. Se a estimativa de cardinalidade estiver incorreta, devido a estatísticas desatualizadas, o custo que o otimizador calcula para os operadores também estará incorreto, levando o otimizador a selecionar um plano que tem um custo estimado baixo, mas um custo real muito alto quando é executado.</p>
        <p>O efeito colateral mais comum de estatísticas incorretas é que o otimizador faz estimativas subestimadas para o número de linhas e, portanto, escolhe operadores que são muito eficientes para um pequeno número de linhas, como junções de loop aninhado e pesquisas de chave. Quando a consulta é executada e descobre-se que um grande número de linhas precisa ser processado, os operadores escolhidos não se adaptam bem e o plano se torna altamente ineficiente.</p>
        <p>Uma maneira de identificar se há um problema com as estatísticas de uma consulta específica é executar a consulta no Management Studio, retornar o plano de execução real e examinar as contagens estimadas e reais de linhas para quaisquer operações de busca e varredura de índice dentro do plano de execução. Se as duas contagens forem significativamente diferentes, considerando que a contagem estimada é por execução do operador e a contagem real é um total para todas as execuções do operador, então uma possibilidade é que as estatísticas estejam desatualizadas.</p>
        <p>Corrigir estatísticas desatualizadas é feito por meio da instrução <code>UPDATE STATISTICS</code>. Isso pode ser executado para todas as estatísticas em uma tabela (<code>UPDATE STATISTICS <nome da tabela></code>) ou apenas para um conjunto de estatísticas específico (<code>UPDATE STATISTICS <nome da tabela> <nome da estatística></code>).</p>
        <p>Se o problema for devido a estatísticas desatualizadas, ou seja, uma atualização das estatísticas resolve o problema, então você precisa evitar que o problema ocorra novamente, e existem três maneiras de fazer isso:</p>
        <ol>
            <li>Se a configuração do banco de dados "Auto_Update_Statistics" estiver desativada, considere ativá-la. Alternativamente, um trabalho de atualização de estatísticas em todo o banco de dados pode ser executado regularmente.</li>
            <li>Se as atualizações automáticas estiverem desabilitadas para um índice específico ou conjunto de estatísticas, como resultado da reconstrução do índice com a opção NORECOMPUTE, elas devem ser habilitadas.</li>
            <li>Um trabalho pode ser criado para atualizar as estatísticas específicas que sofrem com atualizações insuficientes e, consequentemente, resultam em problemas de desempenho. Esse trabalho pode ser agendado com a frequência necessária. Já ouvi falar de casos em que um trabalho desse tipo é executado a cada hora.</li>
        </ol>
        <h3>Predicados não-SARGáveis</h3>
        <p>SARGável, em que SARG significa Argumento de Busca, é um daqueles termos inventados irritantes que nós, como profissionais de TI, adoramos usar; simplesmente significa que um predicado pode ser usado em uma operação de busca de índice. As regras para predicados SARGáveis, em geral, são que a coluna deve ser comparada diretamente (igualdade ou desigualdade) a uma expressão, e qualquer função especificada na coluna tornará o predicado não-SARGável. Em outras palavras, <code>WHERE AlgumaFuncao(Coluna) = @Valor</code> não é SARGável, enquanto <code>WHERE Coluna = AlgumaOutraFuncao(@Valor)</code> é SARGável. Observe que a SARGabilidade não exclui o uso de operadores como <code>LIKE</code> ou <code>BETWEEN</code> (ambos são comparações de desigualdade) ou <code>IN</code> (tratado como um conjunto de comparações de igualdade).</p>
        <p>Predicados não-SARGáveis podem resultar em varreduras de tabela ou de índice e, assim como no caso de índices ausentes, isso causará um uso significativo de CPU, pois o SQL precisa ler e processar muito mais linhas do que o necessário. A Listagem 3.7 mostra um exemplo de um predicado da cláusula <code>WHERE</code> que é não-SARGável devido ao uso de algumas funções de manipulação de datas na coluna <code>ModifiedDate</code>. Este exemplo pressupõe que um índice tenha sido adicionado em <code>ModifiedDate</code>, já que não há um índice desse tipo no banco de dados padrão <code>AdventureWorks</code>.</p>
        <pre>
            <code>
        SELECT  soh.SalesOrderID ,
            OrderDate ,
            DueDate ,
            ShipDate ,
            Status ,
            SubTotal ,
            TaxAmt ,
            Freight ,
            TotalDue
        FROM    Sales.SalesOrderheader AS soh
            INNER JOIN Sales.SalesOrderDetail AS sod
                        ON soh.SalesOrderID = sod.SalesOrderID
        WHERE   CONVERT(VARCHAR(10), sod.ModifiedDate, 101) = '01/01/2010'
            </code>
        </pre>
        <p><code>Listagem 3.7</code>: Um predicado não-SARGável na condição de busca.</p>
        <p>A partir do plano de execução, podemos ver que o uso das funções na coluna ModifiedDate impossibilitou a realização de uma operação de busca no índice; todo o índice foi escaneado para localizar os valores correspondentes, como mostrado na Figura 3.2.</p>
        <img src="imagens/fig32.PNG" alt="Index Scan">
        <p><strong>Figura 3.2</strong>: Um escaneamento de índice no índice SalesOrderDetail.</p>
        <p>Este é um problema bastante comum no código SQL. As datas podem ser difíceis de lidar e muitas vezes as pessoas optam pela abordagem mais fácil, sem perceber o impacto que terá no desempenho. A mudança neste caso é simples; modifique o predicado para ser uma busca de intervalo (desigualdade) por datas e horários dentro do dia desejado.</p>
        <pre>
            <code>
        SELECT  soh.SalesOrderID ,
            OrderDate ,
            DueDate ,
            ShipDate ,
            Status ,
            SubTotal ,
            TaxAmt ,
            Freight ,
            TotalDue
        FROM    Sales.SalesOrderheader AS soh
            INNER JOIN Sales.SalesOrderDetail AS sod ON soh.SalesOrderID = sod.SalesOrderID
        WHERE sod.ModifiedDate >= '2010/01/01'
        AND sod.ModifiedDate < '2010/01/02'
            </code>
        </pre>
        <p><strong>Listagem 3.8</strong>: Um predicado SARGável na condição de busca.</p>
        <p>A Figura 3.3 confirma que agora vemos uma operação de busca no índice.</p>
        <p>Esse é um problema bastante comum em muitos bancos de dados. Com frequência, vejo funções como <code>UPPER</code>, <code>LTRIM</code>, <code>ISNULL</code> sendo usadas em consultas, seja nos joins ou na cláusula <code>WHERE</code>, e em muitos casos simplesmente não há necessidade delas. Se as colunas usarem uma colação que não diferencia maiúsculas de minúsculas, os valores em maiúsculas e minúsculas são considerados iguais, e o uso das funções <code>UPPER</code> ou <code>LOWER</code> não faz nada além de degradar o desempenho. Da mesma forma, nas comparações de strings, o SQL ignora espaços finais, eliminando a necessidade da função <code>RTRIM</code>.</p>
        <img src="imagens/fig33.PNG" alt="Index Seek">
        <p><strong>Figura 3.3</strong>: Uma busca de índice no índice SalesOrderDetail.</p>
        <p>Lidar com <code>NULLs</code> sempre é interessante. A função <code>ISNULL</code> é frequentemente usada desnecessariamente devido a uma incompreensão de como os <code>NULLs</code> funcionam em predicados. Por exemplo, os dois predicados abaixo na cláusula <code>WHERE</code> são completamente equivalentes em função.</p>
        <pre>
            <code>
        WHERE ISNULL(SomeCol,0) > 0
        WHERE SomeCol > 0
            </code>
        </pre>
        <p>No primeiro caso, qualquer linha com um valor <code>NULL</code> será excluída porque o <code>NULL</code> é convertido para zero e o filtro é para valores maiores que zero. No segundo caso, qualquer linha com um valor <code>NULL</code> será excluída porque os <code>NULLs</code> nunca retornam verdadeiro quando comparados a qualquer valor usando os operadores de igualdade (=), diferença (<>), menor que (<), maior que (>), ou qualquer outro operador de comparação. Eles só retornam verdadeiro para verificações de <code>IS NULL</code> ou <code>IS NOT NULL</code>. Portanto, ambos os predicados alcançam o mesmo resultado, mas apenas o segundo permite o uso de pesquisas de índice.</p>
        <h3>Conversões implícitas</h3>
        <p>Uma conversão implícita ocorre devido à comparação de tipos de dados diferentes. O SQL não pode comparar valores de tipos diferentes e, portanto, é necessário converter uma das colunas envolvidas para o mesmo tipo de dados que o outro, a fim de realizar a comparação.</p>
        <p>Quando ocorre uma conversão implícita em uma coluna usada em uma cláusula <code>WHERE</code> ou <code>FROM</code>, o Otimizador do SQL Server determina a conversão de todos os valores da coluna antes que o filtro possa ser aplicado. Isso significa que, durante a execução da consulta, o processador de consulta converterá o tipo de dados de menor precedência para o tipo de dados de maior precedência antes de aplicar o filtro ou a condição de junção. Isso implica que, assim como no caso de funções na coluna, o predicado é considerado não-SARGable, o que significa que não é possível usar pesquisas de índice. O SQL precisa processar mais linhas do que o necessário para obter os resultados, o que resulta em um maior uso da CPU.</p>
        <p>Uma manifestação comum desse problema é a comparação de parâmetros <code>NVARCHAR</code> com colunas do tipo <code>VARCHAR</code>. Existem algumas bibliotecas de acesso a dados (como o JDBC, por exemplo) que passam constantes de string como Unicode (<code>NVARCHAR</code>) por padrão. O problema é demonstrado no exemplo 3.9, onde a coluna AccountNumber é do tipo <code>VARCHAR</code> e o parâmetro é uma sequência Unicode (<code>NVARCHAR</code>), indicada pelo N antes das aspas de abertura.</p>
        <pre>
            <code>
        SELECT  p.FirstName ,
            p.LastName ,
            c.AccountNumber
        FROM    Sales.Customer AS c
            INNER JOIN Person.Person AS p ON c.PersonID = p.BusinessEntityID
        WHERE   AccountNumber = N'AW00029594'
            </code>
        </pre>
        <p><strong>Exemplo 3.9</strong>: Uma conversão implícita de tipo de dados na condição de busca.</p>
        <p>The relevant section of the execution plan, shown in Figure 3.4, confirms that we get an index scan operation.</p>
        <img src="imagens/fig34.png" alt="O predicado não-SARGable resulta em uma varredura de índice.">
        <p><strong>Figura 3.4</strong>: O predicado não-SARGable resulta em uma varredura de índice.</p>
        <p>A janela de propriedades do filtro, na Figura 3.5, mostra a conversão implícita.</p>
        <img src="imagens/fig35.PNG" alt="O predicado do filtro dita a necessidade de converter todas as linhas na coluna AccountNumber para NVARCHAR.">
        <p><strong>Figure 3.5</strong>: O predicado do filtro dita a necessidade de converter todas as linhas na coluna <code>AccountNumber</code> para <code>NVARCHAR</code>.</p>
        <p>A solução para conversões implícitas é garantir que as colunas usadas em junções sejam sempre do mesmo tipo e que, na cláusula <code>WHERE</code>, quaisquer variáveis, parâmetros ou constantes sejam do mesmo tipo das colunas com as quais estão sendo comparados. Se não forem, faça uso cuidadoso das funções de conversão (<code>CAST</code>, <code>CONVERT</code>) nas variáveis, parâmetros ou constantes para que correspondam ao tipo de dados da coluna.</p>
        <p>Se estiver usando bibliotecas de acesso a dados como o JDBC, verifique as propriedades para garantir que elas não estejam passando todos os valores de string como <code>NVARCHAR</code>, independentemente do tipo de dados da coluna subjacente.</p>
        <h3>Parameter sniffing</h3>
        <p>O "parameter sniffing" é um processo usado pelo SQL Server ao criar um plano de execução para uma stored procedure, função ou consulta parametrizada. Na primeira vez em que o plano é compilado, o SQL Server examina, ou "sniffa", os valores dos parâmetros de entrada fornecidos e os utiliza, em conjunto com as estatísticas das colunas, para estimar o número de linhas que serão afetadas pela consulta. Em seguida, usa essa estimativa para calcular o custo de várias possíveis execuções do plano. Um problema surge apenas se os valores que foram passados como parâmetros de entrada na criação inicial do plano resultarem em um número de linhas atípico em relação ao que será obtido em futuras execuções da procedure. O "parameter sniffing" ocorre apenas no momento em que um plano é compilado ou recompilado, e todas as execuções subsequentes da stored procedure, função ou consulta parametrizada usarão o mesmo plano.</p>
        <p>Durante a compilação inicial, apenas os valores dos parâmetros de entrada podem ser "sniffados", pois as variáveis locais ainda não têm valor. Se uma instrução dentro do lote for recompilada, tanto os valores dos parâmetros quanto das variáveis podem ser "sniffados", pois as variáveis terão valores naquele momento.</p>
        <p>Como exemplo, usaremos novamente o banco de dados <code>AdventureWorks</code>, e especificamente a coluna <code>ShipDate</code> na tabela <code>Sales.SalesOrderHeader</code>. Essa coluna tem uma data mínima de 08/07/2004 e uma data máxima de 08/07/2011. O Exemplo 3.10 mostra uma stored procedure para encontrar todos os números de pedidos de venda (também nessa tabela) que estão entre duas datas de envio fornecidas.</p>
        <pre>
            <code>
        CREATE PROCEDURE user_GetCustomerShipDates
        (
          @ShipDateStart DATETIME ,
          @ShipDateEnd DATETIME
        )
        AS
        SELECT  CustomerID ,
                SalesOrderNumber
        FROM    Sales.SalesOrderHeader
        WHERE   ShipDate BETWEEN @ShipDateStart AND @ShipDateEnd
        GO
            </code>
        </pre>
        <p><strong>Exemplo 3.10</strong>: A stored procedure <code>user_GetCustomerShipDates</code>.</p>
        Isso seria suportado por um índice não clusterizado em <code>ShipDate</code>, conforme mostrado no Exemplo 3.11.
        <pre>
            <code>
        CREATE NONCLUSTERED INDEX IDX_ShipDate_ASC
         ON Sales.SalesOrderHeader (ShipDate)
        GO
            </code>
        </pre>
        <p><strong>Exemplo 3.11</strong>: Um índice não clusterizado na coluna <code>ShipDate</code>.</p>
        <p>Agora, vamos executar a stored procedure duas vezes, conforme mostrado no Exemplo 3.12, com a primeira consulta abrangendo um intervalo de datas de vários anos e, portanto, retornando muitas linhas, e a segunda consulta abrangendo apenas um intervalo de dez dias. Certifique-se de obter o plano de execução real juntamente com os resultados.</p>
        <pre>
            <code>
        DBCC FREEPROCCACHE
        EXEC user_GetCustomerShipDates '2001/07/08', '2004/01/01'
        EXEC user_GetCustomerShipDates '2001/07/10', '2001/07/20'
            </code>
        </pre>
        <p><strong>Exemplo 3.12</strong>: Executando a stored procedure <code>user_GetCustomerShipDates</code>, com a primeira consulta abrangendo um intervalo de datas grande.</p>
        <p>Observe que executamos o comando <code>DBCC FREEPROCCACHE</code> para limpar o cache de planos e garantir a criação de um novo plano. O plano é idêntico em ambos os casos, conforme mostrado na Figura 3.6.</p>
        <img src="imagens/fig36.PNG" alt="Planos de execução para a stored procedure user_GetCustomerShipDates.">
        <p><strong>Figura 3.6</strong>: Planos de execução para a stored procedure <code>user_GetCustomerShipDates</code>.</p>
        <p>No plano, vemos que o otimizador optou por não utilizar o índice não clusterizado na coluna <code>ShipDate</code>, que criamos especialmente para esta stored procedure. A razão é que não se trata de um índice de cobertura (não inclui a coluna <code>SalesOrderNumber</code>) e o número de linhas estimado pelo otimizador, com base nos valores dos parâmetros para a execução inicial, juntamente com as estatísticas, foi muito alto para tornar a combinação de busca no índice/verificação da chave otimizada. Portanto, o otimizador ignora esse índice e faz uma varredura em outro.</p>
        <p>Agora, execute novamente o Exemplo 3.12, desta vez sem retornar o plano de execução, mas com as opções <code>STATISTICS IO</code> e <code>STATISTICS TIME</code> habilitadas. A razão para fazer uma execução separada é que retornar o plano de execução real tem um impacto no desempenho da consulta, portanto, as execuções que retornam o plano de execução não devem ser usadas para verificar as estatísticas de desempenho da consulta. Os resultados são os seguintes (os cabeçalhos separadores foram adicionados manualmente, para maior clareza).</p>
        <pre>
            <code>
        ==FIRST EXECUTION (LARGE DATE RANGE)===
        (Table 'SalesOrderHeader'. Scan count 1, logical reads 686, physical reads 0.
        SQL Server Execution Times:
          CPU time = 16 ms, elapsed time = 197 ms.
        SQL Server Execution Times:
          CPU time = 16 ms, elapsed time = 197 ms.
        ==SECOND EXECUTION (SMALL DATE RANGE)===
        Table 'SalesOrderHeader'. Scan count 1, logical reads 686, physical reads 0.
        SQL Server Execution Times:
          CPU time = 15 ms, elapsed time = 5 ms.
        SQL Server Execution Times:
          CPU time = 15 ms, elapsed time = 5 ms.
            </code>
        </pre>
        <p>As leituras lógicas são mostradas como 686 leituras para ambos os casos, mas é o tempo de CPU que é de maior interesse aqui. Vale ressaltar que a maioria do tempo decorrido é, na verdade, a transmissão e exibição das linhas, portanto, esse tempo será muito maior para 17.000 linhas (o primeiro conjunto) do que para 40 linhas (o segundo).</p>
        <p>Agora, vamos limpar o cache novamente e inverter a ordem de execução, para que a consulta com um intervalo de datas mais curto seja executada primeiro, conforme mostrado no Exemplo 3.13. Isso significa que, desta vez, o processo de parameter sniffing resultará em um número estimado de linhas muito menor.</p>
        <pre>
            <code>
        DBCC FREEPROCCACHE
        EXEC user_GetCustomerShipDates '2001/07/10', '2001/07/20'
        EXEC user_GetCustomerShipDates '2001/07/08', '2004/01/01'
            </code>
        </pre>
        <p><strong>Exemplo 3.13</strong>: Executando a stored procedure <code>user_GetCustomerShipDates</code>, com a consulta de intervalo de datas mais curto sendo executada primeiro.</p>
        <p>Como esperado, o plano de execução mudou drasticamente, como mostrado na Figura 3.7. O menor número de linhas estimadas leva o otimizador a usar uma busca no índice no nosso índice <code>IDX_ShipDate_ASC</code>, seguido por uma verificação de chave para recuperar as linhas restantes.</p>
        <img src="imagens/fig37.PNG" alt="Novos planos de execução para a stored procedure user_GetCustomerShipDates.">
        <p><strong>Figura 3.7</strong>: Novos planos de execução para a stored procedure <code>user_GetCustomerShipDates</code>.</p>
        <p>Execute novamente o Exemplo 3.13, desta vez sem o plano de execução, mas com as estatísticas, e você verá que o plano funciona muito bem para a primeira execução, mas causa problemas para a próxima.</p>
        <pre>
            <code>
        ==FIRST EXECUTION (SMALL DATE RANGE)===
        Table 'SalesOrderHeader'. Scan count 1, logical reads 127, physical reads 0, readahead reads 0, lob logical reads 0, lob physical reads 0, loread-ahead reads0.
        
        SQL Server Execution Times:
        CPU time = 0 ms, elapsed time = 0 ms.
        ==SECOND EXECUTION (LARGE DATE RANGE)===
        Table 'SalesOrderHeader'. Scan count 1, logical reads 52429, physical reads 0.
        
        SQL Server Execution Times:
        CPU time = 47 ms, elapsed time = 182 ms.100
            </code>
        </pre>
        <p>Embora não seja um grande salto no tempo de CPU, lembre-se de que mesmo a segunda execução está lidando com 17.000 linhas no conjunto de resultados. Com contagens de linhas maiores, esse problema pode ter um impacto muito significativo.</p>
        <p>Este é um exemplo clássico, embora em pequena escala, de como o parameter sniffing trabalha contra nós. O plano com as verificações de chave é ótimo apenas para contagens de linhas pequenas (tipicamente < 1% da tabela). Acima disso, a E/S adicional e o CPU adicional necessários para as verificações de chave se tornam muito significativos.</p>
        <p>Existem várias maneiras diferentes de lidar com problemas de parameter sniffing, dependendo da situação e da versão do SQL Server que você está usando.</p>
        <h2>Trace Flag 4136</h2>
        <p>O SQL Server 2008 introduziu uma opção para desativar completamente o parameter sniffing para uma instância do SQL Server, simplesmente ativando o Trace Flag 4136. Essa opção foi adicionada no SQL Server 2008 SP1 CU7 e no SQL Server 2008 R2 CU2, e também foi retroportada para o SQL Server 2005 no SP3 CU9.</p>
        <p>Quando o otimizador de consultas é capaz de "sniffar" o valor de um parâmetro, ele usa esse valor, juntamente com o histograma de estatísticas, para fornecer uma estimativa precisa do número de registros que serão retornados. Como discutido anteriormente, isso só é problemático se o valor inicial do parâmetro se mostrar completamente atípico.</p>
        <p>Quando o parameter sniffing é evitado, o otimizador não consegue obter o valor do parâmetro e, portanto, não pode usar o histograma de estatísticas. Em vez disso, ele faz uma estimativa menos precisa do número de linhas que serão retornadas, assumindo uma distribuição uniforme dos dados em todos os valores. Por exemplo, considere uma coluna X contendo 10 linhas com valores 1, 2, 3, 3, 3, 3, 3, 4, 5, 5. O otimizador sempre estimaria que uma consulta "<code>WHERE X = valor</code>" retornará 2 linhas (número total de linhas dividido pelo número de valores distintos), e assim o plano sempre seria otimizado para esse número de linhas.</p>
        <p>Em resumo, embora essa opção esteja disponível, o parameter sniffing é benéfico para a maioria dos procedimentos que são escritos para usar valores típicos. Desativar o parameter sniffing pode afetar inadvertidamente esses planos de maneira negativa. Como tal, esse Trace Flag deve ser considerado como último recurso absoluto se nada mais resolver o problema.</p>
        <h2>Usando o hint OPTIMIZE FOR</h2>
        <p>No SQL Server 2005 e posterior, podemos usar a dica <code>OPTIMIZE FOR</code> para especificar um valor de parâmetro para o otimizador usar ao compilar um plano, conforme mostrado no Listing 3.14.</p>
        <pre>
            <code>
        CREATE PROCEDURE user_GetCustomerShipDates
        (
          @ShipDateStart DATETIME ,
          @ShipDateEnd DATETIME
        )
        AS
        SELECT  CustomerID ,
                SalesOrderNumber
        FROM    Sales.SalesOrderHeader
        WHERE   ShipDate BETWEEN @ShipDateStart AND @ShipDateEnd
        OPTION  ( OPTIMIZE FOR ( @ShipDateStart = '2001/07/08',
                                  @ShipDateEnd = '2004/01/01' ) )
        GO
            </code>
        </pre>
        <p><strong>Listagem 3.14</strong>: Usando o hint de consulta <code>OPTIMIZE FOR</code>.</p>
        <p>Isso permite que o otimizador otimize o plano para um valor de parâmetro que se sabe ser mais comumente usado. Isso elimina a possibilidade de "parameter sniffing", mas ao mesmo tempo pode levar a um plano menos eficiente se valores atípicos forem usados.</p>
        <p>No SQL Server 2008, isso foi "estendido" para fornecer a dica <code>OPTIMIZE FOR UNKNOWN</code>, que instrui o SQL Server a não usar o "parameter sniffing" de forma alguma. Isso permite um controle de "parameter sniffing" consulta por consulta, enquanto o Trace Flag mencionado anteriormente controla a configuração para toda a instância. Na maioria dos casos, a dica é uma solução mais desejável, pois, em geral, o "parameter sniffing" é algo positivo.</p>
        <h2>Opções de recompilação</h2>
        <p>Podemos usar a opção <code>WITH RECOMPILE</code> ao criar uma stored procedure como outra possível solução para problemas de "parameter sniffing". Isso significa que um plano nunca será armazenado em cache para a procedure, pois força uma recompilação e geração de um novo plano a cada execução. Isso significa que as estimativas de linhas serão sempre baseadas no valor atual do parâmetro, mas ao custo de aumentar o tempo de execução da procedure.</p>
        <pre>
            <code>
        CREATE PROCEDURE user_GetCustomerShipDates
           (
          @ShipDateStart DATETIME ,
          @ShipDateEnd DATETIME
           )
           WITH RECOMPILE
        AS
           SELECT  CustomerID ,
               SalesOrderNumber
           FROM    Sales.SalesOrderHeader
           WHERE   ShipDate BETWEEN @ShipDateStart AND @ShipDateEnd
        GO
            </code>
        </pre>
        <p><strong>Listing 3.15</strong>: Usando a opção <code>WITH RECOMPILE</code>.</p>
        <p>O hint de consulta <code>OPTION(RECOMPILE)</code> pode ser usado de maneira semelhante e pode ser uma opção melhor se houver várias consultas dentro da procedure e apenas uma parte delas sofrer com problemas de "parameter sniffing".</p>
        <pre>
            <code>
        CREATE PROCEDURE user_GetCustomerShipDates
           (
          @ShipDateStart DATETIME ,
          @ShipDateEnd DATETIME
           )
        AS
           SELECT  CustomerID ,
               SalesOrderNumber
           FROM    Sales.SalesOrderHeader
           WHERE   ShipDate BETWEEN @ShipDateStart AND @ShipDateEnd
           OPTION  ( RECOMPILE )
        GO
            </code>
        </pre>
        <p><strong>Listing 3.16</strong>: Usando o hint de consulta <code>OPTION(RECOMPILE)</code>.</p>
        <p>Essas técnicas são úteis quando o custo adicional das compilações é pequeno em comparação com a degradação de desempenho causada pelo reuso de planos inadequados. A dica <code>OPTION(RECOMPILE)</code> deve ser usada sempre que possível, em preferência ao <code>WITH RECOMPILE</code> para um procedimento armazenado, a fim de manter o impacto do processo de compilação repetida o mais baixo possível.</p>
        <h3>Consultas não parametrizadas ad hoc</h3>
        <p>As consultas ad hoc são declarações enviadas ao otimizador que não são predefinidas usando stored procedures, <code>sp_executesql</code> ou outras maneiras de forçar o reuso de planos de execução. O SQL Server sempre verificará o cache de planos para ver se um plano adequado pode ser reutilizado para uma determinada consulta, antes de passar pelo processo completo de geração de um novo plano de execução e armazená-lo em cache.</p>
        <p>Consultas ad hoc farão com que planos de execução sejam gerados para cada declaração. Isso causa um uso excessivo de recursos, especialmente da CPU. Considere as três consultas mostradas em Listing 3.17.</p>
        <pre>
            <code>
        SELECT  soh.SalesOrderNumber ,
            sod.ProductID
        FROM    Sales.SalesOrderHeader AS soh
            INNER JOIN Sales.SalesOrderDetail AS sod
                   ON soh.SalesOrderID = sod.SalesOrderID
        WHERE   soh.SalesOrderNumber = 'SO43662'
        
        SELECT  soh.SalesOrderNumber ,
            sod.ProductID
        FROM    Sales.SalesOrderHeader AS soh
            INNER JOIN Sales.SalesOrderDetail AS sod
                   ON soh.SalesOrderID = sod.SalesOrderID
        WHERE   soh.SalesOrderNumber = 'SO58928'
        
        SELECT soh.SalesOrderNumber ,
           sod.ProductID
        FROM   Sales.SalesOrderHeader AS soh104
           INNER JOIN Sales.SalesOrderDetail AS sod
                  ON soh.SalesOrderID = sod.SalesOrderID
        WHERE  soh.SalesOrderNumber = 'SO70907'
            </code>
        </pre>
        <p><strong>Listing 3.17</strong>: Três consultas simples, mas não parametrizadas.</p>
        <p>Essas três declarações deveriam produzir o mesmo plano de execução, mas não o fazem. Os diferentes valores atribuídos hardcoded na cláusula WHERE significam que eles são considerados pelo otimizador como três consultas diferentes e, portanto, recebem planos de execução separados.</p>
        <p>Para consultas muito simples, o SQL Server pode usar uma técnica chamada <strong>parametrização simples</strong> para substituir os valores fixos por parâmetros e, assim, permitir o reuso de planos. No entanto, até mesmo as consultas na Listagem 3.17 são muito complexas para se qualificarem para a parametrização simples.</p>
        <p>O problema com consultas não parametrizadas é duplo:</p>
        <ol>
            <li><strong>O cache de planos é preenchido com muitos planos de uso único de consultas ad hoc</strong>. Isso significa que a memória é usada de forma menos eficiente. Também significa que os planos que poderiam ser reutilizáveis podem ser descartados do cache devido à pressão de memória, exigindo que sejam compilados novamente quando as consultas forem executadas novamente.</li>
            <li><strong>A compilação desses planos de uso único desperdiça CPU</strong>. A compilação é cara, usando quantidades relativamente grandes de CPU, e a compilação repetida de planos para consultas ad hoc, que provavelmente não serão reutilizados, é apenas um desperdício de recursos.</li>
        </ol>
        <p>Casos em que a falta de parametrização está causando uma compilação excessiva de planos, ou onde a parametrização simples (ou forçada) é tentada, mas falha, podem ser identificados usando os seguintes contadores dos objetos de Estatísticas SQL no Monitor de Desempenho:</p>
        <ul>
            <li><strong>SQLServer: SQL Statistics: SQL Compilations/Sec</strong></li>
            <li><strong>SQLServer: SQL Statistics: Auto-Param Attempts/Sec</strong></li>
            <li><strong>SQLServer: SQL Statistics: Failed Auto-Param/Sec</strong></li>
        </ul>
        <p>Referência: <a href="http://msdn.microsoft.com/en-us/library/ms190911(SQL.100).aspx" target="_blank" rel="external">http://msdn.microsoft.com/en-us/library/ms190911(SQL.100).aspx</a>.</p>
        <p>Se as consultas ad hoc não parametrizadas estiverem causando um problema, há algumas opções para resolvê-lo. A primeira e melhor opção é corrigir o problema na origem, no aplicativo que realiza as chamadas. Se isso não for possível, existem configurações no SQL Server que podem ser alteradas para amenizar o problema.</p>
        <h2>Corrigindo o aplicativo</h2>
        <p>Se for possível alterar o aplicativo que está enviando essas consultas ad hoc não parametrizadas para o SQL Server, essa opção deve ser escolhida. Isso pode envolver a migração do acesso aos dados de consultas ad hoc incorporadas no código da interface para procedimentos armazenados, ou pode envolver apenas a alteração das consultas ad hoc incorporadas no código da interface para suas versões parametrizadas. A Listagem 3.18 mostra uma consulta não parametrizada sendo enviada ao SQL Server.</p>
        <pre>
            <code>
        cmd.CommandType = CommandType.Text;
        cmd.CommandText = @"SELECT soh.SalesOrderNumber,
                                sod.ProductID
                        FROM   Sales.SalesOrderHeader AS soh
                                  INNER JOIN Sales.SalesOrderDetail AS sod
                                         ON soh.SalesOrderID = sod.SalesOrderID
                        WHERE  soh.SalesOrderNumber = '" + txtSalesOrderNo.Text + "'";
        
        dtrSalesOrders = cmd.ExecuteReader();
            </code>
        </pre>
        <p><strong>Listagem 3.18</strong>: Uma consulta não parametrizada sendo enviada ao SQL Server.</p>
        <p>A Listagem 3.19 mostra a mesma consulta, mas agora em uma forma parametrizada que permitirá o reuso do plano.</p>
        <pre>
            <code>
        dtrSalesOrders.Close();
        cmd.CommandType = CommandType.Text;
        cmd.CommandText = @"SELECT soh.SalesOrderNumber,
                                sod.ProductID
                        FROM   Sales.SalesOrderHeader AS soh
                                  INNER JOIN Sales.SalesOrderDetail AS sod
                                         ON soh.SalesOrderID = sod.SalesOrderID
                        WHERE  soh.SalesOrderNumber = @SalesOrderNo";
        cmd.Parameters.Add("@SalesOrderNo", SqlDbType.NVarChar, 50);
        cmd.Parameters["@SalesOrderNo"].Value = txtSalesOrderNo.Text;
        
        dtrSalesOrders = cmd.ExecuteReader();
            </code>
        </pre>
        <p><strong>Listagem 3.19</strong>: Uma consulta parametrizada sendo enviada ao SQL Server.</p>
        <p>Se não for possível alterar o aplicativo, como muitas vezes ocorre com aplicativos de fornecedores, ou quando o código-fonte do aplicativo não está disponível, existem duas opções no SQL Server que podem ajudar a aliviar o problema: <strong>parametrização forçada</strong> e <strong>otimização para cargas de trabalho ad hoc</strong>.</p>
        <h2>Parametrização forçada no SQL Server</h2>
        <p>O SQL Server 2005 e versões posteriores oferecem a capacidade de definir a opção <code>PARAMETERIZATION</code> em nível de banco de dados como <code>FORCED</code>, usando a instrução <code>ALTER DATABASE</code>, conforme mostrado na Listagem 3.20. Isso forçará todas as consultas ad hoc nesse banco de dados a serem parametrizadas antes do processo de compilação iniciar.</p>
        <pre><code>ALTER DATABASE AdventureWorks SET PARAMETERIZATION FORCED</code></pre>
        <p><strong>Listagem 3.20</strong>: Definindo a opção <code>PARAMETERIZATION</code> como <code>FORCED</code>.</p>
        <p>Se você executar esse comando e depois executar novamente as três consultas da Listagem 3.17, a consulta que o Otimizador de Consulta do SQL recebe para otimizar será a versão parametrizada, e você verá que apenas um plano será criado em cache, e não três.</p>
        <p>Existem possíveis desvantagens no uso da parametrização forçada, pois essa configuração obriga o SQL a usar um plano para todas as consultas correspondentes, independentemente dos valores literais, o que significa que há uma possibilidade dos mesmos problemas de parameter sniffing aos quais as stored procedures estão suscetíveis. Se ocorrer um problema desse tipo, ele poderá ser investigado e resolvido de maneira semelhante ao discutido anteriormente neste capítulo para as stored procedures.</p>
        <h2>Otimização para cargas de trabalho ad hoc</h2>
        <p>No SQL Server 2008 e versões posteriores, podemos usar a opção "<code>optimize for ad hoc workloads</code>", que é uma configuração em nível de servidor, ou seja, afetará todos os bancos de dados no servidor (ao contrário da parametrização forçada, que é específica do banco de dados).</p>
        <p>Com essa configuração habilitada, o SQL Server não armazena em cache o plano de uma consulta ad hoc na primeira vez em que ela é encontrada. Em vez disso, é armazenado um plano "stub" que indica apenas que a consulta foi vista anteriormente. Somente se a consulta for vista novamente é que o plano será armazenado em cache. Isso não reduz o número de compilações para consultas ad hoc, mas torna menos provável que o cache de planos cresça tanto, pois o stub inicial ocupa muito pouca memória. Assim, reduz as chances de que outros planos que poderiam ser reutilizáveis sejam descartados devido à pressão de memória.</p>
        <p>Para habilitar a configuração "<code>optimize for ad hoc workloads</code>", use o procedimento armazenado <code>sp_configure</code>, conforme mostrado na Listagem 3.21.</p>
        <pre>
            <code>
        EXEC sp_configure 'show advanced options',1
        RECONFIGURE
        EXEC sp_configure 'optimize for ad hoc workloads',1
        RECONFIGURE
            </code>
        </pre>
        <p><strong>Listagem 3.21</strong>: Habilitando a configuração "<code>optimize for ad hoc workloads</code>".</p>
        <h3>Paralelismo inadequado</h3>
        <p>O SQL Server é projetado para ser capaz de aproveitar vários processadores ao processar solicitações de usuários. O paralelismo de consulta é o mecanismo usado pelo mecanismo de execução de consulta do SQL para dividir o trabalho de uma consulta em várias threads, cada uma das quais será executada em um agendador separado. As consultas são paralelizadas no nível do operador; em outras palavras, se a consulta for executada em paralelo, alguns dos operadores da consulta podem ser executados em sua forma paralela, enquanto outros não.</p>
        <img src="imagens/fig38.PNG" alt="Plano de execução mostrando que os operadores estão sendo executados em paralelo">
        <p><strong>Figura 3.8</strong>: Plano de execução mostrando que os operadores estão sendo executados em paralelo.</p>
        <p>Quando uma consulta é enviada para processamento no SQL Server, o otimizador de consulta compila um plano de execução otimizado para permitir que a consulta seja executada da maneira mais rápida possível. Se o custo estimado de executar o plano serialmente exceder a opção '<code>cost threshold for parallelism</code>' do <code>sp_configure</code>, o número de CPUs lógicas disponíveis para o SQL Server for maior que um, e a opção '<code>max degree of parallelism</code>' do <code>sp_configure</code> estiver definida como o valor padrão de zero ou maior que um, o plano gerado incluirá o paralelismo. O Grau de Paralelismo (DOP) não é incluído como parte do plano; isso é determinado no momento da execução com base no número de processadores lógicos, na opção '<code>max degree of parallelism</code>' do <code>sp_configure</code> ou, se estiver sendo usado o hint <code>MAXDOP</code> na consulta, o valor especificado pelo hint, e no número de threads de trabalho disponíveis.</p>
        <p>O processamento de consultas paralelas pode reduzir o tempo necessário para processar uma consulta, particionando horizontalmente os dados de entrada, distribuindo as partições em várias CPUs lógicas e executando simultaneamente a mesma operação em vários núcleos do processador. Isso pode ser muito benéfico para operações de data warehouse e relatórios, que possuem algumas consultas grandes que lidam com volumes de dados e ocorrem apenas algumas solicitações simultaneamente. Ao dividir a solicitação em várias threads do sistema operacional em vários núcleos do processador, o otimizador aumenta a utilização dos recursos de hardware, distribuindo a carga entre todos os processadores no servidor, resultando em uma redução do tempo total de execução.</p>
        <p>O impacto específico de uma carga de trabalho paralela depende de vários fatores, incluindo a capacidade dos demais componentes de hardware do sistema para lidar com as demandas intensas de alocação de memória e E/S de disco que uma carga de trabalho paralela pode gerar. Quando o paralelismo é usado de forma apropriada, em consultas de alto custo, pode ter um efeito muito benéfico no desempenho geral do servidor. No entanto, pode ser muito prejudicial para ambientes OLTP, nos quais a carga de trabalho consiste em várias consultas menores executando simultaneamente, pois a operação paralela pode utilizar todos os núcleos do processador no servidor, fazendo com que outras solicitações aguardem para executar. Se o uso principal do servidor for um banco de dados OLTP com muitas solicitações menores e concorrentes, o paralelismo de uma única consulta comum pode reduzir a taxa de transferência.</p>
        <p>Conforme mencionado acima, o SQL Server possui duas opções de configuração que controlam a execução paralela de consultas pelo mecanismo. Elas são as opções de configuração <code>cost threshold for parallelism</code> e <code>max degree of parallelism</code> do <code>sp_configure</code>. A opção <code>max degree of parallelism</code> existe para evitar que uma única consulta utilize todos os núcleos do processador em um SQL Server. A opção <code>cost threshold for parallelism</code> existe para controlar o limite para uma consulta que faz com que o otimizador use o paralelismo para executar a consulta.</p>
        <p>Com muita frequência, quando surgem problemas de CPU relacionados a "paralelismo inadequado", a solução sugerida parece se concentrar apenas em alterar o valor para <code>max degree of parallelism</code>. Por exemplo, uma rápida pesquisa online do problema, especialmente do tipo de espera <code>CXPACKET</code> (um indicador clássico de problemas relacionados a paralelismo, como discutido um pouco mais adiante), resultará em numerosas postagens que recomendam reduzir o <code>max degree of parallelism</code> para metade ou um quarto do número de processadores lógicos ou núcleos do processador no servidor, ou até mesmo desabilitar completamente o paralelismo definindo-o como 1. Embora isso possa resolver o problema, pode não ser a solução ideal. A melhor solução é considerar, em conjunto, o valor apropriado para cada uma dessas opções.</p>
        <h2>Custo limite para paralelismo</h2>
        <p>Como discutido, a opção de configuração <code>cost threshold for parallelism</code> determina um limiar de "custo" que, quando excedido, faz com que um plano de execução paralela seja gerado para executar a solicitação do usuário. A execução paralela é possível apenas em sistemas de vários processadores, portanto, a opção de <code>cost threshold for parallelism</code> só é utilizada pelo mecanismo de banco de dados quando existem vários processadores, o servidor não está afetado a um único processador e o <code>max degree of parallelism</code> é definido como um valor diferente de 1.</p>
        <p>O "custo" é a quantidade estimada de tempo em segundos que levaria para executar a consulta de forma sequencial, com base em um plano de execução específico. O valor padrão é cinco, o que significa que um plano paralelo só será gerado e utilizado por consultas que tenham uma estimativa de tempo de execução sequencial superior a cinco segundos no sistema em questão. Em bancos de dados maiores, esse limite pode ser baixo o suficiente para causar múltiplas execuções concorrentes de consultas comuns, resultando em contenção no sistema.</p>
        <p>Para determinar qual pode ser uma configuração adequada para a opção de <code>cost threshold for parallelism</code>, é possível consultar os planos existentes no cache de planos para determinar os custos associados aos planos que foram executados com paralelismo, conforme mostrado no Exemplo 3.22.</p>
        <pre>
            <code>
        SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED ;
        
        WITH XMLNAMESPACES
           (DEFAULT 'http://schemas.microsoft.com/sqlserver/2004/07/showplan')
        SELECT query_plan AS CompleteQueryPlan ,
           n.value('(@StatementText)[1]', 'VARCHAR(4000)') AS StatementText ,
           n.value('(@StatementOptmLevel)[1]', 'VARCHAR(25)')
                     AS StatementOptimizationLevel ,
           n.value('(@StatementSubTreeCost)[1]', 'VARCHAR(128)')
                     AS StatementSubTreeCost ,
           n.query('.') AS ParallelSubTreeXML ,
           ecp.usecounts ,
           ecp.size_in_bytes
        FROM   sys.dm_exec_cached_plans AS ecp
           CROSS APPLY sys.dm_exec_query_plan(plan_handle) AS eqp
           CROSS APPLY query_plan.nodes
                  ('/ShowPlanXML/BatchSequence/Batch/Statements/StmtSimple')
           AS qn ( n )
        WHERE n.query('.').exist('//RelOp[@PhysicalOp="Parallelism"]') = 1
            </code>
        </pre>
        <p><strong>Exemplo 3.22</strong>: Determinando o custo estimado dos planos de execução paralela.</p>
        <p>A análise das declarações mais frequentemente executadas que resultam em consultas paralelas pode orientar a configuração apropriada da opção de <code>cost threshold for parallelism</code>, a fim de minimizar o impacto de várias solicitações paralelas executadas simultaneamente, que geram contenção de CPU e E/S no sistema.</p>
        <h2>Grau máximo de paralelismo</h2>
        <p>Sempre que o custo estimado de executar uma consulta serialmente exceder nosso valor cuidadosamente avaliado para o <code>cost threshold for parallelism</code>, o mecanismo do banco de dados pode distribuir a carga de execução dessa consulta entre vários processadores disponíveis, de acordo com o grau de paralelismo ditado pela opção <code>max degree of parallelism</code>. O número de processadores utilizados será determinado pelo valor mais baixo dos três seguintes:</p>
        <ul>
            <li>número de processadores disponíveis</li>
            <li>opção <code>max degree of parallelism</code></li>
            <li>dica de consulta MAXDOP fornecida para a consulta em execução (que substitui o valor especificado por <code>max degree of parallelism</code>).</li>
        </ul>
        <p>Geralmente, como discutimos, o valor apropriado para a opção <code>max degree of parallelism</code> depende em grande parte do tipo de carga de trabalho sendo executada e da capacidade dos outros subsistemas de hardware para lidar com a carga adicional associada à execução paralela no sistema. Se o sistema estiver apresentando problemas relacionados à paralelização (consulte a seção <em>Diagnosticando paralelismo inadequado</em>), pode ser necessário limitar o grau de paralelismo, em conjunto com a sintonização do cost threshold for parallelism para resolver o problema.</p>
        <p>Uma das recomendações mais comuns online é desabilitar completamente a paralelização definindo <code>max degree of parallelism</code> como 1. Existem casos em que essa configuração pode fazer sentido, por exemplo, em cargas de trabalho verdadeiramente OLTP, onde todas as transações são pequenas e muitas transações estão sendo executadas em simultâneo. Esses tipos de bancos de dados raramente existem hoje em dia, e desabilitar completamente a paralelização é mais provável de reduzir o desempenho a longo prazo.</p>
        <p>Ao longo dos anos, fiz várias recomendações diferentes sobre como configurar o <code>max degree of parallelism</code>. Por exemplo, em um sistema SMP, defini-lo como metade do número de núcleos físicos do processador disponíveis, ou como o número de núcleos físicos em um único chip de processador, ou até mesmo definindo-o como 1 para desabilitar completamente a paralelização. Hoje em dia, faço uma recomendação com base na análise da carga de trabalho da consulta e na revisão dos tipos de espera dos trabalhadores associados e subtarefas que estão sendo executados usando a paralelização.</p>
        <p>Em particular, analisarei as ocorrências do tipo de espera de sessão <code>CXPACKET</code>. Na maioria dos sistemas, o <code>CXPACKET</code> é o sintoma e não o problema; geralmente, há um tipo de espera subjacente diferente que pode ser observado em <code>sys.dm_os_waiting_tasks</code> para a sessão. Ao focar nesse tipo de espera, uma decisão melhor sobre a opção apropriada <code>max degree of parallelism</code> pode ser tomada. Por exemplo, se o tipo de espera subjacente for <code>PAGEIOLATCH_SH</code>, então a operação paralela está esperando uma leitura do subsistema de E/S de disco, e reduzir o <code>max degree of parallelism</code> não resolverá o problema raiz; apenas reduzirá o número de trabalhadores sendo usados no sistema e reduzirá o tempo acumulado de espera para o tipo de espera <code>CXPACKET</code>. No entanto, isso pode reduzir a carga adicional que as operações de paralelismo exercem no subsistema de E/S de disco e dar tempo para aumentar o desempenho de E/S do servidor.</p>
        <p>Existem, no entanto, algumas considerações específicas relacionadas à arquitetura de memória dos processadores. Em sistemas baseados em NUMA (Acesso Não Uniforme à Memória), a opção <code>max degree of parallelism</code> deve ser definida como o número mínimo de processadores disponíveis em um único nó NUMA. Isso é feito para evitar o processamento paralelo entre nós, o que gera um custo significativo, pois o compartilhamento de memória entre nós é uma operação dispendiosa.</p>
        <p>Em sistemas de Multiprocessamento Simétrico (SMP), um dos compromissos com vários núcleos de processador em um único chip é o uso de caches L2 compartilhados entre vários núcleos, o que pode resultar em falhas de cache para aplicativos que consomem muita memória, como o SQL Server, e afetar o desempenho de cargas de trabalho altamente concorrentes em níveis mais elevados de paralelismo. Aqui, o valor apropriado para essa opção depende em grande parte do tipo de carga de trabalho sendo executada e da capacidade dos outros subsistemas de hardware para lidar com a carga adicional associada à execução paralela no sistema.</p>
        <p>Finalmente, observe que no SQL Server 2008 e posterior, o resource governor pode ser usado para impor um <code>max degree of parallelism</code> para grupos de consultas, com base em várias propriedades de conexão. Portanto, seria possível limitar consultas de um aplicativo, um conjunto específico de logins ou nomes de host específicos a um determinado <code>max degree of parallelism</code> e permitir que outras consultas sejam ilimitadas.</p>
        <h2>Hyper-threading e paralelismo</h2>
        <p>O Hyper-threading é uma tecnologia da Intel projetada para melhorar a execução paralela, apresentando ao sistema operacional dois núcleos lógicos para cada núcleo físico. Isso significa que, em vez de um agendador por núcleo do processador, você tem dois, e assim dois threads podem ser executados "simultaneamente".</p>
        <p><strong><em>Processadores AMD e dois threads fortes</em></strong></p>
        <em>Arquiteturas modernas de processadores AMD, como a Bulldozer, utilizam uma abordagem diferente para o encadeamento, chamada de <strong>dois threads fortes</strong>, com um design que oferece hardware dedicado para cada um dos dois threads. Não discutiremos mais esse tópico aqui, mas mais informações podem ser encontradas no site da AMD: </em><a href="http://www.anandtech.com/show/3863/amd-discloses-bobcat-bulldozer-architectures-at-hot-chips-2010" target="_blank" rel="external">http://www.anandtech.com/show/3863/amd-discloses-bobcat-bulldozer-architectures-at-hot-chips-2010</a>.
        <p>Uma pergunta comumente feita nos fóruns online é se o hyper-threading deve ser ativado para o SQL Server e como essas decisões são afetadas pelo tipo de carga de trabalho.</p>
        <p>Como discutido anteriormente, para uma carga de trabalho OLAP ou DSS, o desempenho da execução da consulta se beneficiará ao permitir que o otimizador de consultas paralelize consultas individuais. Isso certamente é verdade quando existem um grande número de núcleos de CPU físicos, mas, nas implementações iniciais do hyper-threading, a experiência da maioria dos DBAs foi que as consultas complexas que compunham uma carga de trabalho típica de OLAP/DSS apresentavam um desempenho ruim ao serem paralelizadas em vários núcleos hiper-threaded. Uma consulta típica e curta de OLTP era menos afetada ao ser executada em um núcleo lógico, em oposição a um físico, portanto, ativar o hyper-threading para uma carga de trabalho OLTP poderia trazer benefícios da paralelização no sentido de que mais núcleos estariam disponíveis para processar mais consultas em um determinado período de tempo.</p>
        <p>No entanto, vários problemas arquiteturais com implementações antigas de hyper-threading, que se tornaram cada vez mais problemáticos à medida que a carga da CPU em um servidor aumentava, fizeram com que a maioria dos DBAs simplesmente desabilitasse o hyper-threading no BIOS, independentemente do tipo de carga de trabalho.</p>
        <p>Ainda há alguns anos, quando o SQL Server 2008 RTM foi lançado pela primeira vez, o conselho de desativar o hyper-threading para o SQL Server, especialmente para cargas de trabalho de DW/OLAP/DSS, era geralmente correto. O maior problema com processadores mais antigos e o hyper-threading estava relacionado ao tamanho dos caches internos, que são compartilhados quando o hyper-threading está habilitado. O tamanho menor do cache significava que ocorriam muitas falhas de cache para aplicativos dependentes de memória, como o SQL Server. Outra questão no início era que o Windows Server 2000 não tinha suporte para hyper-threading, então, quando você tinha um servidor com dois processadores com hyper-threading ativado, o Windows pensava que tinha quatro processadores físicos e agendava a execução simultânea em ambos os threads de um processador quando sob carga.</p>
        <p>No entanto, avanços e melhorias recentes em hardware, no Windows e na implementação do hyper-threading significam que é simplesmente incorreto desativar o hyper-threading como regra geral. Muitos dos problemas iniciais não existem mais. Por exemplo, o Windows Server 2003 e versões posteriores têm suporte para hyper-threading e, portanto, reconhecem dois processadores físicos e dois processadores lógicos, e tratam o agendamento de forma diferente para acomodar o fato de dois dos processadores lógicos serem provenientes do hyper-threading. Além disso, os processadores mais recentes possuem caches muito maiores (MB em vez de KB); eles são menos propensos a problemas de falhas de cache e são mais adequados para usar o hyper-threading com implementações dependentes de memória, como o SQL Server, especialmente no Windows Server 2008.</p>
        <p>Na verdade, com arquiteturas recentes de processadores, especialmente Intel Nehalem e posteriores, meu conselho é habilitar o hyper-threading, a menos que você encontre um bom motivo para desativá-lo. Certamente é um erro desabilitar o hyper-threading sem primeiro testar completamente sua carga de trabalho do aplicativo com o hyper-threading habilitado e, em seguida, desabilitado, para realmente saber se há benefícios em ter o hyper-threading ativado ou desativado.</p>
        <p>É claro que, à medida que processadores com oito ou até doze núcleos físicos surgem no mercado, torna-se mais fácil alcançar altos níveis de paralelismo sem a necessidade do hyper-threading. No entanto, a tecnologia continua sendo fundamental para os processadores modernos da Intel (por exemplo, o processador Xeon E7-4870, para servidores de 4 soquetes, possui dez núcleos físicos <em>mais</em> hyper-threading), e com a maioria das arquiteturas de processadores recentes, há uma boa chance de você ver benefícios de desempenho e/ou throughput tanto para cargas de trabalho de DW/OLAP quanto de OLTP.</p>
        <h2>Diagnosticando paralelismo inadequado</h2>
        <p>A melhor maneira de determinar se o processamento paralelo está causando um gargalo de recursos em um sistema específico é analisar as estatísticas de espera (wait statistics) e estatísticas de latch (latch statistics) de uma instância do SQL Server. Quando ocorre um gargalo durante a execução paralela de uma consulta, o tipo de espera <code>CXPACKET</code> é exibido como uma das principais esperas do SQL Server. Esse tipo de espera é definido sempre que um processo paralelo precisa aguardar no iterador de troca (exchange iterator) para que outro worker continue o processamento. Como discutido anteriormente, quando isso acontece, geralmente existe um tipo de espera subjacente, não relacionado ao <code>CXPACKET</code>, que está associado ao worker paralisado. No entanto, como vários workers são forçados a esperar quando isso ocorre, a quantidade de esperas <code>CXPACKET</code> geralmente excede o tipo de espera subjacente.</p>
        <p>Sempre que possível, é melhor isolar e solucionar o tipo de espera subjacente, pois isso levará a melhorias gerais no throughput do sistema. As esperas <code>CXPACKET</code> são apenas um sintoma do problema na maioria dos casos, e não o problema real. Existem cenários em que pode não ser possível eliminar o tipo de espera subjacente; por exemplo, quando o subsistema de E/S em disco não consegue acompanhar a demanda exigida pela execução paralela de uma consulta, o tipo de espera raiz pode ser <code>IO_COMPLETION</code>, <code>ASYNC_IO_COMPLETION</code> ou <code>PAGEIOLATCH_*</code>, e dimensionar o subsistema de E/S não é possível. Quando isso ocorre, reduzir o nível de paralelismo a um grau que ainda permita o processamento paralelo ocorrer sem gargalos no subsistema de E/S em disco pode melhorar o desempenho geral do sistema. É possível que as esperas <code>CXPACKET</code> em conjunto com outros tipos de espera, como <code>LATCH_*</code> e <code>SOS_SCHEDULER_YIELD</code>, indiquem que o paralelismo é o problema real, e uma investigação adicional das estatísticas de latch no sistema validará se esse é realmente o caso. A visão de gerenciamento dinâmico <code>sys.dm_os_latch_stats</code> contém informações sobre as esperas de latch específicas que ocorreram na instância, e se uma das principais esperas de latch for <code>ACCESS_METHODS_DATASET_PARENT</code>, em conjunto com <code>CXPACKET</code>, <code>LATCH_*</code> e <code>SOS_SCHEDULER_YIELD</code> como as principais esperas, o nível de paralelismo no sistema é a causa do gargalo durante a execução da consulta, e pode ser necessário reduzir a opção <code>max degree of parallelism</code> no sp_configure para resolver os problemas.</p>
        <h2>Resolvendo problemas de paralelismo</h2>
        <p>Conforme discutido anteriormente, consultas maiores e de longa duração geralmente se beneficiarão da execução paralela, uma vez que o custo de executar a consulta de forma serial é maior do que o custo associado à inicialização, sincronização e término dos trabalhadores paralelos na execução paralela da consulta. O paralelismo inadequado ocorre mais comumente em casos em que a natureza da carga de trabalho é "mista", ou seja, temos uma carga de trabalho essencialmente de OLTP, caracterizada por um grande número de transações curtas, mas onde algumas dessas transações são complexas o suficiente para exceder o <code>cost threshold for parallelism</code>, e o SQL Server paraleliza sua execução em todos os núcleos disponíveis, consumindo recursos de CPU.</p>
        <p>Quando são diagnosticados problemas relacionados ao paralelismo, o primeiro remédio a ser investigado é otimizar as consultas que estão sendo paralelizadas de forma inadequada, caso ainda não estejam ajustadas. O paralelismo inadequado pode facilmente ser resultado de índices ausentes ou inadequados, estatísticas desatualizadas ou consultas mal escritas. Em outras palavras, ao ajustar essas consultas, elas deixarão de exceder o <code>cost threshold for parallelism</code> e, assim, serão executadas naturalmente em um único núcleo de CPU.</p>
        <p>Se a carga de trabalho estiver ajustada da melhor forma possível e os problemas de paralelismo persistirem, então a opção <code>cost threshold for parallelism</code> deve ser usada em conjunto com a opção <code>max degree of parallelism</code> para gerenciar a execução paralela no sistema como um todo.</p>
        <h3>TokenAndPermUserStore</h3>
        <p>O cache <code>TokenAndPermUserStore</code> foi introduzido no SQL Server 2005 como uma otimização que permitiria o armazenamento em cache dos resultados das verificações de permissões pelos usuários em relação aos objetos do banco de dados. No entanto, esse cache poderia ser a causa de problemas de desempenho, especialmente nas versões anteriores do SQL Server 2005, devido aos limites de tamanho do cache serem muito altos. Os problemas de desempenho geralmente se manifestavam como uso excessivamente alto da CPU e threads com altos tempos de espera <code>CMEMTHREAD</code>. Esta seção abordará como identificar problemas associados ao cache <code>TokenAndPermUserStore</code>, soluções temporárias, hotfixes da Microsoft para o problema, bem como a solução a longo prazo.</p>
        <p>O problema é discutido no artigo da Base de Conhecimento 927396 (<a href="http://support.microsoft.com/kb/927396" target="_blank" rel="external">http://support.microsoft.com/kb/927396</a>) e tende a se manifestar nas seguintes circunstâncias:</p>
        <ul>
            <li>grandes quantidades de memória não-AWE alocadas para o SQL Server (isso significa que o problema é específico para o SQL de 64 bits)</li>
            <li>muitas consultas SQL dinâmicas ou ad hoc</li>
            <li>muitos usuários de banco de dados diferentes.</li>
        </ul>
        <p>Para investigar possíveis problemas relacionados ao cache <code>TokenAndPermUserStore</code>, acompanhe o tamanho do cache ao longo de um período de tempo, usando a consulta mostrada na Listagem 3.23.</p>
        <pre>
            <code>
        SELECT SUM(single_pages_kb + multi_pages_kb) / 1024.0 AS CacheSizeMB
        FROM   sys.dm_os_memory_clerks
        WHERE  [name] = 'TokenAndPermUserStore'
            </code>
        </pre>
        <p><strong>Listagem 3.23</strong>: Encontrando o tamanho do cache TokenAndPermUserStore.</p>
        <p>Se o cache crescer constantemente em tamanho e esse crescimento for acompanhado por consultas em espera com o tipo de espera CMEMTHREAD, então o tamanho do cache pode ser a causa do alto uso da CPU.</p>
        <p>Se você estiver usando o SQL Server 2005 e o nível de patch estiver abaixo do SP2, a primeira coisa a fazer é aplicar pelo menos o SP2 e, de preferência, o SP4, pois foram feitas melhorias no gerenciamento desse cache no SP2.</p>
        <p>No entanto, a melhor solução a longo prazo é uma mudança arquitetural para reduzir o uso de consultas ad hoc ou SQL dinâmicas e mover o máximo possível de lógica para stored procedures. Dependendo da arquitetura da aplicação, isso pode variar de trivial a impossível, mas deve ser considerado, pois isso quase elimina a chance de encontrar esse problema.</p>
        <h2>Soluções temporárias no SQL Server 2005</h2>
        <p>Se essas medidas não forem imediatamente possíveis, existem algumas soluções temporárias para esse problema no SQL Server 2005.</p>
        <h3>Use a função de servidor sysadmin</h3>
        <p>Tornando a conta de serviço da aplicação um membro da função de servidor <code>sysadmin</code>, qualquer verificação de permissões é contornada e o problema é resolvido. A suposição é que a conta pode executar qualquer operação dentro do SQL Server e, portanto, não requer verificações de permissões adicionais.</p>
        <p>Essa solução está longe de ser ideal, pois fornece permissões elevadas à conta de serviço. Em uma situação urgente, ela proporcionará alívio temporário para os problemas associados ao alto uso da CPU. No entanto, se funcionar e provar que o cache <code>TokenAndPermUserStore</code> é a causa raiz, você deve imediatamente determinar se outra solução pode ser utilizada em vez disso para resolver o problema.</p>
        <h3>Limpe regularmente o cache</h3>
        <p>Usando um trabalho do SQL Agent e o comando mostrado na Listagem 3.24, você pode regularmente liberar espaço no cache <code>TokenAndPermUserStore</code>.</p>
        <pre><code>DBCC FREESYSTEMCACHE ('TokenAndPermUserStore')</code></pre>
        <p><strong>Listagem 3.24</strong>: Liberando espaço no cache <code>TokenAndPermUserStore</code>.</p>
        <p>Novamente, isso deve ser feito apenas em casos extremos e como uma solução temporária. No entanto, isso irá controlar o tamanho do cache até que uma solução de longo prazo possa ser aplicada.</p>
        <h3>Trace Flags</h3>
        <p>No SQL 2005 SP2 ou posterior, a Flag de Trace 4618 e/ou a Flag de Trace 4610 podem ser habilitadas. A Flag de Trace 4618 restringe o número de entradas que o cache irá armazenar para 1024 e, se ambas as flags estiverem habilitadas, o número de entradas no cache é limitado a 8192. Restringir o número de entradas que o cache irá armazenar deve ser usado temporariamente, enquanto outras soluções são consideradas.</p>
        <p>Uma última opção de alteração de configuração no SQL 2005, se estiver no SP3 ou posterior, é habilitar a Flag de Trace 4621. Isso permite definir uma cota personalizada. Para obter detalhes sobre como configurar isso, consulte o artigo da Base de Conhecimento 959823 (<a href="http://support.microsoft.com/kb/959823" target="_blank" rel="external">http://support.microsoft.com/kb/959823</a>).</p>
        <h2>Opções de configuração no SQL Server 2008</h2>
        <p>Com o SQL Server 2008, foram introduzidas as opções de configuração <code>access check cache bucket count</code> e <code>access check cache quota</code>. Essas opções controlam o número de entradas e o número de buckets de hash usados pelo cache <code>TokenAndPermUserStore</code>. O cache não deve causar os mesmos problemas no SQL 2008 como ocorria no SQL 2005, mas se os problemas surgirem, a cota pode ser definida para um número menor e/ou o número de buckets de hash pode ser aumentado. Alterar essas configurações pode reduzir o tempo necessário para localizar as entradas do cache. No entanto, essa alteração de configuração não é recomendada, a menos que seja orientada pelo Suporte ao Cliente da Microsoft, mas deve ser observada como uma área para solução de problemas.</p>
        <h3>Opções de economia de energia do Windows Server e BIOS</h3>
        <p>Como parte das iniciativas de computação sustentável, muitos fabricantes de hardware enviam novos desktops, laptops e até mesmo servidores destinados ao uso em datacenters com a configuração avançada de controle de energia definida de modo que o sistema operacional, ou o próprio hardware, possa reduzir automaticamente o consumo de energia e os requisitos de resfriamento do sistema, desligando dispositivos que não estão sendo usados e reduzindo a velocidade dos processadores instalados no servidor. Infelizmente, isso pode ter um impacto bastante negativo no desempenho do processador.</p>
        <p>Essas configurações de economia de energia baseadas em hardware podem ser configuradas no BIOS do sistema principal para permitir que o hardware controle o consumo de energia (<code>Hardware</code>), permitir que o sistema operacional Windows controle o gerenciamento de energia (<code>Controle do SO</code>) ou desativar completamente os recursos de gerenciamento de energia (<code>Nenhum</code>). Em geral, a opção padrão no BIOS é permitir que o sistema operacional controle os recursos de gerenciamento de energia do sistema com base em suas opções configuradas.</p>
        <p>O Windows Server 2008 e o 2008 R2 têm como configuração padrão a opção de gerenciamento de energia <code>Equilibrado</code> (Windows Power Plan), que permite que o sistema mude para um estado de baixo desempenho para reduzir o consumo de energia. Uma das surpresas que muitas pessoas tiveram ao atualizar seus sistemas em hardware de servidor mais recente com o Windows Server 2008 ou 2008 R2 instalado é que o desempenho geral diminui após um certo período de tempo e acaba sendo significativamente menor do que quando o servidor foi inicializado pela primeira vez. Isso é resultado direto das características de gerenciamento de energia que causam a redução da velocidade dos processadores no servidor.</p>
        <p>Para identificar se esse é um problema em seu sistema, você pode usar uma ferramenta gratuita chamada CPU-Z, disponível em <a href="http://www.cpuid.com/softwares/cpu-z/versions-history.html" target="_blank" rel="external">http://www.cpuid.com/softwares/cpu-z/versions-history.html</a>, para coletar informações sobre o estado atual dos processadores instalados em um servidor. Não discutiremos em detalhes essa ferramenta aqui, mas os valores importantes a serem observados em relação aos problemas de gerenciamento de energia são a <strong>Especificação da CPU</strong>, que mostra o tipo de processador e sua velocidade de clock nominal, e a <strong>Velocidade do Núcleo</strong>, que mostra a velocidade de clock atual dos processadores no sistema. Se a Velocidade do Núcleo for menor que a especificação nominal, significa que o gerenciamento de energia está reduzindo o desempenho do sistema.</p>
        <p>O primeiro passo é verificar o esquema atual de gerenciamento de energia do Windows. Se estiver definido como <strong>Equilibrado</strong>, altere-o para <strong>Alto Desempenho</strong>, o que impede que o sistema mude para um estado de baixo desempenho e garante que as características de desempenho do sistema sejam consistentes (consulte <a href="http://support.microsoft.com/kb/2207548" target="_blank" rel="external">http://support.microsoft.com/kb/2207548</a>). Se o <strong>Alto Desempenho</strong> estiver sendo usado pelo Windows, a configuração do BIOS também deve ser verificada. Se estiver definido como <strong>Hardware</strong>, altere para <strong>Controle do SO</strong>.</p>
        <p>O que é insidioso aqui é o impacto que a economia de energia tem no contador de desempenho <code>% Processor Usage</code>. O valor desse contador é calculado com base na frequência atual da CPU dividida pela frequência disponível da CPU. Assim, uma CPU com velocidade reduzida faz com que o Windows relate valores de uso da CPU mais altos, levando as pessoas a acreditar que o servidor está sob uma carga mais pesada do que realmente está.</p>
        <h2>Resumo</h2>
        <p>Uma má gestão da utilização da CPU pode ter um impacto dramático no desempenho do SQL Server. Em geral, o uso sustentado da CPU em uma máquina do SQL Server não deve exceder 60-70%. Picos ocasionais para valores mais altos não devem ser um problema, mas um uso mais intenso e sustentado indica que o servidor está sob uma carga severa de CPU.</p>
        <p>Quando surgem problemas de CPU e após confirmar que o alto uso da CPU se deve ao processo do SQL Server, o primeiro passo é isolar a origem do problema, utilizando informações de ferramentas como o Monitor de Desempenho (PerfMon), SQLTrace e as Visualizações de Gerenciamento Dinâmico do SQL Server, muitas das quais foram significativamente aprimoradas nas versões do SQL Server 2005 e 2008.</p>
        <p>Com o problema localizado, podem ser tomadas as medidas apropriadas para aliviar a pressão da CPU, que vão desde adicionar índices úteis e ajustar consultas que consomem muita CPU até alterar as configurações de configuração. Se todas essas medidas falharem, pode ser simplesmente necessário ter mais ou CPUs mais rápidas, juntamente com um melhor balanceamento da carga entre as CPUs e um agendamento mais eficiente das consultas intensivas em CPU.</p>
        <h2>Recursos adicionais</h2>
        <ul>
            <li>Conversas de dados implícitos</li>
            <ul><li><a href="http://sqlblog.com/blogs/jonathan_kehayias/archive/2010/01/08/findingimplicit-column-conversions-in-the-plan-cache.aspx" target="_blank" rel="external">http://sqlblog.com/blogs/jonathan_kehayias/archive/2010/01/08/findingimplicit-column-conversions-in-the-plan-cache.aspx</a></li></ul>
            <li>Ajuste de Consulta</li>
            <ul>
                <li><a href="http://www.straightpathsql.com/presentations/ucandoit/" target="_blank" rel="external">http://www.straightpathsql.com/presentations/ucandoit/</a></li>
                <li><a href="http://www.simple-talk.com/sql/performance/simple-query-tuning-with-statistics-io-and-execution-plans/" target="_blank" rel="external">http://www.simple-talk.com/sql/performance/simple-query-tuning-with-statistics-io-and-execution-plans/</a></li>
                <li><a href="http://www.simple-talk.com/sql/t-sql-programming/13-things-youshould-know-about-statistics-and-the-query-optimizer/" target="_blank" rel="external">http://www.simple-talk.com/sql/t-sql-programming/13-things-youshould-know-about-statistics-and-the-query-optimizer/</a></li>
                <li><a href="http://www.simple-talk.com/author/gail-shaw/" target="_blank" rel="external">http://www.simple-talk.com/author/gail-shaw/</a></li>
            </ul>
            <li>Quantidade estimada vs. quantidade real de linhas</li>
            <ul><li><a href="http://sqlinthewild.co.za/index.php/2009/09/22/estimated-rows-actual-rows-and-execution-count/" target="_blank" rel="external">http://sqlinthewild.co.za/index.php/2009/09/22/estimated-rows-actual-rows-and-execution-count/</a></li></ul>
            <li>Cost threshold for parallelism</li>
            <ul><li><a href="http://sqlblog.com/blogs/jonathan_kehayias/archive/2010/01/26/21172.aspx" target="_blank" rel="external">http://sqlblog.com/blogs/jonathan_kehayias/archive/2010/01/26/21172.aspx</a></li></ul>
            <li>Max degree of parallelism</li>
            <ul><li><a href="http://msdn.microsoft.com/en-us/library/ms181007.aspx" target="_blank" rel="external">http://msdn.microsoft.com/en-us/library/ms181007.aspx</a></li></ul>
            <li>Dicas de consulta</li>
            <ul><li><a href="http://msdn.microsoft.com/en-us/library/ms181714.aspx" target="_blank" rel="external">http://msdn.microsoft.com/en-us/library/ms181714.aspx</a></li></ul>
            <li>Diretrizes para modificar o MAXDOP</li>
            <ul><li><a href="http://support.microsoft.com/kb/329204" target="_blank" rel="external">http://support.microsoft.com/kb/329204</a></li></ul>
            <li>Limitando o MAXDOP com o Resource Governor</li>
            <ul><li><a href="http://www.sqlmag.com/blog/sql-server-questions-answered-28/database-administration/controlling-maxdop-executing-queries-140163" target="_blank" rel="external">http://www.sqlmag.com/blog/sql-server-questions-answered-28/database-administration/controlling-maxdop-executing-queries-140163</a></li></ul>
            <li>Configuração do Parallelism/MAXDOP</li>
            <ul>
                <li><a href="http://msdn.microsoft.com/en-us/library/ms178065.aspx" target="_blank" rel="external">http://msdn.microsoft.com/en-us/library/ms178065.aspx</a></li>
                <li><a href="http://msdn.microsoft.com/en-us/library/ms188611.aspx" target="_blank" rel="external">http://msdn.microsoft.com/en-us/library/ms188611.aspx</a></li>
                <li><a href="http://blogs.msdn.com/b/joesack/archive/2009/03/18/should-you-worryabout-sos-scheduler-yield.aspx"  target="_blank" rel="external">http://blogs.msdn.com/b/joesack/archive/2009/03/18/should-you-worryabout-sos-scheduler-yield.aspx</a></li>
            </ul>
            <li>Arquitetura do SQLOS</li>
            <ul>
                <li><a href="http://blogs.msdn.com/b/sqlosteam/archive/2010/06/23/sqlos-resources.aspx" target="_blank" rel="external">http://blogs.msdn.com/b/sqlosteam/archive/2010/06/23/sqlos-resources.aspx</a></li>
                <li><a href="http://sqlblogcasts.com/blogs/sqlworkshops/archive/2007/11/25/" target="_blank" rel="external">http://sqlblogcasts.com/blogs/sqlworkshops/archive/2007/11/25/</a></li>
            </ul>findingoptimal-number-of-cpus-for-a-given-long-running-cpu-intensive-dss-olaplike-queries-workload.aspx</li>
            <li>Contadores de CPU do Monitor do Sistema</li>
            <ul><li><a href="http://msdn.microsoft.com/en-us/library/ms178072.aspx" target="_blank" rel="external">http://msdn.microsoft.com/en-us/library/ms178072.aspx</a></li></ul>
            <li>Uso de DMV para o uso de CPU a partir dos buffers em anel</li>
            <ul>
                <li><a href="http://troubleshootingsql.com/2009/12/30/how-to-find-out-the-cpuusage-information-for-the-sql-server-process-using-ring-buffers/" target="_blank" rel="external">http://troubleshootingsql.com/2009/12/30/how-to-find-out-the-cpuusage-information-for-the-sql-server-process-using-ring-buffers/</a></li>
                <li><a href="http://msdn.microsoft.com/en-us/library/ms175048(SQL.90).aspx" target="_blank" rel="external">http://msdn.microsoft.com/en-us/library/ms175048(SQL.90).aspx</a></li>
                <li><a href="http://technet.microsoft.com/en-us/library/cc966540.aspx" target="_blank" rel="external">http://technet.microsoft.com/en-us/library/cc966540.aspx</a></li>
            </ul>
            <li>Parametrização forçada</li>
            <ul><li><a href="http://technet.microsoft.com/en-us/library/ms175037(SQL.90).aspx" target="_blank" rel="external">http://technet.microsoft.com/en-us/library/ms175037(SQL.90).aspx</a></li></ul>
            <li>Corrigindo problemas de <code>TokenAndPermUserStore</code></li>
            <ul>
                <li>Identificação e visão geral</li>
                <ul><li><a href="http://support.microsoft.com/kb/927396" target="_blank" rel="external">http://support.microsoft.com/kb/927396</a></li></ul>
                <li>Cache de resultados de verificação de acesso</li>
                <ul>
                    <li><a href="http://support.microsoft.com/kb/955644" target="_blank" rel="external">http://support.microsoft.com/kb/955644</a></li>
                    <li><a href="http://msdn.microsoft.com/en-us/library/cc645588.aspx" target="_blank" rel="external">http://msdn.microsoft.com/en-us/library/cc645588.aspx</a></li>
                </ul>
                <li>"Eliminando o cache sempre que ele atinge um determinado tamanho"</li>
                <ul><li><a href="http://blogs.msdn.com/chrissk/archive/2008/06/19/script-to-purgetokenandpermuserstore.aspx" target="_blank" rel="external">http://blogs.msdn.com/chrissk/archive/2008/06/19/script-to-purgetokenandpermuserstore.aspx</a></li></ul>
                <li>Opções sp_configure no SQL Server 2008</li>
                <ul><li><a href="http://support.microsoft.com/kb/955644/en-us" target="_blank" rel="external">http://support.microsoft.com/kb/955644/en-us</a></li></ul>
                <li>Correções rápidas associadas a esse problema</li>
                <ul><li><a href="http://support.microsoft.com/kb/959823126" target="_blank" rel="external">http://support.microsoft.com/kb/959823126</a></li></ul>
            </ul>
            <a href="cap02.html" target="_self" rel="previous"><img src="imagens/previous.png" alt="Página anterior"></a>
            <a href="index.html" target="_self" rel="previous"><img src="imagens/index.png" alt="Página principal"></a>
            <a href="cap04.html" target="_self" rel="next"><img src="imagens/next.png" alt="Próxima página"></a>
        </ul>
    </main>
</body>
</html>